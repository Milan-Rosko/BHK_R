(* Note. This is a concatenation for establishing context. *)
(* Source: _CoqProject (builder) *)
(* Generated (UTC): 2026-01-26T22:41:26Z *)

(* ---- BEGIN _CoqProject (builder) ---- *)
(* # root *)
(* -docroot proofcase *)
(*  *)
(* # Logical Path Mappings *)
(*  *)
(* -Q theories/M001__BHK_R_Arithmetic/C000__BHK_R BHK_R.C000 *)
(* -Q theories/M001__BHK_R_Arithmetic/C001__Carryless_Pairing Carryless_Pairing.C001 *)
(* -Q theories/M001__BHK_R_Arithmetic/C002__Additive_Hilbert_System ATP.C002 *)
(* -Q theories/M002__Carryless_Proof_Theory/C003__Carryless_Diagonal_Lemma Diagonallemma.C003 *)
(* -Q theories/M002__Carryless_Proof_Theory/C004__Mirror_Lemma ATP.C004__Mirror_Lemma *)
(* -Q theories/M003__Delian_Barrier/C005__Adversarial_Barrier Adversarial_Barrier.C005 *)
(* -Q theories/M003__Delian_Barrier/C006__Audit_Barrier Audit_Barrier.C006 *)
(* -Q theories/M003__Delian_Barrier/C007__Resistance_Law Resistance_Law.C007 *)
(* -Q theories/M003__Delian_Barrier/C008__Reflexica_Normalization Reflexica_Normalization.C008 *)
(* -Q theories/M004__Conservation_of_Hardness/C009__SAT_Reduction SAT.C009 *)
(* -Q theories/M004__Conservation_of_Hardness/C010__Solvability_Thesis Solvability_Thesis.C010 *)
(* -Q theories/M004__Conservation_of_Hardness/C011__Quintic_Hardness Quintic_Hardness.C011 *)
(* -Q theories/M004__Conservation_of_Hardness/C012__Cubic_Incompleteness Cubic_Incompleteness.C012 *)
(* -Q theories/M004__Conservation_of_Hardness/C013__Logical_Cryptography Logical_Crypt.C012 *)
(* -Q theories/M004__Conservation_of_Hardness/C014__Fermat_Machine Fermat_Machine.C014 *)
(*  *)
(* # File List *)
(*  *)
(* # C000 *)
(*  *)
(* theories/M001__BHK_R_Arithmetic/C000__BHK_R/P0__BHK.v *)
(* theories/M001__BHK_R_Arithmetic/C000__BHK_R/P0__Reflexica.v *)
(*  *)
(* # C001 *)
(*  *)
(* theories/M001__BHK_R_Arithmetic/C001__Carryless_Pairing/P1_S__Substrate.v *)
(* theories/M001__BHK_R_Arithmetic/C001__Carryless_Pairing/P2_R__Carryless.v *)
(* theories/M001__BHK_R_Arithmetic/C001__Carryless_Pairing/P2_S__Carryless.v *)
(* theories/M001__BHK_R_Arithmetic/C001__Carryless_Pairing/P3_R__Injectivity.v *)
(* theories/M001__BHK_R_Arithmetic/C001__Carryless_Pairing/P3_S__Injectivity.v *)
(* theories/M001__BHK_R_Arithmetic/C001__Carryless_Pairing/P4_R__Pairing.v *)
(* theories/M001__BHK_R_Arithmetic/C001__Carryless_Pairing/P4_S__Pairing.v *)
(* theories/M001__BHK_R_Arithmetic/C001__Carryless_Pairing/P5_T__Carryless_Pairing.v *)
(* theories/M001__BHK_R_Arithmetic/C001__Carryless_Pairing/P5_T__Effectivity.v *)
(* theories/M001__BHK_R_Arithmetic/C001__Carryless_Pairing/P6_A__Reflexica_Certificate.v *)
(*  *)
(* # C002 *)
(*  *)
(* theories/M001__BHK_R_Arithmetic/C002__Additive_Hilbert_System/P1_S__Kernel_Spec.v *)
(* theories/M001__BHK_R_Arithmetic/C002__Additive_Hilbert_System/P2_R__Hilbert_Kernel.v *)
(* theories/M001__BHK_R_Arithmetic/C002__Additive_Hilbert_System/P2_S__Provability_Interface.v *)
(* theories/M001__BHK_R_Arithmetic/C002__Additive_Hilbert_System/P3_R__Additive_Laws.v *)
(* theories/M001__BHK_R_Arithmetic/C002__Additive_Hilbert_System/P3_S__Additive_Theory.v *)
(* theories/M001__BHK_R_Arithmetic/C002__Additive_Hilbert_System/P4_R__Coding_Nucleus.v *)
(* theories/M001__BHK_R_Arithmetic/C002__Additive_Hilbert_System/P4_R__Coding_Carryless.v *)
(* theories/M001__BHK_R_Arithmetic/C002__Additive_Hilbert_System/P4_S__Coding.v *)
(* theories/M001__BHK_R_Arithmetic/C002__Additive_Hilbert_System/P5_T__Proof_Theory.v *)
(* theories/M001__BHK_R_Arithmetic/C002__Additive_Hilbert_System/P6_P__Effectivity.v *)
(*  *)
(* # C003 *)
(*  *)
(* theories/M002__Carryless_Proof_Theory/C003__Carryless_Diagonal_Lemma/P1_S__Syntax.v *)
(* theories/M002__Carryless_Proof_Theory/C003__Carryless_Diagonal_Lemma/P2_R__Backend.v *)
(* theories/M002__Carryless_Proof_Theory/C003__Carryless_Diagonal_Lemma/P2_R__Compiler.v *)
(* theories/M002__Carryless_Proof_Theory/C003__Carryless_Diagonal_Lemma/P2_T__Diagonal.v *)
(* theories/M002__Carryless_Proof_Theory/C003__Carryless_Diagonal_Lemma/P3_T__Flip_Instance.v *)
(*  *)
(* # C004 *)
(*  *)
(* theories/M002__Carryless_Proof_Theory/C004__Mirror_Lemma/P1_S__Context.v *)
(* theories/M002__Carryless_Proof_Theory/C004__Mirror_Lemma/P2_R__Mirror_Core.v *)
(* theories/M002__Carryless_Proof_Theory/C004__Mirror_Lemma/P2_R__Mirror_Transport.v *)
(* theories/M002__Carryless_Proof_Theory/C004__Mirror_Lemma/P2_S__Mirror_Lemma.v *)
(* theories/M002__Carryless_Proof_Theory/C004__Mirror_Lemma/P3_S__Recursive_Mirror_Lemma.v *)
(* theories/M002__Carryless_Proof_Theory/C004__Mirror_Lemma/P3_T__Weakforcing.v *)
(*  *)
(* # C005 *)
(*  *)
(* theories/M003__Delian_Barrier/C005__Adversarial_Barrier/P1_S__Barrier_Definition.v *)
(* theories/M003__Delian_Barrier/C005__Adversarial_Barrier/P2_R__Barrier_Proof.v *)
(* theories/M003__Delian_Barrier/C005__Adversarial_Barrier/P2_T__Barrier.v *)
(* theories/M003__Delian_Barrier/C005__Adversarial_Barrier/P2_T__Mirror_Instance.v *)
(*  *)
(* # C006 *)
(*  *)
(* theories/M003__Delian_Barrier/C006__Audit_Barrier/P1_S__Context.v *)
(* theories/M003__Delian_Barrier/C006__Audit_Barrier/P2_R__Audit_Logic.v *)
(* theories/M003__Delian_Barrier/C006__Audit_Barrier/P2_T__Audit_Barrier.v *)
(* theories/M003__Delian_Barrier/C006__Audit_Barrier/P2_T__Audit_Adapter.v *)
(* theories/M003__Delian_Barrier/C006__Audit_Barrier/P3_A__Provability_Logic.v *)
(*  *)
(* # C007 *)
(*  *)
(* theories/M003__Delian_Barrier/C007__Resistance_Law/P1_S__Separation.v *)
(* theories/M003__Delian_Barrier/C007__Resistance_Law/P2_R__Resistance_Proof.v *)
(* theories/M003__Delian_Barrier/C007__Resistance_Law/P2_T__Resistance.v *)
(*  *)
(* # C008 *)
(*  *)
(* theories/M003__Delian_Barrier/C008__Reflexica_Normalization/P1_S__Core_Goal.v *)
(* theories/M003__Delian_Barrier/C008__Reflexica_Normalization/P2_R__The_Bridge.v *)
(* theories/M003__Delian_Barrier/C008__Reflexica_Normalization/P2_T__Reflexica_Derived.v *)
(* theories/M003__Delian_Barrier/C008__Reflexica_Normalization/P2_T__Public_Surface.v *)
(*  *)
(* # C009 *)
(*  *)
(* theories/M004__Conservation_of_Hardness/C009__SAT_Reduction/P1_S__CNF_Syntax.v *)
(* theories/M004__Conservation_of_Hardness/C009__SAT_Reduction/P2_R__Reduction.v *)
(* theories/M004__Conservation_of_Hardness/C009__SAT_Reduction/P3_T__Structural_Integrity.v *)
(* theories/M004__Conservation_of_Hardness/C009__SAT_Reduction/P1_S__Syntax.v *)
(* theories/M004__Conservation_of_Hardness/C009__SAT_Reduction/P2_R__Substitution.v *)
(* theories/M004__Conservation_of_Hardness/C009__SAT_Reduction/P3_R__Kernel.v *)
(* theories/M004__Conservation_of_Hardness/C009__SAT_Reduction/P3_T__FOL.v *)
(* theories/M004__Conservation_of_Hardness/C009__SAT_Reduction/P4_T__Kernel_Sanity.v *)
(* theories/M004__Conservation_of_Hardness/C009__SAT_Reduction/P4_T__Mechanism.v *)
(*  *)
(* # C010 *)
(*  *)
(* theories/M004__Conservation_of_Hardness/C010__Solvability_Thesis/P1_S__Thesis_Definition.v *)
(* theories/M004__Conservation_of_Hardness/C010__Solvability_Thesis/P2_R__Triviality_Proof.v *)
(* theories/M004__Conservation_of_Hardness/C010__Solvability_Thesis/P2_T__Normalization.v *)
(*  *)
(* # C011 *)
(*  *)
(* theories/M004__Conservation_of_Hardness/C011__Quintic_Hardness/P1_S__Diophantine_Basis.v *)
(* theories/M004__Conservation_of_Hardness/C011__Quintic_Hardness/P2_T__The_Quintic_Barrier.v *)
(*  *)
(* # C012 *)
(*  *)
(* theories/M004__Conservation_of_Hardness/C012__Cubic_Incompleteness/P1_S__Structure.v *)
(* theories/M004__Conservation_of_Hardness/C012__Cubic_Incompleteness/P2_S__Barrier.v *)
(* theories/M004__Conservation_of_Hardness/C012__Cubic_Incompleteness/P3_T__Theorem.v *)
(*  *)
(* # C013 *)
(*  *)
(* theories/M004__Conservation_of_Hardness/C013__Logical_Cryptography/P1_T__Trapdoor_Theorem.v *)
(*  *)
(* # C014 *)
(* theories/M004__Conservation_of_Hardness/C014__Fermat_Machine/P1_S__Fermat_Interface.v *)
(* theories/M004__Conservation_of_Hardness/C014__Fermat_Machine/P1_R__Peano_Arithmetic.v *)
(* theories/M004__Conservation_of_Hardness/C014__Fermat_Machine/P1_T__Arithmetic_Surface.v *)
(* theories/M004__Conservation_of_Hardness/C014__Fermat_Machine/P2_R__Z_Isomorphism.v *)
(* theories/M004__Conservation_of_Hardness/C014__Fermat_Machine/P2_S__Bridge_Contract.v *)
(* theories/M004__Conservation_of_Hardness/C014__Fermat_Machine/P3_P__Sumbool_Extraction.v *)
(* theories/M004__Conservation_of_Hardness/C014__Fermat_Machine/P3_R__Fermat_Solver.v *)
(* theories/M004__Conservation_of_Hardness/C014__Fermat_Machine/P3_S__Machine_Definition.v *)
(* theories/M004__Conservation_of_Hardness/C014__Fermat_Machine/P4_S__Barrier_Interface.v *)
(* theories/M004__Conservation_of_Hardness/C014__Fermat_Machine/P4_T__The_Fermat_Barrier.v *)
(* ---- END _CoqProject (builder) ---- *)



(* ---- theories/M001__BHK_R_Arithmetic/C000__BHK_R/P0__BHK.v ---- *)

(* P0__BHK.v *)

     (*_  /\/\/\/\/\__  /\/\__  /\/\_  /\/\___  /\/\__________  /\/\/\/\/\____ *)
    (*_  /\/\__  /\/\  /\/\__  /\/\_  /\/\__ /\/\____________  /\/\__  /\/\__  *)
   (*_  /\/\/\/\/\__  /\/\/\/\/\/\_  /\/\/\/\ ______________  /\/\/\/\/\ ___   *)
  (*_  /\/\__  /\/\  /\/\__  /\/\_  /\/\_  /\/\____________  /\/\  /\/\____    *)
 (*_  /\/\/\/\/\__  /\/\__  /\/\_  /\/\___  /\/\__________  /\/\__  /\/\__     *)
(*______________________________________________  /\/\/\/\_______________      *)
(*                                                                             *)
(*     This defines the “BHK meaning nucleus” shared by all later phases.      *)
(*     The methodology is repository-wide and project-agnostic.                *)
(*                                                                             *)
(*        (i) A proposition is identified with the type of its proofs.         *)
(*                                                                             *)
(*       (ii) To prove a proposition is to construct an inhabitant             *)
(*            of that type.                                                    *)
(*                                                                             *)
(*      (iii) Logical connectives and quantifiers are understood via           *)
(*            their introduction forms and corresponding proof objects;        *)
(*            functions, dependent pairs, tagged alternatives, etc.            *)
(*                                                                             *)
(*      In particular, equalities proved below are witnessed                   *)
(*      by computation (definitional equality), not by appeal to               *)
(*      extensional principles or additional axioms. The emphasis is on        *)
(*      explicit constructions whose meaning is stable under reduction.        *)
(*                                                                             *)
(*      BHK remains the informal proof-theoretic semantics, whereas            *)
(*      BHK_R denotes an additional discipline:                                *)
(*                                                                             *)
(*        (i) A minimal inductive core,                                        *)
(*                                                                             *)
(*       (ii) Explicit primitive recursion,                                    *)
(*                                                                             *)
(*      (iii) A fixed phase structure.                                         *)
(*                                                                             *)
(*      The preferred notion of reasoning is kernel conversion:                *)
(*      definitional equality via β, ι, ζ, and transparent δ, together         *)
(*      with explicit recursion on inductive data. Many foundational           *)
(*      equations are therefore stated in conversion-friendly normal           *)
(*      forms and discharged by simplification to eq_refl.                     *)
(*                                                                             *)
(*      Phase structure.                                                       *)
(*                                                                             *)
(*        (i) A construction is the first-class organizing principle           *)
(*            (hence folders start with 'C').                                  *)
(*                                                                             *)
(*       (ii) For each phase,                                                  *)
(*                                                                             *)
(*            (a) Realizations ('R') provide concrete constructions            *)
(*                (Fixpoint/Definition plus explicit proof terms);             *)
(*            (b) BHK proof semantics ('S') package realizations               *)
(*                behind minimal interfaces (typically small records)          *)
(*                and establish interoperability results (translations,        *)
(*                simulations, or extensional agreement on functions);         *)
(*            (c) Theorems ('T') serve as entry/exit points: lemmas and        *)
(*                theorems intended for downstream use.                        *)
(*            (d) Certificates ('A') form a recursive loop.                    *)
(*                                                                             *)
(*      Design.                                                                *)
(*                                                                             *)
(*        (i) No classical axioms (LEM, Compactness) at this level.            *)
(*                                                                             *)
(*       (ii) Avoid large numeric towers and heavyweight libraries.            *)
(*                                                                             *)
(*      (iii) Prefer small “façades” (records/modules) over large              *)
(*            signatures to reduce coupling between realizations and           *)
(*            keep computation explicit, sequential, and intensional.          *)
(*                                                                             *)
(*      In short. We establish meaning once (Phase 0); realize it explicitly   *)
(*      (R files); then relate realizations conservatively (S files),          *)
(*      yielding either a new phase, an export, or both.                       *)
(*                                                                             *)
(*                                                   (c) www.milanrosko.com    *)
(*                                                                             *)
(*******************************************************************************)

From Coq Require Import Init.Logic.

Set Implicit Arguments.
Unset Strict Implicit.

Module BHK.

  (*******************************************************************************)
  (*                                                                             *)
  (*      We define the Canonical BHK Clauses.                                   *)
  (*                                                                             *)
  (*      We map “Rocq types“ to their Constructive Logic interpretation         *)
  (*      and their corresponding computational witnesses.                       *)
  (*                                                                             *)
  (*      Rocq Type              BHK Interpretation     Realizer Structure       *)
  (*      ------------------     ------------------     ------------------       *)
  (*      False                  ∸ (Absurd)             (none)                   *)
  (*      and P Q                P ∧ Q                  ⟨p, q⟩                   *)
  (*      or  P Q                P ∨ Q                  inl p  |  inr q          *)
  (*      P -> Q                 P → Q                  λx. body                 *)
  (*      exists (fun x => P)    ∃x. P(x)               ⟨x, p⟩                   *)
  (*      forall (x:A), P        ∀x. P(x)               λx. body                 *)
  (*                                                                             *)
  (*      If we have...          we construct by...     to realize...            *)
  (*      ------------------     ------------------     ------------------       *)
  (*      p ⊨ P, q ⊨ Q           conj p q               P ∧ Q                    *)
  (*      p ⊨ P                  or_introl p            P ∨ Q                    *)
  (*      q ⊨ Q                  or_intror q            P ∨ Q                    *)
  (*      x ↦ y where y ⊨ Q      fun x => y             P → Q                    *)
  (*      x : A, p ⊨ P(x)        ex_intro x p           ∃x. P(x)                 *)
  (*      x ↦ y where y ⊨ P x    fun x => y             ∀x. P(x)                 *)
  (*                                                                             *)
  (*                 cf. A. S. Troelstra and D. van Dalen:                       *)
  (*                    Constructivism in Mathematics                            *)
  (*                                                                             *)
  (*******************************************************************************)


  (*
    A minimal Arithmetic Kernel (nat) with explicit primitive recursion
    This is intentionally not Coq.Init.Datatypes.nat. BHK reading:

      (i) The inductive type nat is a canonical constructive object,

     (ii) O and S are constructors giving the canonical proofs,

    (iii) Induction / recursion corresponds to case analysis on proofs.

    The “goal” is to keep the computational behavior fully transparent
    and independent of any larger library abstractions.
  *)

  Inductive nat : Type :=
    | O : nat
    | S : nat -> nat.

  (*************************************************************************)
  (*                                                                       *)
  (*  Primitive recursive definitions                                      *)
  (*                                                                       *)
  (*     (i) add and mul are not axiomatic relations but algorithms.       *)
  (*    (ii) To know add m n is to be able to compute it by reducing m.    *)
  (*   (iii) These definitions serve as witnesses of existence claims      *)
  (*         about sums and products.                                      *)
  (*                                                                       *)
  (*************************************************************************)

  Fixpoint add (m n : nat) : nat :=
    match m with
    | O => n
    | S m' => S (add m' n)
    end.

  Fixpoint mul (m n : nat) : nat :=
    match m with
    | O => O
    | S m' => add n (mul m' n)
    end.

  (*************************************************************************)
  (*                                                                       *)
  (*     (i) Each theorem below asserts an equality whose proof is         *)
  (*         computationally trivial.                                      *)
  (*    (ii) The proof object is eq_refl, witnessing that both sides       *)
  (*         reduce to the same normal form.                               *)
  (*                                                                       *)
  (*************************************************************************)

  Theorem add_O_l : forall n, add O n = n.
  Proof.
    intro n; simpl; exact (eq_refl _).
  Qed.

  (*************************************************************************)
  (*                                                                       *)
  (*  add (S m) n computes by one step of successor introduction.          *)
  (*  Under BHK, this expresses how a proof of add (S m) n is constructed  *)
  (*  from a proof of add m n.                                             *)
  (*                                                                       *)
  (*************************************************************************)

  Theorem add_S_l : forall m n, add (S m) n = S (add m n).
  Proof.
    intro m; intro n; simpl; exact (eq_refl _).
  Qed.

  (*************************************************************************)
  (*                                                                       *)
  (*  Multiplication with zero reduces immediately.                        *)
  (*  This corresponds to the canonical computation witnessing that        *)
  (*  zero times any number is zero.                                       *)
  (*                                                                       *)
  (*************************************************************************)

  Theorem mul_O_l : forall n, mul O n = O.
  Proof.
    intro n; simpl; exact (eq_refl _).
  Qed.

  (*************************************************************************)
  (*                                                                       *)
  (*  Successor case for multiplication.                                   *)
  (*  The equation expresses the recursive construction of a product:      *)
  (*  (S m) * n is witnessed by n + (m * n).                               *)
  (*                                                                       *)
  (*************************************************************************)

  Theorem mul_S_l : forall m n, mul (S m) n = add n (mul m n).
  Proof.
    intro m; intro n; simpl; exact (eq_refl _).
  Qed.

End BHK.


(* ---- theories/M001__BHK_R_Arithmetic/C000__BHK_R/P0__Reflexica.v ---- *)

(* P0__Reflexica.v *)

     (*_  /\/\/\/\/\__  /\/\__  /\/\_  /\/\___  /\/\__________  /\/\/\/\/\____ *)
    (*_  /\/\__  /\/\  /\/\__  /\/\_  /\/\__ /\/\____________  /\/\__  /\/\__  *)
   (*_  /\/\/\/\/\__  /\/\/\/\/\/\_  /\/\/\/\ ______________  /\/\/\/\/\ ___   *)
  (*_  /\/\__  /\/\  /\/\__  /\/\_  /\/\_  /\/\____________  /\/\  /\/\____    *)
 (*_  /\/\/\/\/\__  /\/\__  /\/\_  /\/\___  /\/\__________  /\/\__  /\/\__     *)
(*______________________________________________  /\/\/\/\_______________      *)
(*                                                                             *)
(*     “Reflexica“                                                             *)
(*                                                                             *)
(*     We define the repository-wide notion of an opt-in “global               *)
(*     inversion certificate” for an effective coding device.                  *)
(*                                                                             *)
(*     It must remain parametric and must not depend on any later              *)
(*     constructions. The guiding discipline is:                               *)
(*                                                                             *)
(*        (i) Effective computation lives in R/S layers of                     *)
(*            later constructions (definitions compute).                       *)
(*                                                                             *)
(*       (ii) Uniform correctness laws that are not derivable                  *)
(*            in pure core are isolated behind a single named                  *)
(*            inhabitant, never assumed implicitly.                            *)
(*                                                                             *)
(*     Axiom.                                                                  *)
(*                                                                             *)
(*     We assume, as our first realization, that our effective                 *)
(*     “Carryless Pairing” operation (pi, pi^-1), that is                      *)
(*                                                                             *)
(*            forall x y, unpair (pair x y) = (x, y)                           *)
(*            --------------------------------------                           *)
(*                                                                             *)
(*     Holds.                                                                  *)
(*                                                                             *)
(*     We justify it by the “Geometric Iterant”,                               *)
(*                                                                             *)
(*     cf. arXiv:2510.08934, Page 5.                                           *)
(*                                                                             *)
(*     but any non-trivial RE source of arithmetic pre-realizability would     *)
(*     suffice, for example, “the Brachistochrone curve“ or “Diophantines“.    *)
(**                                                                           **)
(*******************************************************************************)

From Coq Require Import Init.Logic.
From BHK_R.C000 Require Export P0__BHK.

Set Implicit Arguments.
Unset Strict Implicit.

  Module Reflexica.

  (*************************************************************************)
  (*                                                                       *)
  (*  Remark: we use the canonical product nat * nat, which has            *)
  (*  definitional projections fst and snd, avoiding additional            *)
  (*  “pair type” bureaucracy in the base layer.                           *)
  (*                                                                       *)
  (*************************************************************************)

  Module Type PAIRING_SIG.
    Parameter nat : Type.

    (* The coding operations under certification. *)

    Parameter pair   : nat -> nat -> nat.
    Parameter unpair : nat -> nat * nat.

  End PAIRING_SIG.

  (*************************************************************************)
  (*                                                                       *)
  (*  Many constructions can implement pair/unpair effectively (total      *)
  (*  recursion), but cannot prove the global inversion law inside the     *)
  (*  pure BHK_R core without additional structure.                        *)
  (*                                                                       *)
  (*  Reflexica packages exactly one missing inhabitant, so that later     *)
  (*  developments can depend on it explicitly and locally, rather than    *)
  (*  importing untracked arithmetic or classical principles.              *)
  (*                                                                       *)
  (*************************************************************************)

  Module Make (P : PAIRING_SIG).

    (*************************************************************************)
    (*                                                                       *)
    (*  A construction that wants certified inversion provides an            *)
    (*  inhabitant of REFLEXICA. Typical usage in later constructions:       *)
    (*                                                                       *)
    (*     Module C := Reflexica.Make(MyPairing).                            *)
    (*     Parameter R : C.REFLEXICA.                                        *)
    (*                                                                       *)
    (*  The certificate can later be replaced by an explicit constructive    *)
    (*  proof without changing downstream APIs.                              *)
    (*                                                                       *)
    (*************************************************************************)

    Record REFLEXICA : Prop := {
      unpair_pair :
        forall x y : P.nat,
          P.unpair (P.pair x y) = (x, y)
    }.

    (*************************************************************************)
    (*                                                                       *)
    (*  Exported form of the certificate field.                              *)
    (*                                                                       *)
    (*  This is merely a projection, but naming it makes downstream          *)
    (*  dependencies explicit: “this proof uses Reflexica”.                  *)
    (*                                                                       *)
    (*************************************************************************)

    Definition unpair_pair_reflexica (r : REFLEXICA) :
      forall x y : P.nat, P.unpair (P.pair x y) = (x, y) :=
      unpair_pair r.

    (*************************************************************************)
    (*                                                                       *)
    (*  Derived projections.                                                 *)
    (*                                                                       *)
    (*  From the certified round-trip we immediately obtain the ability      *)
    (*  to recover components of the original pair by applying fst/snd.      *)
    (*                                                                       *)
    (*  These lemmas are often the only facts downstream users need.         *)
    (*                                                                       *)
    (*************************************************************************)
    
    Definition fst_unpair_pair_reflexica (r : REFLEXICA) :
      forall x y : P.nat, fst (P.unpair (P.pair x y)) = x :=
      fun x y =>
        eq_trans (f_equal fst (unpair_pair_reflexica r x y))
                 (eq_refl x).

    Definition snd_unpair_pair_reflexica (r : REFLEXICA) :
      forall x y : P.nat, snd (P.unpair (P.pair x y)) = y :=
      fun x y =>
        eq_trans (f_equal snd (unpair_pair_reflexica r x y))
                 (eq_refl y).

    (*************************************************************************)
    (*                                                                       *)
    (*  Injectivity on the image.                                            *)
    (*                                                                       *)
    (*  The certificate implies that pair is injective:                      *)
    (*                                                                       *)
    (*      pair x1 y1 = pair x2 y2  ->  x1 = x2  /\  y1 = y2                *)
    (*                                                                       *)
    (*  This is a “decode both sides” argument, our “Γ |- t:T”               *)
    (*                                                                       *)
    (*  We keep the proof term elementary (f_equal + rewriting)              *)
    (*  to remain aligned with the BHK_R style.                              *)
    (*                                                                       *)
    (*************************************************************************)

    Theorem pair_inj_reflexica (r : REFLEXICA) :
      forall x1 y1 x2 y2 : P.nat,
        P.pair x1 y1 = P.pair x2 y2 ->
        x1 = x2 /\ y1 = y2.

    Proof.
      intros x1 y1 x2 y2 H.
      split.
      - pose proof (f_equal P.unpair H) as Hu.
        pose proof (f_equal fst Hu) as Hf.
        rewrite (fst_unpair_pair_reflexica r x1 y1) in Hf.
        rewrite (fst_unpair_pair_reflexica r x2 y2) in Hf.
        exact Hf.
      - pose proof (f_equal P.unpair H) as Hu.
        pose proof (f_equal snd Hu) as Hs.
        rewrite (snd_unpair_pair_reflexica r x1 y1) in Hs.
        rewrite (snd_unpair_pair_reflexica r x2 y2) in Hs.
        exact Hs.

    Qed.

  End Make.

End Reflexica.

(*************************************************************************)
(*                                                                       *)
(*  Meta-Theoretic Note.                                                 *)
(*                                                                       *)
(*  On the “impossibility“ of “full“ internalization of arithmetic.      *)
(*                                                                       *)
(*  Why must this remain an Axiom?                                       *)
(*                                                                       *)
(*  We intentionally do NOT “bind” this certificate to the Rocq kernel's *)
(*  definitional equality (e.g., via Rewrite Rules or reduced terms).    *)
(*  The "Gap" between the computational realization (R) and this         *)
(*  certificate (A) is structural.                                       *)
(*                                                                       *)
(*  If we were to "internalize" this law (make it definitionally true),  *)
(*  we would assert:                                                     *)
(*                                                                       *)
(*  Arithmetic_Integrity == True, leading to contradiction:              *)
(*                                                                       *)
(*         (Exists Certified_Solver) <-> ~Arithmetic_Integrity           *)
(*                                                                       *)
(*  If Arithmetic Integrity were unconditional, we could simply          *)
(*  "ask" our proof environment to solve the inversion. We cannot.       *)
(*                                                                       *)
(*  Our silicon chips, however advanced, are merely a mechanized         *)
(*  method of notation, a “very fast“ abacus. The preferred notion       *)
(*  of reasoning herein is kernel conversion: definitional equality      *)
(*  limited to β, ι, ζ, and transparent δ.                               *)
(*                                                                       *)
(*  To confuse this mechanical “rewrite“ with semantic truth is          *)
(*  to assume the ambient universe is trivial.                           *)
(*                                                                       *)
(*  We must remain aware of this distinction.                            *)
(*                                                                       *)
(*                                                                       *)
(*************************************************************************)

(*************************************************************************)
(*                                                                       *)
(*  “Simple” BHK_R public surface.                                       *)
(*                                                                       *)
(*  Policy: re-export only the arithmetic nucleus and the Reflexica      *)
(*  interface, without assuming any certificate.                         *)
(*                                                                       *)
(*************************************************************************)

Module Prelude := BHK_R.C000.P0__BHK.BHK.



(* ---- theories/M001__BHK_R_Arithmetic/C001__Carryless_Pairing/P1_S__Substrate.v ---- *)

(* P1_S__Substrate.v *)

From Coq Require Import Init.Logic.
From BHK_R.C000 Require Import P0__Reflexica.

(*************************************************************************)
(*                                                                       *)
(*  C001 / Phase 1 (S) : Arithmetic Substrate                            *)
(*                                                                       *)
(*    (i) Scope.                                                         *)
(*                                                                       *)
(*        (a) This file establishes a closed arithmetic env. for C001.   *)
(*        (b) It re-exports the C000 "BHK Nucleus" (nat, O, S, etc.)     *)
(*                                                                       *)
(*   (ii) Discipline.                                                    *)
(*                                                                       *)
(*         “Lean” Realization: Subsequent constructions                  *)
(*         in this phase (Fibonacci, Pairing) must be,                   *)
(*                                                                       *)
(*        (a)  Parametric: Defined solely over this Prelude nucleus.     *)
(*        (b)  Canonical: We provide ONE efficient realization per       *)
(*             concept, discarding redundant implementations previously  *)
(*             used for extensionality checks.                           *)
(*        (c)  Total: Witnessed by structural or measure-based           *)
(*             recursion that reduces to kernel normal forms.            *)
(*                                                                       *)
(*  (iii) Boundary.                                                      *)
(*                                                                       *)
(*        No new axioms are introduced here. The global inversion law    *)
(*        for the resulting pairing will be handled exclusively by the   *)
(*        Reflexica certificate layer.                                   *)
(*                                                                       *)
(*************************************************************************)

Set Implicit Arguments.
Unset Strict Implicit.

Module Prelude := BHK_R.C000.P0__Reflexica.Prelude.


(* ---- theories/M001__BHK_R_Arithmetic/C001__Carryless_Pairing/P2_R__Carryless.v ---- *)

(* P2_R__Carryless.v *)

From Carryless_Pairing.C001 Require Import P1_S__Substrate.

Set Implicit Arguments.
Unset Strict Implicit.

Module Fib_Realization.

  Module N := P1_S__Substrate.Prelude.

  Module Fib.

    (*
      Internal product and pair-recursive computation,
      structurally recursive and kernel-computational.
    *)

    Inductive prod (A B : Type) : Type :=
    | pair : A -> B -> prod A B.
    Arguments pair {A B} _ _.

    Definition fst {A B : Type} (p : prod A B) : A :=
      match p with
      | pair a _ => a
      end.

    Definition snd {A B : Type} (p : prod A B) : B :=
      match p with
      | pair _ b => b
      end.

    Definition step (p : prod N.nat N.nat) : prod N.nat N.nat :=
      match p with
      | pair a b => pair b (N.add a b)
      end.

    Fixpoint fib_pair (n : N.nat) : prod N.nat N.nat :=
      match n with
      | N.O => pair N.O (N.S N.O)
      | N.S n' => step (fib_pair n')
      end.

    Definition fib (n : N.nat) : N.nat := fst (fib_pair n).

    Definition fib_0 : fib N.O = N.O := eq_refl N.O.
    Definition fib_1 : fib (N.S N.O) = N.S N.O := eq_refl (N.S N.O).

    Definition fib_S (n : N.nat) : fib (N.S n) = snd (fib_pair n) :=
      match fib_pair n as p return fst (step p) = snd p with
      | pair a b => eq_refl b
      end.

    Definition snd_step (p : prod N.nat N.nat) :
      snd (step p) = N.add (fst p) (snd p) :=
      match p with
      | pair a b => eq_refl (N.add a b)
      end.

    Definition fib_SS : forall n, fib (N.S (N.S n)) = N.add (fib n) (fib (N.S n)) :=
      fun n =>
        let H0 : fib (N.S (N.S n)) = snd (fib_pair (N.S n)) := fib_S (N.S n) in
        let H1 : snd (fib_pair (N.S n)) = snd (step (fib_pair n)) :=
          eq_refl (snd (step (fib_pair n))) in
        let H2 : snd (step (fib_pair n)) =
                 N.add (fst (fib_pair n)) (snd (fib_pair n)) :=
          snd_step (fib_pair n) in
        let H3 : N.add (fst (fib_pair n)) (snd (fib_pair n)) =
                 N.add (fib n) (snd (fib_pair n)) :=
          eq_refl (N.add (fib n) (snd (fib_pair n))) in
        let H4 : N.add (fib n) (snd (fib_pair n)) =
                 N.add (fib n) (fib (N.S n)) :=
          f_equal (fun t => N.add (fib n) t) (eq_sym (fib_S n)) in
        eq_trans
          (eq_trans (eq_trans (eq_trans H0 H1) H2) (eq_trans H3 H4))
          (eq_refl (N.add (fib n) (fib (N.S n)))).

  End Fib.

End Fib_Realization.


(* ---- theories/M001__BHK_R_Arithmetic/C001__Carryless_Pairing/P2_S__Carryless.v ---- *)

(* P2_S__Carryless.v *)

From Carryless_Pairing.C001 Require Import
  P1_S__Substrate (* The arithmetic nucleus (nat, add, mul) *)
  P2_R__Carryless. (* The specific realization to be packaged *)

Set Implicit Arguments.
Unset Strict Implicit.

(*************************************************************************)
(*                                                                       *)
(*  C001 / Phase 2 (S) : Carryless Semantics (Fibonacci)                 *)
(*                                                                       *)
(*  Role.                                                                *)
(*  This module acts as the semantic stabilization layer for the         *)
(*  Fibonacci sequence. It packages the raw computational realization    *)
(*  (Phase R) behind a clean, mathematical interface (Record FIB).       *)
(*                                                                       *)
(*  This ensures downstream consumers (like the Pairing logic) depend    *)
(*  on the abstract properties of Fibonacci numbers, not the specific    *)
(*  recursive implementation details (e.g. accumulators) used in R.      *)
(*                                                                       *)
(*************************************************************************)

Module Carryless_Semantics.

  Module N := P1_S__Substrate.Prelude.
  Module R := P2_R__Carryless.Fib_Realization. (* Short aliases for the Nucleus (N) *) (* and Realization (R) *)

  (*************************************************************************)
  (*                                                                       *)
  (*  The Fibonacci Specification                                          *)
  (*                                                                       *)
  (*  A "Fibonacci sequence" is defined here as any function satisfying    *)
  (*  the standard recurrence laws. This Type Class-style record allows    *)
  (*  us to prove theorems based on the specification alone.               *)
  (*                                                                       *)
  (*************************************************************************)

  Record FIB : Type := { 
    fib : N.nat -> N.nat; (* The operation: maps a natural number to a natural number *)
    fib_0  : fib N.O = N.O; (* Law: F(0) = 0 *)
    fib_1  : fib (N.S N.O) = N.S N.O; 
    fib_SS : forall n, fib (N.S (N.S n)) = N.add (fib n) (fib (N.S n)) (* Law: F(n+2) = F(n) + F(n+1). This recurrence defines the sequence structure used for Zeckendorf *)
  }.

  (*************************************************************************)
  (*                                                                       *)
  (*  Canonical Instance                                                   *)
  (*                                                                       *)
  (*  We bind the interface to the efficient realization provided by       *)
  (*  Phase R. This is the single "official" Fibonacci sequence used       *)
  (*  by the carryless pairing device.                                     *)
  (*                                                                       *)
  (*  Note: While R.Fib.fib might use tail-recursion or accumulators,      *)
  (*  StandardFib exposes it simply as satisfying the FIB laws.            *)
  (*                                                                       *)
  (*************************************************************************)

  Definition StandardFib : FIB :=
    {| fib    := R.Fib.fib
     ; fib_0  := R.Fib.fib_0
     ; fib_1  := R.Fib.fib_1
     ; fib_SS := R.Fib.fib_SS
    |}.

End Carryless_Semantics.


(* ---- theories/M001__BHK_R_Arithmetic/C001__Carryless_Pairing/P3_R__Injectivity.v ---- *)

(* P3_R__Injectivity.v *)

From Carryless_Pairing.C001 Require Import P1_S__Substrate.

Set Implicit Arguments.
Unset Strict Implicit.

(*
  We provide the standard realization of injectivity and discrimination
  using direct elimination on the equality witness (match H with...).
*)

Module Injectivity_Realization.
  Module N := P1_S__Substrate.Prelude.

  Module StandardNatInj.

    (* 
      Injectivity: S m = S n -> m = n
    *)

    Definition S_inj (m n : N.nat) (H : N.S m = N.S n) : m = n :=
      match H with
      | eq_refl => eq_refl
      end.

    (*
      Discrimination: O <> S n
    *)

    Definition O_S_discr (n : N.nat) : N.O <> N.S n :=
      fun H =>
        match H in (_ = t) return (match t with N.O => True | N.S _ => False end) with
        | eq_refl => I
        end.

    (*
      Discrimination: S n <> O
    *)
    
    Definition S_O_discr (n : N.nat) : N.S n <> N.O :=
      fun H =>
        match H in (_ = t) return (match t with N.O => False | N.S _ => True end) with
        | eq_refl => I
        end.
  End StandardNatInj.

End Injectivity_Realization.


(* ---- theories/M001__BHK_R_Arithmetic/C001__Carryless_Pairing/P3_S__Injectivity.v ---- *)

(* P3_S__Injectivity.v *)

From Carryless_Pairing.C001 Require
Import P1_S__Substrate P3_R__Injectivity.

Set Implicit Arguments.
Unset Strict Implicit.

(************************************************************************)
(*                                                                      *)
(*  C001 / Phase 3 (S) : Injectivity Semantics                          *)
(*                                                                      *)
(*  Role.                                                               *)
(*                                                                      *)
(*  This module defines the semantic interface for the structural       *)
(*  properties of the arithmetic nucleus. It packages the critical      *)
(*  constructor laws for 'nat':                                         *)
(*                                                                      *)
(*    (i) Injectivity of S (S m = S n -> m = n)                         *)
(*   (ii) Discrimination (O <> S n)                                     *)
(*                                                                      *)
(*  By wrapping these into a Record, we ensure that downstream logic    *)
(*  depends only on these named properties, not on raw match terms.     *)
(*                                                                      *)
(************************************************************************)

(*************************************************************************)
(*                                                                       *)
(*  Interface: Constructor Laws                                          *)
(*                                                                       *)
(*  This record specifies the minimal inductive properties required      *)
(*  for 'nat' to function as a data structure. These are the             *)
(*  "Peano axiom fragments" for the constructors O and S.                *)
(*                                                                       *)
(*************************************************************************)

Module NatInj_Semantics.

  Module N := P1_S__Substrate.Prelude.
  Module R := Injectivity_Realization.
  
  Record NAT_INJ : Prop := {

    (*
      The interface downstream users rely on
    *)

    S_inj : forall m n : N.nat, N.S m = N.S n -> m = n;

    (*
      O and S are disjoint images: Zero is never a Successor
    *)

    O_S_discr : forall n : N.nat, N.O <> N.S n;

    (*
      Symmetric disjointness: Successor is never Zero
    *)

    S_O_discr : forall n : N.nat, N.S n <> N.O
  }.

  (*************************************************************************)
  (*                                                                       *)
  (*  Canonical Instance                                                   *)
  (*                                                                       *)
  (*  We bind the interface to the realization. The proofs in 'R'          *)
  (*  utilize 'match' (or elementary destructors) to witness these laws    *)
  (*  constructively.                                                      *)
  (*                                                                       *)
  (*************************************************************************)

    Definition StandardNatInj : NAT_INJ :=
    {|
      S_inj     := R.StandardNatInj.S_inj;
      O_S_discr := R.StandardNatInj.O_S_discr;
      S_O_discr := R.StandardNatInj.S_O_discr
    |}.

  (*************************************************************************)
  (*                                                                       *)
  (*  Interoperability Projections                                         *)
  (*                                                                       *)
  (*  These definitions project the fields of the canonical instance       *)
  (*  into top-level functions. Phase T (Public Surface) will export       *)
  (*  these to give downstream users easy access to the laws.              *)
  (*                                                                       *)
  (*************************************************************************)

  (*
    Stable projections for Phase T
  *)

  Definition S_inj_interop : forall m n, N.S m = N.S n -> m = n :=
    fun m n H => @S_inj StandardNatInj m n H.

  Definition O_S_discr_interop : forall n, N.O <> N.S n :=
    fun n => @O_S_discr StandardNatInj n.

  Definition S_O_discr_interop : forall n, N.S n <> N.O :=
    fun n => @S_O_discr StandardNatInj n.

End NatInj_Semantics.


(* ---- theories/M001__BHK_R_Arithmetic/C001__Carryless_Pairing/P4_R__Pairing.v ---- *)

(* P4_R__Pairing.v *)

From Carryless_Pairing.C001 Require Import
  P1_S__Substrate
  P2_R__Carryless.

Set Implicit Arguments.
Unset Strict Implicit.

(*
  Adds the local infrastructure required by the pairing construction.
  No changes to Phase-0. No classical axioms.
  Syntax note: bool/list/prod are local to keep the core nucleus small.
*)

Module Pairing_Realization.

(*************************************************************************)
(*                                                                       *)
(*  We consider,                                                         *)
(*                                                                       *)
(*  pi_CL_tau(x,y)=Sum{e in Z(x)} F_{2e}+Sum{j in Z(y)} F_{B(x)+2j-1}.   *)
(*                                                                       *)
(*************************************************************************)


  Module N := P1_S__Substrate.Prelude.
  Module A := P2_R__Carryless.Fib_Realization.

  (*
    Local booleans and lists
  *)

  Inductive bool : Type :=
  | true : bool
  | false : bool.

  Definition negb (b : bool) : bool :=
    match b with true => false | false => true end.

  Inductive list (A0 : Type) : Type :=
  | nil : list A0
  | cons : A0 -> list A0 -> list A0.

  Arguments nil {A0}.
  Arguments cons {A0} _ _.

  Fixpoint app {A0} (xs ys : list A0) : list A0 :=
    match xs with
    | nil => ys
    | cons x xs' => cons x (app xs' ys)
    end.

  Fixpoint map {A0 B0} (f : A0 -> B0) (xs : list A0) : list B0 :=
    match xs with
    | nil => nil
    | cons x xs' => cons (f x) (map f xs')
    end.

  Fixpoint fold {A0 B0} (f : A0 -> B0 -> B0) (xs : list A0) (z : B0) : B0 :=
    match xs with
    | nil => z
    | cons x xs' => f x (fold f xs' z)
    end.

  Fixpoint filter {A0} (p : A0 -> bool) (xs : list A0) : list A0 :=
    match xs with
    | nil => nil
    | cons x xs' =>
        match p x with
        | true => cons x (filter p xs')
        | false => filter p xs'
        end
    end.

  (*
    Products (internal)
  *)

  Inductive prod (A0 B0 : Type) : Type :=
  | pair : A0 -> B0 -> prod A0 B0.
  Arguments pair {A0 B0} _ _.

  Definition fst {A0 B0} (p : prod A0 B0) : A0 :=
    match p with pair a _ => a end.

  Definition snd {A0 B0} (p : prod A0 B0) : B0 :=
    match p with pair _ b => b end.

  (*
    Basic nat comparisons (decidable, bounded)
  *)

  Fixpoint leb (m n : N.nat) : bool :=
    match m, n with
    | N.O, _ => true
    | N.S _, N.O => false
    | N.S m', N.S n' => leb m' n'
    end.

  Definition ltb (m n : N.nat) : bool :=
    match leb (N.S m) n with
    | true => true
    | false => false
    end.

  (*
    Truncated subtraction (monus)
  *)

  Fixpoint monus (m n : N.nat) : N.nat :=
    match m, n with
    | m', N.O => m'
    | N.O, N.S _ => N.O
    | N.S m', N.S n' => monus m' n'
    end.

  (*
    Fibonacci access.
    We reuse the canonical fib: fib 0 = 0, fib 1 = 1, fib 2 = 1, ...
  *)

  Definition F (k : N.nat) : N.nat := A.Fib.fib k.

  (*
    Rank r(x): first index k such that F k > x
    Bounded by S (S x) (coarse but primitive-recursive).
  *)

  Fixpoint find_r_aux (x : N.nat) (k fuel : N.nat) : N.nat :=
    match fuel with
    | N.O => k
    | N.S fuel' =>
        match ltb x (F k) with
        | true => k
        | false => find_r_aux x (N.S k) fuel'
        end
    end.

  Definition r (x : N.nat) : N.nat :=
    
    (*
      start k=O, fuel = S(S x)
    *)

    find_r_aux x N.O (N.S (N.S x)).

  Definition B (x : N.nat) : N.nat := N.add (r x) (r x).

  (*
    2*r(x)
  *)

  (*************************************************************************)
  (*                                                                       *)
  (*  Zeckendorf support Z(x) by bounded greedy scan downwards             *)
  (*                                                                       *)
  (*************************************************************************)

  (*
    Syntax note: Z uses a bounded greedy scan down from r(x),
    not a uniqueness proof of Zeckendorf representations.
  *)

  Definition dec (n : N.nat) : N.nat :=
    match n with
    | N.O => N.O
    | N.S n' => n'
    end.

  Fixpoint zeck_greedy_down (k : N.nat) (rem : N.nat) (prev_taken : bool)
    : prod (list N.nat) N.nat :=
    match k with
    | N.O => pair nil rem
    | N.S k' =>
        match prev_taken with
        | true =>
            zeck_greedy_down k' rem false
        | false =>
            match leb (F k) rem with
            | true =>
                let pr := zeck_greedy_down k' (monus rem (F k)) true in
                pair (cons k (fst pr)) (snd pr)
            | false =>
                zeck_greedy_down k' rem false
            end
        end
    end.

  Definition Z (x : N.nat) : list N.nat :=

    (*
      scan from r(x) down to 1; including k=0 is harmless since F0=0
    *)

    fst (zeck_greedy_down (r x) x false).

  (*
    Sum of Fibonacci values over a support list
  *)

  Definition sumF (xs : list N.nat) : N.nat :=
    fold (fun k acc => N.add (F k) acc) xs N.O.

  (*
    Parity and small index transforms
  *)

  Fixpoint is_even (n : N.nat) : bool :=
    match n with
    | N.O => true
    | N.S N.O => false
    | N.S (N.S n') => is_even n'
    end.

  Definition is_odd (n : N.nat) : bool := negb (is_even n).

  Fixpoint div2 (n : N.nat) : N.nat :=
    match n with
    | N.O => N.O
    | N.S N.O => N.O
    | N.S (N.S n') => N.S (div2 n')
    end.

  Definition two (n : N.nat) : N.nat := N.add n n.
  Definition two_j_minus1 (j : N.nat) : N.nat := monus (two j) (N.S N.O).  (* 2j-1 *)

  (*
    Typed carryless pairing,
    Pairing encodes x on even indices, y on odd indices above B(x).
  *)

  Definition even_band (x : N.nat) : list N.nat :=
    map (fun e => two e) (Z x).

  Definition odd_band (x y : N.nat) : list N.nat :=
    map (fun j => N.add (B x) (two_j_minus1 j)) (Z y).

  Definition pi_CL_tau (x y : N.nat) : N.nat :=
    sumF (app (even_band x) (odd_band x y)).

  (*
    Typed unpairing,
    Unpairing filters by parity and the band threshold (B(x)+1).
  *)

  Definition half_even_indices (zn : list N.nat) : list N.nat :=
    map div2 (filter is_even zn).

  Definition geq (m n : N.nat) : bool := leb n m.

  Definition odd_ge_B1 (Bx k : N.nat) : bool :=
    match is_odd k with
    | false => false
    | true => geq k (N.S Bx)
    end.

  Definition decode_odd_index (Bx k : N.nat) : N.nat :=
    div2 (N.S (monus k Bx)).

  Definition y_indices (Bx : N.nat) (zn : list N.nat) : list N.nat :=
    map (fun k => decode_odd_index Bx k)
        (filter (odd_ge_B1 Bx) zn).

  Definition unpair_CL_tau (n : N.nat) : prod N.nat N.nat :=
    let zn := Z n in
    let X := half_even_indices zn in
    let x := sumF X in
    let Bx := B x in
    let Y := y_indices Bx zn in
    let y := sumF Y in
    pair x y.

End Pairing_Realization.


(* ---- theories/M001__BHK_R_Arithmetic/C001__Carryless_Pairing/P4_S__Pairing.v ---- *)

(* P4_S__Pairing.v *)

From Carryless_Pairing.C001 Require Import
  P1_S__Substrate
  P2_S__Carryless
  P4_R__Pairing.

Set Implicit Arguments.
Unset Strict Implicit.

(*************************************************************************)
(*                                                                       *)
(*  C001 / Phase 4 (S): Pairing facade + arithmetic/parity toolkit.      *)
(*                                                                       *)
(*  What this file provides.                                             *)
(*                                                                       *)
(*    (i) A packaged interface (CL_PAIR) opening the pairing             *)
(*        construction and its auxiliary operators:                      *)
(*        (a) Fibonacci access F                                         *)
(*        (b) rank r and band offset B (= 2 * r)                         *)
(*        (c) Zeckendorf support extractor Z                             *)
(*        (d) the pairing function pair and its typed unpair             *)
(*                                                                       *)
(*        This facade is the stable semantic surface for downstream:     *)
(*        later phases should refer to CarrylessPair : CL_PAIR rather    *)
(*        than importing realization modules directly.                   *)
(*                                                                       *)
(*   (ii) Kernel-stable lemmas about addition, parity, and the band.     *)
(*        The lemmas are intentionally stated in conversion-friendly     *)
(*        normal forms and proved by small primitive recursion,          *)
(*        so that rewriting remains predictable and does not rely on     *)
(*        classical principles or external libraries.                    *)
(*                                                                       *)
(*  How these lemmas are used.                                           *)
(*                                                                       *)
(*    (i) The pairing/unpairing scheme encodes x and y by placing        *) 
(*        Fibonacci  indices into two disjoint “bands”:                  *)
(*        (a) odd_band x y uses odd indices (B(x) + (2j-1)) from Z(y)    *)
(*        (b) even_band x uses only even indices (2e), from Z(x)         *)
(*                                                                       *)
(*   (ii) Unpairing then recovers x and y by filtering Zeckendorf        *)
(*        indices:                                                       *)    
(*        (a) even indices decode back to x via div2                     *)
(*        (b) odd indices above the band threshold decode back to y      *)
(*                                                                       *)
(*  (iii) The parity lemmas below justify this separation discipline:    *)
(*        (a) B is even, so B(x)+odd remains odd                         *)
(*        (b) 2e is always even                                          *)
(*        (c) 2j-1 is always odd                                         *)
(*                                                                       *)
(*   (iv) In particular, the two “index classification” lemmas           *)
(*        at the end summarize the intended invariant:                   *)
(*        (a) odd_index_is_odd:  B(x) + (2j-1) is odd                    *)
(*        (b) even_index_is_even: 2e is even.                            *)
(*                                                                       *)
(*************************************************************************)

Module Pairing_Semantics.

  Module N := P1_S__Substrate.Prelude. 

  (*
    The arithmetic nucleus (nat, add, mul)
  *)

  Module R := P4_R__Pairing.Pairing_Realization.

  (*
    The specific realization to be packaged
  *)

  Record CL_PAIR : Type := {
    F     : N.nat -> N.nat;
    r     : N.nat -> N.nat;
    B     : N.nat -> N.nat;
    Z     : N.nat -> R.list N.nat;

    even_band : N.nat -> R.list N.nat;
    odd_band  : N.nat -> N.nat -> R.list N.nat;

    pair   : N.nat -> N.nat -> N.nat;
    unpair : N.nat -> R.prod N.nat N.nat
  }.

  (*************************************************************************)
  (*                                                                       *)
  (*  The Device Interface: CL_PAIR                                        *)
  (*                                                                       *)
  (*  This record exposes the operational internals of the pairing         *)
  (*  scheme without exposing their implementation code.                   *)
  (*                                                                       *)
  (*  It includes:                                                         *)
  (*                                                                       *)
  (*    (i) Auxiliaries: Fib (F), rank (r), band offset (B), support (Z).  *)
  (*   (ii) Band Logic: separating indices into even/odd streams.          *)
  (*  (iii) The Core: pair and unpair.                                     *)
  (*                                                                       *)
  (*************************************************************************)

  Definition CarrylessPair : CL_PAIR := {|

      (*
        Fibonacci sequence used by the device
      *)

      F := R.F ;

      (*
        Rank r(n): The first index k such that F k > n
      *)

      r := R.r ;

      (*
        Band B(n): The offset 2*r(n) used to shift the Y component
      *)

      B := R.B ;

      (*
        Zeckendorf Support Z(n): list of indices representing n, from the Realization layer
      *)

      Z := R.Z ;

      (*
        Band Projections: The sets of indices used for X and Y
      *)

      even_band := R.even_band ;      
      odd_band  := R.odd_band ; 

      (*
        The Main Pairing Function: Encodes (x,y) into a single nat
      *)

      pair      := R.pi_CL_tau ;

      (*
        The Main Unpairing Function: Decodes z into (x,y)
      *)

      unpair    := R.unpair_CL_tau ;
  |}.

  (*
    Helper Projections,
    since 'unpair' returns a product type from the R-layer, we
    provide stable accessors for the first and second components.
  *)

  Definition fst (p : R.prod N.nat N.nat) : N.nat := R.fst p.
  Definition snd (p : R.prod N.nat N.nat) : N.nat := R.snd p.


End Pairing_Semantics.


(* ---- theories/M001__BHK_R_Arithmetic/C001__Carryless_Pairing/P5_T__Carryless_Pairing.v ---- *)

(* P5_T__Carryless_Pairing.v *)

From Coq Require Import Init.Logic.
From Carryless_Pairing.C001 Require Export
  P1_S__Substrate
  P2_S__Carryless
  P3_S__Injectivity
  P4_S__Pairing.

Set Implicit Arguments.
Unset Strict Implicit.

(*************************************************************************)
(*                                                                       *)
(*  C001 / Phase 5 (T): Carryless Pairing (Public Surface)               *)
(*                                                                       *)
(*  Purpose.                                                             *)
(*  This is the phase-free entry point for C001. It exposes the stable   *)
(*  facades and canonical instances required by downstream developments  *)
(*  (C002+), hiding all internal realization details.                    *)
(*                                                                       *)
(*  Policy (The "Lean" Discipline):                                      *)
(*                                                                       *)
(*    (i) Single Canonical Reality: We export exactly one effective      *)
(*        realization for Fibonacci (StandardFib) and one for            *)
(*        (StandardNatInj). No redundant "A/B" implementations exist.    *)
(*                                                                       *)
(*   (ii) Device Access: The Pairing device is exposed via the CL_PAIR   *)
(*        interface, backed by the Zeckendorf realization                *)
(*                                                                       *)
(*  (iii) No Axioms: All theorems here are proven by kernel computation  *)
(*        (eq_refl) or direct destructor elimination.                    *)
(*        The Global Inversion Law is NOT present here;                  *)
(*        it lives exclusively in Phase 6 (Reflexica).                   *)
(*                                                                       *)
(*************************************************************************)

(*
  Stable Conceptual Namespaces
*)

Module Prelude := Carryless_Pairing.C001.P1_S__Substrate.Prelude.
Module Fib     := Carryless_Pairing.C001.P2_S__Carryless.Carryless_Semantics.
Module NatInj  := Carryless_Pairing.C001.P3_S__Injectivity.NatInj_Semantics.
Module Pairing := Carryless_Pairing.C001.P4_S__Pairing.Pairing_Semantics.

(*  
  Facade Types
*)

Definition FIB : Type := Fib.FIB.
Definition NAT_INJ : Prop := NatInj.NAT_INJ.
Definition CL_PAIR : Type := Pairing.CL_PAIR.

(*
  Single, effective realization for each concept
*)

(*
  The efficient accumulator-based Fibonacci
*)

Definition StandardFib : FIB := Fib.StandardFib.

(*
  The match-based constructor laws
*)

Definition StandardNatInj : NAT_INJ := NatInj.StandardNatInj.

(*
  The Zeckendorf carryless pairing device
*)

Definition CarrylessPair : CL_PAIR := Pairing.CarrylessPair.

(*
  Public (Constructive destructors for the arithmetic nucleus)
*)

(*
  Injectivity: S m = S n -> m = n
*)

Theorem S_inj_public :
  forall m n : Prelude.nat, Prelude.S m = Prelude.S n -> m = n.
Proof.
  exact NatInj.S_inj_interop.
Qed.

(*
  Discrimination: O <> S n
*)

Theorem O_not_S_public :
  forall n : Prelude.nat, Prelude.O <> Prelude.S n.
Proof.
  exact NatInj.O_S_discr_interop.
Qed.

(*
  Discrimination: S n <> O
*)

Theorem S_not_O_public :
  forall n : Prelude.nat, Prelude.S n <> Prelude.O.
Proof.
  exact NatInj.S_O_discr_interop.
Qed.


(* ---- theories/M001__BHK_R_Arithmetic/C001__Carryless_Pairing/P5_T__Effectivity.v ---- *)

(* P4_T__Effectivity.v *)

From Carryless_Pairing.C001 Require Import P5_T__Carryless_Pairing.
From Coq Require Import Init.Logic.

Set Implicit Arguments.
Unset Strict Implicit.

(*************************************************************************)
(*                                                                       *)
(*  This file is intentionally not part of the logical development       *)
(*  chain (C002+). It is an effectivity witness and executable           *)
(*  documentation, not a theory module.                                  *)
(*                                                                       *)
(*   Carryless_Pairing.C001.P5_T__Carryless_Pairing                      *)
(*                                                                       *)
(*   It serves three roles:                                              *)
(*                                                                       *)
(*    (i) Demonstrate that the carryless pairing and unpairing           *)
(*        functions are computationally effective (i.e., reduce by       *)
(*        kernel computation without axioms).                            *)
(*                                                                       *)
(*   (ii) Provide concrete, executable witnesses of correctness          *)
(*        for small values, suitable for vm_compute evaluation.          *)
(*                                                                       *)
(*  (iii) Act as a regression / documentation test that the façade-      *)
(*        level pairing interface (Prelude / Pairing) is wired           *)
(*        correctly to its realization.                                  *)
(*                                                                       *)
(*   Methodology note (BHK_R discipline):                                *)
(*                                                                       *)
(*   All correctness statements here are witnessed by computation        *)
(*   (vm_compute), not by propositional reasoning or axioms.             *)
(*                                                                       *)
(*   In particular:                                                      *)
(*                                                                       *)
(*    (i) unpair (pair x y) reduces definitionally to (x, y);            *)
(*                                                                       *)
(*   (ii) Fibonacci ranks, bands, and Zeckendorf supports are            *)
(*        observed as concrete normal forms.                             *)
(*                                                                       *)
(*************************************************************************)

Module Test_Pairing_Small.

  Module N := Prelude.
  Module P := Pairing.
  Module R := P.R.

  (* This allows us to write readable constants (e.g., "5") in tests. *)

  Fixpoint of_nat (n : Coq.Init.Datatypes.nat) : N.nat :=
    match n with
    | Coq.Init.Datatypes.O => N.O
    | Coq.Init.Datatypes.S k => N.S (of_nat k)
    end.

  (*
    Local list constructors for the project's list type.
  *)

  Definition lnil : R.list N.nat := R.nil.
  Definition lcons (a : Coq.Init.Datatypes.nat) (xs : R.list N.nat) : R.list N.nat :=
    R.cons (of_nat a) xs.
  Definition l1 (a : Coq.Init.Datatypes.nat) : R.list N.nat := lcons a lnil.
  Definition l2 (a b : Coq.Init.Datatypes.nat) : R.list N.nat := lcons a (l1 b).

  (*
    Project-pair projection without relying on any external libraries.
  *)

  Definition fst {A B} (p : R.prod A B) : A :=
    match p with R.pair a _ => a end.
  Definition snd {A B} (p : R.prod A B) : B :=
    match p with R.pair _ b => b end.

  (*************************************************************************)
  (*                                                                       *)
  (*  TEST 1: x=1, y=1                                                     *)
  (*  Expected: pair(1,1)=37; Z(1)={2}; r(1)=3; B=6;                       *)
  (*           even_band={4}; odd_band={9};                                *)
  (*           Z(pair)= {9,4}; unpair(pair)= (1,1).                        *)
  (*                                                                       *)
  (*  We verify the entire pipeline:                                       *)
  (*                                                                       *)
  (*    (i) Zeckendorf support Z(1)                                        *)
  (*   (ii) Rank r(1) and Band B(1)                                        *)
  (*  (iii) Even/Odd band construction                                     *)
  (*   (iv) final pairing value and Unpairing round-trip                   *)
  (*                                                                       *)
  (*************************************************************************)

  (*
    Remark. Convenience embedding of Coq's built-in nat into the
  *)

  Definition x11 : N.nat := of_nat 1.
  Definition y11 : N.nat := of_nat 1.

  (*
    Check exact value: pair(1,1) should correspond to index 37
  *)

  Example test_pair_1_1_value :
    P.pair CarrylessPair x11 y11 = of_nat 37.
  Proof. vm_compute. reflexivity. Qed.

  (*
    Verify internals: Z(1) = [2]
  *)

  Example test_Z_1 :
    P.Z CarrylessPair x11 = l1 2.
  Proof. vm_compute. reflexivity. Qed.

  (*
    Verify internals: rank r(1) = 3
  *)

  Example test_r_1 :
    P.r CarrylessPair x11 = of_nat 3.
  Proof. vm_compute. reflexivity. Qed.

  (*
    Verify internals: band offset B(1) = 6
  *)

  Example test_B_1 :
    P.B CarrylessPair x11 = of_nat 6.
  Proof. vm_compute. reflexivity. Qed.

  (*
    Verify round-trip: unpair(pair(1,1)) reduces to (1,1)
  *)

  Example test_even_band_1 :
    P.even_band CarrylessPair x11 = l1 4.
  Proof. vm_compute. reflexivity. Qed.

  Example test_odd_band_1_1 :
    P.odd_band CarrylessPair x11 y11 = l1 9.
  Proof. vm_compute. reflexivity. Qed.

  Example test_Z_pair_1_1 :
    P.Z CarrylessPair (P.pair CarrylessPair x11 y11) = l2 9 4.
  Proof. vm_compute. reflexivity. Qed.

  Example test_unpair_pair_1_1_fst :
    fst (P.unpair CarrylessPair (P.pair CarrylessPair x11 y11)) = x11.
  Proof. vm_compute. reflexivity. Qed.

  Example test_unpair_pair_1_1_snd :
    snd (P.unpair CarrylessPair (P.pair CarrylessPair x11 y11)) = y11.
  Proof. vm_compute. reflexivity. Qed.

  (*
    TEST 2: x=5, y=3
    Expected: pair(5,3)=4236; unpair(pair)= (5,3).
  *)

  Definition x53 : N.nat := of_nat 5.
  Definition y53 : N.nat := of_nat 3.

  (*
    Check value
  *)

  Example test_pair_5_3_value :
    P.pair CarrylessPair x53 y53 = of_nat 4236.
  Proof. vm_compute. reflexivity. Qed.

  (*
    Check round-trip
  *)

  Example test_unpair_pair_5_3_fst :
    fst (P.unpair CarrylessPair (P.pair CarrylessPair x53 y53)) = x53.
  Proof. vm_compute. reflexivity. Qed.

  Example test_unpair_pair_5_3_snd :
    snd (P.unpair CarrylessPair (P.pair CarrylessPair x53 y53)) = y53.
  Proof. vm_compute. reflexivity. Qed.

End Test_Pairing_Small.


(* ---- theories/M001__BHK_R_Arithmetic/C001__Carryless_Pairing/P6_A__Reflexica_Certificate.v ---- *)

(* P6_A__Reflexica_Certificate.v *)

From Coq Require Import Init.Logic.
From Coq Require Import Logic.ConstructiveEpsilon.
From Coq Require Import Arith.PeanoNat.
From BHK_R.C000 Require Import P0__Reflexica.
From Carryless_Pairing.C001 Require Export P5_T__Carryless_Pairing.

Set Implicit Arguments.
Unset Strict Implicit.

(*************************************************************************)
(*                                                                       *)
(*   C001 / Phase 6 (A) : Reflexica Certificate (Certificate Layer)      *)
(*                                                                       *)
(*   This module provides the "Global Inversion Certificate" for the     *)
(*   Carryless Pairing device.                                           *)
(*                                                                       *)
(*   While Phases R, S, and T provide an effective *device* that         *)
(*   computes correctly (witnessed by regression tests), they do NOT     *)
(*   export a logical proof that 'unpair' inverts 'pair' for ALL inputs. *)
(*                                                                       *)
(*   We introduce a guarantee as an explicit Axiom (Reflexica).          *)
(*   Downstream theories (C002+) that require correctness properties     *)
(*   (e.g. injectivity) must import this file.                           *)
(*                                                                       *)
(*    (i) Opt-in: This file is separated from P5_T.                      *)
(*        One can use the device computationally without accepting this. *)
(*                                                                       *)
(*   (ii) Minimal: We assume only the single record instance. All other  *)
(*        theorems (injectivity, projections) are derived constructively *)
(*        from that single point of failure.                             *)
(*                                                                       *)
(*  (iii) We provide a method of switching between models of             *)
(*        “arithmetic truth”.                                            *)
(*                                                                       *)
(*************************************************************************)

Module Carryless_Reflexica.

  Module N := Prelude.
  Module P := Pairing.

  (*
    We adapt the Carryless Pairing device to match the input signature
    expected by the generic Reflexica functor.
  *)

  Module Sig <: P0__Reflexica.Reflexica.PAIRING_SIG.
    Definition nat : Type := N.nat.

  (*************************************************************************)
  (*                                                                       *)
  (*  Remark. Reflexica expects a return type of (nat * nat), so we map    *)
  (*  the device's custom product type to the standard tuple.              *)
  (*                                                                       *)
  (*  We adapt the Carryless Pairing device to match the input signature   *)
  (*  expected by the generic Reflexica functor.                           *)
  (*                                                                       *)
  (*************************************************************************)

    Definition pair : nat -> nat -> nat := P.pair CarrylessPair.
    Definition unpair (z : nat) : nat * nat :=
      let p := P.unpair CarrylessPair z in (P.fst p, P.snd p).
  End Sig.

  Module Cert := P0__Reflexica.Reflexica.Make(Sig).

  Definition REFLEXICA : Prop := Cert.REFLEXICA.

  (*************************************************************************)
  (*                                                                       *)
  (*  CONFIGURATION SWITCH                                                 *)
  (*                                                                       *)
  (*  Set to [true]  for BHK_R approach: clean single axiom (recommended)  *)
  (*  Set to [false] for Rocq approach:  heavy Standard Library bypass     *)
  (*                                                                       *)
  (*************************************************************************)

  Definition USE_BHK_R : bool := true.  (* <-- EDIT THIS LINE TO SWITCH *)

  (*************************************************************************)
  (*                                                                       *)
  (*  Approach One (Standard).                                             *)
  (*                                                                       *)
  (*  We assert that the “pullback” between Modus Ponens (the logical      *)
  (*  step) and the Golden Ratio (the geometric limit) satisfies the       *)
  (*  Reflexica record.                                                    *)
  (*                                                                       *)
  (*  We derive from this our “Carryless Pairing” and trust it as a        *)
  (*  structural necessity:                                                *)
  (*                                                                       *)
  (*  No finitary ratio will ever fully express an irrational number.      *)
  (*                                                                       *)
  (*************************************************************************)

  Module BHK_R_Approach.
    Axiom axiom : REFLEXICA.
  End BHK_R_Approach.

  (*************************************************************************)
  (*                                                                       *)
  (*  Approach Two (Rocq Library Bypass).                                  *)
  (*                                                                       *)
  (*  Instead of an “axiom”, we import ConstructiveEpsilon and construct   *)
  (*  the certificate via search. This demonstrates                        *)
  (*                                                                       *)
  (*  The project uses Prelude.nat (custom inductive), not Coq's nat.      *)
  (*  ConstructiveEpsilon expects Coq's nat, so we need.                   *)
  (*                                                                       *)  
  (*    (i) A bijection between Prelude.nat and Coq.Init.Datatypes.nat     *)
  (*        Decidable equality on Prelude.nat                              *)
  (*   (ii) Transport proofs across the bijection                          *)
  (*                                                                       *)
  (*  We belive this demonstrates why the clean single-axiom should be     *)
  (*  preferred.                                                           *)
  (*                                                                       *)
  (*************************************************************************)

  Module Rocq_Approach.

    (* Decidability of equality on Sig.nat (Prelude.nat) *)
    Definition sig_nat_eq_dec : forall x y : Sig.nat, {x = y} + {x <> y}.
    Proof.
      induction x as [|x' IHx]; destruct y as [|y'].
      - left. reflexivity.
      - right. discriminate.
      - right. discriminate.
      - destruct (IHx y') as [Heq | Hneq].
        + left. rewrite Heq. reflexivity.
        + right. intro H. apply Hneq. inversion H. reflexivity.
    Defined.

    (*
      To use constructive_indefinite_description_nat, we would need to convert
       between Prelude.nat and Coq's nat. They are isomorphic but distinct types.

      This is a fundamental limitation: ConstructiveEpsilon is designed for
      Coq.Init.Datatypes.nat, not user-defined inductive types.

      To make this work, we would need:

        (i) A bijection nat_to_coq : Sig.nat -> Coq.Init.Datatypes.nat
       (ii) Its inverse coq_to_nat : Coq.Init.Datatypes.nat -> Sig.nat
      (iii) Proofs that they compose to identity
       (iv) Transport lemmas for pair/unpair across the bijection

      This overhead demonstrates why the Standard Library approach is "heavy".
    *)

    Definition search_fst (y z : Sig.nat) (Hz : exists x, Sig.pair x y = z) :
      {x : Sig.nat | Sig.pair x y = z}.
    Proof.
      (* Would use constructive_indefinite_description_nat after encoding *)
      admit.
    Admitted.

    Definition search_snd (x z : Sig.nat) (Hz : exists y, Sig.pair x y = z) :
      {y : Sig.nat | Sig.pair x y = z}.
    Proof.

      (*
        Would use constructive_indefinite_description_nat after encoding
      *)

      admit.
    Admitted.

    (*
      The certificate via Standard Library search.
    *)

    Definition certificate : REFLEXICA.
    Proof.
      constructor.
      intros x y.

      (*
         The Standard Library gives us search machinery, but connecting it
         to the specific pair/unpair implementation requires assumptions
         that are equivalent to what Reflexica provides directly.

         This demonstrates: the "heavy" approach doesn't eliminate axioms,
         it just scatters them across admitted lemmas and type conversions.

         Either way, by isolating the "source of truth" behind a single boolean switch (USE_BHK_R),
         we establish that the rest of the system (the "Additive Theory" and "Mirror Lemma")
         is completely agnostic to how arithmetic truth is established, provided it is established.
      *)

      admit.
    Admitted.

  End Rocq_Approach.

  (*
    Implementation of our “switch”
  *)

  Definition Reflexica : REFLEXICA :=
    match USE_BHK_R with
    | true  => BHK_R_Approach.axiom
    | false => Rocq_Approach.certificate
    end.

  (*************************************************************************)
  (*                                                                       *)
  (*  BHK Perspective.                                                     *)
  (*                                                                       *)
  (*  From the perspective of BHK, the method of certification             *)
  (*  (“MLTT Judgment” vs. “Geometric Iterant”) is secondary.              *)
  (*                                                                       *)
  (*  Once we accept a “first” realization, it is such, as the absurd      *)
  (*  has no realization. Recursion becomes a witness of consistency.      *)
  (*                                                                       *)
  (*************************************************************************)

  Definition unpair_pair_reflexica :
    forall x y : N.nat,
      Sig.unpair (Sig.pair x y) = (x, y) :=
    Cert.unpair_pair_reflexica Reflexica.

  Definition fst_unpair_pair_reflexica :
    forall x y : N.nat,
      fst (Sig.unpair (Sig.pair x y)) = x :=
    Cert.fst_unpair_pair_reflexica Reflexica.

  Definition snd_unpair_pair_reflexica :
    forall x y : N.nat,
      snd (Sig.unpair (Sig.pair x y)) = y :=
    Cert.snd_unpair_pair_reflexica Reflexica.

  Theorem pair_inj_reflexica :
    forall x1 y1 x2 y2 : N.nat,
      P.pair CarrylessPair x1 y1 = P.pair CarrylessPair x2 y2 ->
      x1 = x2 /\ y1 = y2.
  Proof.
    exact (Cert.pair_inj_reflexica Reflexica).
  Qed.

End Carryless_Reflexica.

(*
  Phase-free Reflexica consequences (axiom-dependent public surface).
*)

Module Reflexica := Carryless_Reflexica.

Module N := Prelude.
Module P := Pairing.

Theorem unpair_pair_public :
  forall x y : N.nat,
    Carryless_Reflexica.Sig.unpair (Carryless_Reflexica.Sig.pair x y) = (x, y).
Proof.
  exact Reflexica.unpair_pair_reflexica.
Qed.

Theorem fst_unpair_pair_public :
  forall x y : N.nat,
    fst (Carryless_Reflexica.Sig.unpair (Carryless_Reflexica.Sig.pair x y)) = x.
Proof.
  exact Reflexica.fst_unpair_pair_reflexica.
Qed.

Theorem snd_unpair_pair_public :
  forall x y : N.nat,
    snd (Carryless_Reflexica.Sig.unpair (Carryless_Reflexica.Sig.pair x y)) = y.
Proof.
  exact Reflexica.snd_unpair_pair_reflexica.
Qed.

Theorem pair_inj_public :
  forall x1 y1 x2 y2 : N.nat,
    P.pair CarrylessPair x1 y1 = P.pair CarrylessPair x2 y2 ->
    x1 = x2 /\ y1 = y2.
Proof.
  exact Reflexica.pair_inj_reflexica.
Qed.


(* ---- theories/M001__BHK_R_Arithmetic/C002__Additive_Hilbert_System/P1_S__Kernel_Spec.v ---- *)

(* P1_S__Kernel_Spec.v *)

From Coq Require Import Init.Logic.
From BHK_R.C000 Require Export P0__Reflexica.

Set Implicit Arguments.
Unset Strict Implicit.

(*************************************************************************)
(*                                                                       *)
(*  C002 / Phase 1 (S) : Proof Kernel                                    *)
(*                                                                       *)
(*  Role.                                                                *)
(*                                                                       *)
(*    (i) Minimal Dependencies: It relies only on the C000 Nucleus.      *)
(*                                                                       *)
(*   (ii) Checker-First: A proof system is defined primarily by a total  *)
(*        boolean checker ('check').                                     *)
(*                                                                       *)
(*  (iii) Soundness Envelope: The propositional predicate 'Prf' is       *)
(*        derived from the checker via a soundness condition.            *)
(*                                                                       *)
(*  This module defines the architectural contract for a “Proof Kernel”  *)
(*  It establishes the "Checker-First" discipline used throughout C002.  *)
(*                                                                       *)
(*************************************************************************)

(*
  Re-export the C000 Prelude so downstream users have access to 'nat'
*)

Module Prelude := BHK_R.C000.P0__Reflexica.Prelude.
Export Prelude.

Module C_002_Prelim.

  (*
    Local Datatypes.

    To keep the kernel dependency-light, we define minimal local types
    for booleans, options, and lists. This prevents heavy library
    imports from polluting the trusted kernel base.
  *)

  Inductive bool : Type := true | false.

  Inductive option (A : Type) : Type :=
    | Some : A -> option A
    | None : option A.

  (*
    Lists are used to represent proof scripts (linear sequences of formulas)
  *)

  Inductive list (A : Type) : Type :=
    | nil  : list A
    | cons : A -> list A -> list A.

  Arguments nil  {A}.
  Arguments cons {A} _ _.
  Arguments Some {A} _.
  Arguments None {A}.

  (*
    The Proof Kernel Contract.
    Proof kernel contract: checker-first, Prop only as envelope.
  *)

  Record ProofKernel : Type := {

    (*
      The type of formulas (object language)
    *)

    Form  : Type;

    (*
      The type of proof objects (e.g., lists of formulas)
    *)

    Proof : Type;

    (*
      Ground Truth: A total boolean function that validates a proof
    *)
    
    check : Proof -> Form -> bool;

    (*
      The Semantic Envelope: A Prop-level predicate
    *)

    Prf   : Proof -> Form -> Prop;   

    (*
      The Consistency Link: If the checker says 'true', the Prop holds.
      This allows us to use computation (check) to witness logical facts.
    *)

    check_sound :
      forall (p : Proof) (phi : Form),
        check p phi = true -> Prf p phi
  }.

  (*************************************************************************)
  (*                                                                       *)
  (*  This record defines the specific *logical* structure we require:     *)
  (*  An implicational logic with Falsity, closed under Modus Ponens.      *)
  (*                                                                       *)
  (*  Remark. 'Prov' here is the existential projection of 'Prf':          *)
  (*                                                                       *)
  (*               Prov phi <-> exists p, Prf p phi                        *)
  (*                                                                       *)
  (*************************************************************************)

  Record AdditiveProvability : Type := {

    Form_ATP : Type;

    (*
      Connectives
    *)

    Imp : Form_ATP -> Form_ATP -> Form_ATP;
    Bot : Form_ATP;

    (*
      The Provability Predicate
    *)

    Prov : Form_ATP -> Prop;

    (*************************************************************************)
    (*                                                                       *)
    (*  The Closure Principle: Modus Ponens.                                 *)
    (*                                                                       *)
    (*  Only inference rule required at higher levels.                       *)
    (*  Internal rules (K, S, EFQ) are hidden inside 'Prov'.                 *)
    (*                                                                       *)
    (*************************************************************************)

    Prov_MP :
      forall (A B : Form_ATP),
        Prov (Imp A B) -> Prov A -> Prov B
  }.

End C_002_Prelim.

Export C_002_Prelim.


(* ---- theories/M001__BHK_R_Arithmetic/C002__Additive_Hilbert_System/P2_R__Hilbert_Kernel.v ---- *)

(* P2_R__Hilbert_Kernel.v *)

From Coq Require Import Init.Logic.
From ATP.C002 Require Import P1_S__Kernel_Spec.

Set Implicit Arguments.
Unset Strict Implicit.

Module C_002_HilbertKernel_R.

  Import C_002_Prelim.

  (*
    Object language.
  *)

  Inductive Form : Type :=
    | F_Bot : Form
    | F_Imp : Form -> Form -> Form.

  Definition Imp (A B : Form) : Form := F_Imp A B.
  Definition Bot : Form := F_Bot.

  (*
    Membership over local lists
  *)

  Inductive In {A : Type} (x : A) : list A -> Prop :=
    | In_here  : forall xs, In x (cons x xs)
    | In_there : forall y xs, In x xs -> In x (cons y xs).

  (*
    Boolean combinators (local bool)
  *)

  Definition orb (b1 b2 : bool) : bool :=
    match b1 with true => true | false => b2 end.

  Definition andb (b1 b2 : bool) : bool :=
    match b1 with true => b2 | false => false end.

  Lemma andb_true_elim :
    forall b1 b2, andb b1 b2 = true -> b1 = true /\ b2 = true.
  Proof.
    intros b1 b2 H. destruct b1.
    - simpl in H. split; [exact (eq_refl _)| exact H].
    - simpl in H. discriminate H.
  Qed.

  Lemma orb_true_elim :
    forall b1 b2, orb b1 b2 = true -> b1 = true \/ b2 = true.
  Proof.
    intros b1 b2 H. destruct b1.
    - left. exact (eq_refl _).
    - right. exact H.
  Qed.

  (*
    Boolean equality for formulas
  *)

  Fixpoint form_eqb (A B : Form) : bool :=
    match A, B with
    | F_Bot, F_Bot => true
    | F_Imp A1 A2, F_Imp B1 B2 =>
        andb (form_eqb A1 B1) (form_eqb A2 B2)
    | _, _ => false
    end.

  Lemma form_eqb_refl : forall A, form_eqb A A = true.
  Proof.
    induction A as [|A1 IH1 A2 IH2].
    - simpl. exact (eq_refl _).
    - simpl. rewrite IH1. exact IH2.
  Qed.

  Lemma form_eqb_true_eq : forall A B, form_eqb A B = true -> A = B.
  Proof.
    induction A as [|A1 IH1 A2 IH2]; intros B H.
    - destruct B; [exact (eq_refl _)| simpl in H; discriminate H].
      (* 'Hilbert looks like the Architect' *)
    - destruct B; [simpl in H; discriminate H|].
      simpl in H.
      apply andb_true_elim in H as [H1 H2].
      apply IH1 in H1; subst.
      apply IH2 in H2; subst.
      exact (eq_refl _).
  Qed.

  (*
    K, S, EFQ
  *)

  Inductive Ax : Form -> Prop :=
    | Ax_K   : forall A B, Ax (Imp A (Imp B A))
    | Ax_S   : forall A B C,
        Ax (Imp (Imp A (Imp B C)) (Imp (Imp A B) (Imp A C)))
    | Ax_EFQ : forall A, Ax (Imp Bot A).

  (*
    Boolean axiom recognizers
  *)

  Definition is_K (phi : Form) : bool :=
    match phi with
    | F_Imp A (F_Imp _ A') => form_eqb A A'
    | _ => false
    end.

  Definition is_EFQ (phi : Form) : bool :=
    match phi with
    | F_Imp F_Bot _ => true
    | _ => false
    end.

  Definition is_S (phi : Form) : bool :=
    match phi with
    | F_Imp (F_Imp A (F_Imp B C))
            (F_Imp (F_Imp A1 B1) (F_Imp A2 C2)) =>
        andb (andb (form_eqb A A1) (form_eqb A A2))
             (andb (form_eqb B B1) (form_eqb C C2))
    | _ => false
    end.

  Definition is_axiom (phi : Form) : bool :=
    orb (is_EFQ phi) (orb (is_K phi) (is_S phi)).

  Lemma is_K_sound : forall phi, is_K phi = true -> Ax phi.
  Proof.
    intros phi H.
    destruct phi as [|A R]; simpl in H; try discriminate H.
    destruct R as [|B A']; simpl in H; try discriminate H.
    apply form_eqb_true_eq in H; subst.
    apply Ax_K.
  Qed.

  Lemma is_EFQ_sound : forall phi, is_EFQ phi = true -> Ax phi.
  Proof.
    intros phi H. destruct phi as [|L R]; simpl in H; try discriminate H.
    destruct L; simpl in H; try discriminate H.
    apply Ax_EFQ.
  Qed.

  Lemma is_S_sound : forall phi, is_S phi = true -> Ax phi.
  Proof.
    intros phi H.
    destruct phi as [|L R]; simpl in H; try discriminate H.
    destruct L as [|A LR]; simpl in H; try discriminate H.
    destruct LR as [|B C]; simpl in H; try discriminate H.
    destruct R as [|R1 R2]; simpl in H; try discriminate H.
    destruct R1 as [|A1 B1]; simpl in H; try discriminate H.
    destruct R2 as [|A2 C2]; simpl in H; try discriminate H.
    apply andb_true_elim in H as [Hleft Hright].
    apply andb_true_elim in Hleft as [HA1 HA2].
    apply andb_true_elim in Hright as [HB1 HC2].
    apply form_eqb_true_eq in HA1; subst A1.
    apply form_eqb_true_eq in HA2; subst A2.
    apply form_eqb_true_eq in HB1; subst B1.
    apply form_eqb_true_eq in HC2; subst C2.
    apply Ax_S.
  Qed.

  Lemma is_axiom_sound : forall phi, is_axiom phi = true -> Ax phi.
  Proof.
    intros phi H.
    unfold is_axiom in H.
    apply orb_true_elim in H as [HE|Hrest].
    - apply is_EFQ_sound. exact HE.
    - apply orb_true_elim in Hrest as [HK|HS].
      + apply is_K_sound. exact HK.
      + apply is_S_sound. exact HS.
  Qed.

  (*
    Proof scripts: linear lists of formulas
  *)

  Definition Proof : Type := list Form.

  (*
    Boolean list search + soundness
  *)

  Fixpoint existsb {A : Type} (p : A -> bool) (xs : list A) : bool :=
    match xs with
    | nil => false
    | cons x xs' => orb (p x) (existsb p xs')
    end.

  Lemma existsb_sound :
    forall (A : Type) (p : A -> bool) (xs : list A),
      existsb p xs = true ->
      exists x : A, In x xs /\ p x = true.
  Proof.
    intros A p xs H.
    induction xs as [|x xs IH].
    - simpl in H. discriminate H.
    - simpl in H.
      unfold orb in H.
      destruct (p x) eqn:Px.
      + exists x. split; [apply In_here| exact Px].
      + specialize (IH H).
        destruct IH as [y [Hyin Hyp]].
        exists y. split; [apply In_there; exact Hyin| exact Hyp].
  Qed.

  (*
    MP witness: ctx contains psi and (psi -> phi)
  *)

  Definition mp_witness (ctx : list Form) (phi : Form) : bool :=
    existsb
      (fun psi =>
         existsb
           (fun chi =>
              match chi with
              | F_Imp X Y =>
                  andb (form_eqb X psi) (form_eqb Y phi)
              | _ => false
              end)
           ctx)
      ctx.

  Lemma mp_witness_sound :
    forall (ctx : list Form) (phi : Form),
      mp_witness ctx phi = true ->
      exists psi : Form, In psi ctx /\ In (Imp psi phi) ctx.
  Proof.
    intros ctx phi Hmw.
    unfold mp_witness in Hmw.
    pose proof (existsb_sound
                  (A := Form)
                  (p := fun psi =>
                          existsb
                            (fun chi =>
                               match chi with
                               | F_Imp X Y =>
                                   andb (form_eqb X psi) (form_eqb Y phi)
                               | _ => false
                               end)
                            ctx)
                  (xs := ctx)
                  Hmw) as Hpsi.
    destruct Hpsi as [psi [HinPsi Hinner]].

    pose proof (existsb_sound
                  (A := Form)
                  (p := fun chi =>
                          match chi with
                          | F_Imp X Y =>
                              andb (form_eqb X psi) (form_eqb Y phi)
                          | _ => false
                          end)
                  (xs := ctx)
                  Hinner) as Hchi.
    destruct Hchi as [chi [HinChi Hchi_ok]].

    destruct chi as [|X Y].
    - simpl in Hchi_ok. discriminate Hchi_ok.
    - simpl in Hchi_ok.
      apply andb_true_elim in Hchi_ok as [HX HY].
      apply form_eqb_true_eq in HX; subst X.
      apply form_eqb_true_eq in HY; subst Y.
      exists psi. split; [exact HinPsi| exact HinChi].
  Qed.

  (*
    Sequential checker
  *)

  Fixpoint check_lines (ctx : list Form) (pf : Proof) : bool :=
    match pf with
    | nil => true
    | cons line rest =>
        let ok_line := orb (is_axiom line) (mp_witness ctx line) in
        andb ok_line (check_lines (cons line ctx) rest)
    end.

  Fixpoint last_opt (pf : Proof) : option Form :=
    match pf with
    | nil => @None Form
    | cons x nil => Some x
    | cons _ xs => last_opt xs
    end.

  Definition check (pf : Proof) (goal : Form) : bool :=
    match last_opt pf with
    | @None _ => false
    | Some last => andb (check_lines nil pf) (form_eqb last goal)
    end.

  (*
    Prop-level derivability mirroring check_lines
  *)

  Inductive Prf_lines : list Form -> Proof -> Prop :=
    | Prf_lines_nil :
        forall ctx, Prf_lines ctx nil
    | Prf_lines_cons_Ax :
        forall ctx line rest,
          Ax line ->
          Prf_lines (cons line ctx) rest ->
          Prf_lines ctx (cons line rest)
    | Prf_lines_cons_MP :
        forall ctx psi line rest,
          In psi ctx ->
          In (Imp psi line) ctx ->
          Prf_lines (cons line ctx) rest ->
          Prf_lines ctx (cons line rest).

  Inductive Prf : Proof -> Form -> Prop :=
    | Prf_intro :
        forall pf phi,
          last_opt pf = Some phi ->
          Prf_lines nil pf ->
          Prf pf phi.

  (*
    Soundness of check_lines and check
  *)

  Lemma check_lines_sound :
    forall ctx pf,
      check_lines ctx pf = true ->
      Prf_lines ctx pf.
  Proof.
    intros ctx pf H.
    revert ctx H.
    induction pf as [|line rest IH]; intros ctx H.
    - constructor.
    - simpl in H.
      apply andb_true_elim in H as [Hok Hrest].
      unfold orb in Hok.
      destruct (is_axiom line) eqn:HAx.
      + apply Prf_lines_cons_Ax.
        * apply is_axiom_sound. exact HAx.
        * apply IH. exact Hrest.
      + pose proof (mp_witness_sound (ctx := ctx) (phi := line) Hok) as Hw.
        destruct Hw as [psi [HinPsi HinImp]].
        apply Prf_lines_cons_MP with (psi := psi).
        * exact HinPsi.
        * exact HinImp.
        * apply IH. exact Hrest.
  Qed.

  Theorem check_sound :
    forall (pf : Proof) (phi : Form),
      check pf phi = true -> Prf pf phi.
  Proof.
    intros pf phi H.
    unfold check in H.
    destruct (last_opt pf) as [last|] eqn:Hlast.
    - simpl in H.
      apply andb_true_elim in H as [Hlines Heq].
      apply form_eqb_true_eq in Heq; subst phi.
      apply Prf_intro with (phi := last).
      + exact Hlast.
      + apply check_lines_sound. exact Hlines.
    - simpl in H. discriminate H.
  Qed.

  (*
    Package the ProofKernel contract
  *)

  Definition HilbertKernel : ProofKernel :=
    {|
      C_002_Prelim.Form := Form;
      C_002_Prelim.Proof := Proof;
      C_002_Prelim.check := check;
      C_002_Prelim.Prf := Prf;
      C_002_Prelim.check_sound := check_sound
    |}.

End C_002_HilbertKernel_R.

Export C_002_HilbertKernel_R.


(* ---- theories/M001__BHK_R_Arithmetic/C002__Additive_Hilbert_System/P2_S__Provability_Interface.v ---- *)

(* P2_S__Provability_Interface.v *)

From Coq Require Import Init.Logic.
From ATP.C002 Require Import P1_S__Kernel_Spec.
From ATP.C002 Require Import P2_R__Hilbert_Kernel.

Set Implicit Arguments.
Unset Strict Implicit.

(*************************************************************************)
(*                                                                       *)
(*  C002 / Phase 2 (S) : Provability Interface Binding                   *)
(*                                                                       *)
(*  Role:                                                                *)
(*                                                                       *)
(*  This module binds the abstract notion of "Provability" to the        *)
(*  concrete Hilbert Kernel implementation from Phase R.                 *)
(*                                                                       *)
(*    (i) it binds the abstract notion of "Provability" to               *)
(*        the concrete Hilbert Kernel implementation from Phase R.       *)
(*                                                                       *)
(*   (ii) It defines the 'Prov' predicate as,                            *)
(*                                                                       *)
(*               Prov(phi) <-> exists pf, Prf(pf, phi)                   *)
(*                                                                       *)
(*   This confirms the "Witness-First" discipline: to be provable        *)
(*   means to possess a concrete proof object (a script) that checks.    *)
(*                                                                       *)
(*************************************************************************)

Module C_002_Provability_S.

  Import C_002_Prelim.
  Import C_002_HilbertKernel_R. (* Realizes K, S, EFQ, check, Prf *)

  (*************************************************************************)
  (*                                                                       *)
  (*  Object Language Mapping.                                             *)
  (*                                                                       *)
  (*  We map the abstract Form/Imp/Bot types to the concrete inductive     *)
  (*  types defined in the R-layer.                                        *)
  (*                                                                       *)
  (*************************************************************************)


  Definition Form : Type := C_002_HilbertKernel_R.Form.
  Definition Imp  : Form -> Form -> Form := C_002_HilbertKernel_R.Imp.
  Definition Bot  : Form := C_002_HilbertKernel_R.Bot.

  Definition Prov (phi : Form) : Prop :=
    exists pf : C_002_HilbertKernel_R.Proof, C_002_HilbertKernel_R.Prf pf phi.


  (*************************************************************************)
  (*                                                                       *)
  (*  The Soundness Bridge.                                                *)
  (*                                                                       *)
  (*  This lemma allows us to prove 'Prov phi' by simply running the       *)
  (*  kernel checker. If 'check pf phi' returns true, we immediately       *)
  (*  have a witness for 'Prov phi'.                                       *)
  (*                                                                       *)
  (*  Usage: apply Prov_from_check with (pf := my_script).                 *)
  (*  vm_compute. reflexivity.                                             *)
  (*                                                                       *)
  (*************************************************************************)

  Lemma Prov_from_check :
    forall (pf : C_002_HilbertKernel_R.Proof) (phi : Form),
      C_002_HilbertKernel_R.check pf phi = true ->
      Prov phi.
  Proof.

  (*
    Construct the existential witness
  *)

    intros pf phi Hc.
    exists pf.

    (*
      Use the kernel's internal soundness theorem
    *)

    apply C_002_HilbertKernel_R.check_sound. exact Hc.
  Qed.

End C_002_Provability_S.

Export C_002_Provability_S.


(* ---- theories/M001__BHK_R_Arithmetic/C002__Additive_Hilbert_System/P3_R__Additive_Laws.v ---- *)

(* P3_R__Additive_Laws.v *)

From Coq Require Import Init.Logic.

From ATP.C002 Require Import P1_S__Kernel_Spec.
From ATP.C002 Require Import P2_R__Hilbert_Kernel.
From ATP.C002 Require Import P2_S__Provability_Interface.

Set Implicit Arguments.
Unset Strict Implicit.

Module C_002_Additive_Laws_R.

  Import C_002_Prelim.
  Import C_002_HilbertKernel_R.
  Import C_002_Provability_S.

  (*
    List operations on local lists
  *)

  Fixpoint app {A : Type} (xs ys : list A) : list A :=
    match xs with
    | nil => ys
    | cons x xs' => cons x (app xs' ys)
    end.

  Notation "xs ++ ys" := (app xs ys) (at level 60, right associativity).

  Definition sing {A : Type} (x : A) : list A := cons x nil.

  (*
    Context extension matching Prf_lines' operational growth
  *)

  Fixpoint extend_ctx (ctx : list Form) (pf : Proof) : list Form :=
    match pf with
    | nil => ctx
    | cons line rest => extend_ctx (cons line ctx) rest
    end.

  Lemma extend_ctx_app :
    forall (ctx : list Form) (pf1 pf2 : Proof),
      extend_ctx ctx (pf1 ++ pf2) = extend_ctx (extend_ctx ctx pf1) pf2.
  Proof.
    intros ctx pf1 pf2. revert ctx.
    induction pf1 as [|x xs IH]; intro ctx.
    - simpl. exact (eq_refl _).
    - simpl. apply IH.
  Qed.

  (*
    Weakening for Prf_lines
  *)

  Definition incl (xs ys : list Form) : Prop :=
    forall x, In x xs -> In x ys.

  Lemma incl_cons :
    forall a xs ys, incl xs ys -> incl (cons a xs) (cons a ys).
  Proof.
    intros a xs ys Hinc x Hin.
    inversion Hin.
    - subst. apply In_here.
    - apply In_there. apply Hinc. exact H0.
  Qed.

  Lemma Prf_lines_weaken :
    forall (ctx1 ctx2 : list Form) (pf : Proof),
      incl ctx1 ctx2 ->
      Prf_lines ctx1 pf ->
      Prf_lines ctx2 pf.
  Proof.
    intros ctx1 ctx2 pf Hinc Hpf.
    revert ctx2 Hinc.
    induction Hpf; intros ctx2 Hinc.
    - constructor.
    - apply Prf_lines_cons_Ax; try assumption.
      apply IHHpf with (ctx2 := cons line ctx2).
      apply incl_cons. exact Hinc.
    - apply Prf_lines_cons_MP with (psi := psi).
      + apply Hinc. exact H.
      + apply Hinc. exact H0.
      + apply IHHpf with (ctx2 := cons line ctx2).
        apply incl_cons. exact Hinc.
  Qed.

  Lemma Prf_lines_app :
    forall (ctx : list Form) (pf1 pf2 : Proof),
      Prf_lines ctx pf1 ->
      Prf_lines (extend_ctx ctx pf1) pf2 ->
      Prf_lines ctx (pf1 ++ pf2).
  Proof.
    intros ctx pf1 pf2 H1 H2.
    revert pf2 H2.
    induction H1 as
      [ ctx0
      | ctx0 line rest Hax Hrest IH
      | ctx0 psi line rest HinPsi HinImp Hrest IH
      ]; intros pf2 H2'.
    - simpl. exact H2'.
    - simpl. apply Prf_lines_cons_Ax; try exact Hax.
      apply IH. exact H2'.
    - simpl. apply Prf_lines_cons_MP with (psi := psi); try assumption.
      apply IH. exact H2'.
  Qed.

  (*
    Membership is preserved when extending contexts
  *)

  Lemma In_extend_ctx :
    forall x ctx pf,
      In x ctx -> In x (extend_ctx ctx pf).
  Proof.
    intros x ctx pf Hin. revert ctx Hin.
    induction pf as [|line rest IH]; intros ctx Hin.
    - simpl. exact Hin.
    - simpl. apply IH. apply In_there. exact Hin.
  Qed.

  Lemma last_opt_in_extend_ctx :
    forall (ctx : list Form) (pf : Proof) (phi : Form),
      last_opt pf = Some phi ->
      In phi (extend_ctx ctx pf).
  Proof.
    intros ctx pf phi Hlast.
    revert ctx phi Hlast.
    induction pf as [|line rest IH]; intros ctx phi Hlast.
    - simpl in Hlast. discriminate Hlast.
    - destruct rest as [|r rs].
      + simpl in Hlast. inversion Hlast. subst. simpl. apply In_here.
      + simpl in Hlast. simpl. apply IH with (ctx := cons line ctx). exact Hlast.
  Qed.

  Lemma last_opt_app :
    forall (pf1 pf2 : Proof) (phi : Form),
      last_opt pf2 = Some phi ->
      last_opt (pf1 ++ pf2) = Some phi.
  Proof.
    induction pf1 as [|x xs IH]; intros pf2 phi H.
    - simpl. exact H.
    - simpl.
      destruct xs as [|y ys].
      + destruct pf2 as [|p ps].
        * simpl in H. discriminate H.
        * simpl. exact H.
      + simpl. apply IH. exact H.
  Qed.

  (*
    Additive closure: Prov (A->B) -> Prov A -> Prov B
  *)

  Definition compose_MP (pfAB pfA : Proof) (B : Form) : Proof :=
    (pfAB ++ pfA) ++ sing B.

  Theorem Prov_MP :
    forall (A B : Form),
      Prov (Imp A B) ->
      Prov A ->
      Prov B.
  Proof.
    intros A B [pfAB HpfAB] [pfA HpfA].
    inversion HpfAB as [pfAB0 phiAB HlastAB HlinesAB]. subst pfAB0 phiAB.
    inversion HpfA  as [pfA0  phiA  HlastA  HlinesA ]. subst pfA0  phiA.

    exists (compose_MP pfAB pfA B).
    apply Prf_intro with (phi := B).
    - unfold compose_MP. apply last_opt_app. simpl. exact (eq_refl _).
    - unfold compose_MP.

      (*
        First derive pfAB ++ pfA from nil.
      *)

      assert (HpfABpfA : Prf_lines nil (pfAB ++ pfA)).
      {
        apply Prf_lines_app with (pf1 := pfAB) (pf2 := pfA).
        - exact HlinesAB.
        - apply Prf_lines_weaken with (ctx1 := nil).
          + intros x Hin. inversion Hin.
          + exact HlinesA.
      }

      (*
        Now append final line B by MP from A and (A->B) present in ctx.
      *)
      
      apply Prf_lines_app with (pf1 := pfAB ++ pfA) (pf2 := sing B).
      + exact HpfABpfA.
      + apply Prf_lines_cons_MP with (psi := A).
        * rewrite extend_ctx_app.
          apply last_opt_in_extend_ctx with (ctx := extend_ctx nil pfAB).
          exact HlastA.
        * rewrite extend_ctx_app.
          apply In_extend_ctx.
          apply last_opt_in_extend_ctx with (ctx := nil).
          exact HlastAB.
        * constructor.
  Qed.

End C_002_Additive_Laws_R.

Export C_002_Additive_Laws_R.


(* ---- theories/M001__BHK_R_Arithmetic/C002__Additive_Hilbert_System/P3_S__Additive_Theory.v ---- *)

(* P3_S__Additive_Theory.v *)

From Coq Require Import Init.Logic.

From ATP.C002 Require Import P1_S__Kernel_Spec.            (* The Interface Spec *)
From ATP.C002 Require Import P2_S__Provability_Interface.  (* The 'Prov' binding *)
From ATP.C002 Require Import P3_R__Additive_Laws.          (* The MP Proof (Realization) *)

Set Implicit Arguments.
Unset Strict Implicit.

(*************************************************************************)
(*                                                                       *)
(*  C002 / Phase 3 (S) : Additive Theory Packaging                       *)
(*                                                                       *)
(*  Role.                                                                *)
(*                                                                       *)
(*  This module builds the final "Container" for the proof system.       *)
(*                                                                       *)
(*  It takes the raw components,                                         *)
(*                                                                       *)
(*    (i) The Kernel Spec (P1_S)                                         *)
(*                                                                       *)
(*   (ii) The Provability Predicate (P2_S)                               *)
(*                                                                       *)
(*  (iii) The Modus Ponens Realization (P3_R)                            *)
(*                                                                       *)
(*   and packages them into a single ”Additive Provability” record.      *)
(*                                                                       *)
(*   Analogy. A “CSS Class“, or this “box”                               *)
(*                                                                       *)
(*************************************************************************)

Module C_002_Additive_Theory_S.

  Import C_002_Prelim.
  Import C_002_Provability_S.
  Import C_002_Additive_Laws_R. (* Contains the constructive proof of MP *)

  (*************************************************************************)
  (*                                                                       *)
  (*  The Additive Theory Container                                        *)
  (*                                                                       *)
  (*  Here we instantiate the 'AdditiveProvability' record defined in P1.  *)
  (*  We are filling the "div" with concrete content.                      *)
  (*                                                                       *)
  (*************************************************************************)

  Definition C_002_ATP : AdditiveProvability :=
    {|
      Form_ATP := Form;
      C_002_Prelim.Imp := Imp;
      C_002_Prelim.Bot := Bot;

      (*
        The Content: The Provability Predicate
      *)
      
      C_002_Prelim.Prov := Prov;

      (*
        We use the constructive proof 'Prov_MP' from P3_R
      *)

      C_002_Prelim.Prov_MP := Prov_MP
    |}.

  (*
    We alias the fields of the container so downstream users can use
    'ATP_Imp', 'ATP_Prov', etc., without digging into the record.
  *)

  Definition ATP_Form : Type := C_002_ATP.(C_002_Prelim.Form_ATP).
  Definition ATP_Imp  : ATP_Form -> ATP_Form -> ATP_Form := C_002_ATP.(C_002_Prelim.Imp).
  Definition ATP_Bot  : ATP_Form := C_002_ATP.(C_002_Prelim.Bot).
  Definition ATP_Prov : ATP_Form -> Prop := C_002_ATP.(C_002_Prelim.Prov).

  (*
    Our main theory of provability:
    The logic works as expected.
  *)

  Theorem ATP_Prov_MP :
    forall (A B : ATP_Form),
      ATP_Prov (ATP_Imp A B) -> ATP_Prov A -> ATP_Prov B.
  Proof.
    exact (C_002_ATP.(C_002_Prelim.Prov_MP)).
  Qed.

End C_002_Additive_Theory_S.

Export C_002_Additive_Theory_S.


(* ---- theories/M001__BHK_R_Arithmetic/C002__Additive_Hilbert_System/P4_R__Coding_Nucleus.v ---- *)

(* P4_R__Coding_Nucleus.v *)

From Coq Require Import Init.Logic.
From ATP.C002 Require Import P1_S__Kernel_Spec.

Set Implicit Arguments.
Unset Strict Implicit.

(*************************************************************************)
(*                                                                       *)
(*  C_002 / Phase 4 (R): Coding nucleus interface.                       *)
(*                                                                       *)
(*  This file stabilizes the coding dependency surface for downstream    *)
(*  developments (C_003+). It is interface-only: no realization imports, *)
(*  no axioms, and all partiality made explicit via option and fuel.     *)
(*                                                                       *)
(*    (i) Atom and Code are abstract.                                    *)
(*   (ii) Pairing on codes is abstract (may be unused by some codecs).   *)
(*  (iii) Sequence decoding is fuelled explicitly.                       *)
(*   (iv) CODEC_OK packages a codec plus explicit constructive           *)
(*        witnesses for the basic sequence round-trip property.          *)
(*                                                                       *)
(*************************************************************************)

Module C_002_Coding_Nucleus_R.

  Import C_002_Prelim.

  Record CODEC : Type := {
    Atom : Type;
    Code : Type;

    atom0    : Atom;
    atomS    : Atom -> Atom;
    atomPred : Atom -> Atom;

    atom_eqb : Atom -> Atom -> bool;

    (*
      reserved tags
    *)

    tag_bot : Atom;
    tag_imp : Atom;
    tag_sep : Atom;

    pairC   : Code -> Code -> Code;
    unpairC : Code -> option (Code * Code);

    (*
      sequences of atoms encoded as codes
    *)
    
    enc_seq : list Atom -> Code;
    dec_seq_fuel : Atom -> Code -> option (list Atom)
  }.

  Record CODEC_OK : Type := {
    C : CODEC;

    atom_eqb_refl :
      forall a : C.(Atom), C.(atom_eqb) a a = true;

    atom_eqb_sound :
      forall a b : C.(Atom), C.(atom_eqb) a b = true -> a = b;

    fuel_seq : list (C.(Atom)) -> C.(Atom);

    dec_seq_enc_seq :
      forall xs : list (C.(Atom)),
        C.(dec_seq_fuel) (fuel_seq xs) (C.(enc_seq) xs) = Some xs;

    tag_bot_eq : C.(atom_eqb) C.(tag_bot) C.(tag_bot) = true;
    tag_imp_eq : C.(atom_eqb) C.(tag_imp) C.(tag_imp) = true;
    tag_sep_eq : C.(atom_eqb) C.(tag_sep) C.(tag_sep) = true;
    tag_imp_bot_neq : C.(atom_eqb) C.(tag_imp) C.(tag_bot) = false
  }.

End C_002_Coding_Nucleus_R.

Export C_002_Coding_Nucleus_R.



(* ---- theories/M001__BHK_R_Arithmetic/C002__Additive_Hilbert_System/P4_R__Coding_Carryless.v ---- *)

(* P4_R__Coding_Carryless.v *)

From Coq Require Import Init.Logic.

From ATP.C002 Require Import P1_S__Kernel_Spec.
From ATP.C002 Require Import P4_R__Coding_Nucleus.

From Carryless_Pairing.C001 Require Import P5_T__Carryless_Pairing.

Set Implicit Arguments.
Unset Strict Implicit.

(*************************************************************************)
(*                                                                       *)
(*  C_002 / Phase 4 (R): Canonical codec (uses C_001 pairing).           *)
(*                                                                       *)
(*  Role: code-as-nat codec whose pairing/unpairing are sourced from     *)
(*  C_001 CarrylessPair.                                                 *)
(*                                                                       *)
(*************************************************************************)

Module C_002_Coding_R.

  Import C_002_Prelim.
  Module CN := C_002_Coding_Nucleus_R.

  Module CP := Carryless_Pairing.C001.P5_T__Carryless_Pairing.
  Module N  := CP.Prelude.
  Module P  := CP.Pairing.
  Module R  := P.R.

  Definition Atom : Type := N.nat.
  Definition Code : Type := N.nat.

  Definition atom0 : Atom := N.O.
  Definition atomS : Atom -> Atom := N.S.

  Definition atomPred (a : Atom) : Atom :=
    match a with
    | N.O => N.O
    | N.S a' => a'
    end.

  Fixpoint atom_eqb (m n : Atom) : bool :=
    match m, n with
    | N.O, N.O => true
    | N.S m', N.S n' => atom_eqb m' n'
    | _, _ => false
    end.

  Definition tag_bot : Atom := N.O.
  Definition tag_imp : Atom := N.S N.O.
  Definition tag_sep : Atom := N.S (N.S N.O).

  Definition pairC (x y : Code) : Code :=
    P.pair CP.CarrylessPair x y.

  Definition unpairC (z : Code) : option (Code * Code) :=
    let p := P.unpair CP.CarrylessPair z in
    Some (P.fst p, P.snd p).

  (*
    Sequence coding via pairing (S-head, 0-terminator).
  *)

  Fixpoint enc_seq (xs : list Atom) : Code :=
    match xs with
    | nil => N.O
    | cons a xs' => pairC (atomS a) (enc_seq xs')
    end.

  Definition unpair_fuel (fuel : N.nat) (z : Code) : option (Code * Code) :=
    match fuel with
    | N.O => None
    | N.S _ => unpairC z
    end.

  Fixpoint dec_seq_fuel (fuel : N.nat) (z : Code) : option (list Atom) :=
    match fuel with
    | N.O => None
    | N.S fuel' =>
        match atom_eqb z N.O with
        | true => Some nil
        | false =>
            match unpair_fuel fuel z with
            | None => None
            | Some (h, t) =>
                match h with
                | N.O => None
                | N.S a =>
                    match dec_seq_fuel fuel' t with
                    | None => None
                    | Some xs => Some (cons a xs)
                    end
                end
            end
        end
    end.

  Definition Codec : CN.CODEC :=
    {|
      CN.Atom := Atom;
      CN.Code := Code;

      CN.atom0 := atom0;
      CN.atomS := atomS;
      CN.atomPred := atomPred;

      CN.atom_eqb := atom_eqb;

      CN.tag_bot := tag_bot;
      CN.tag_imp := tag_imp;
      CN.tag_sep := tag_sep;

      CN.pairC := pairC;
      CN.unpairC := unpairC;

      CN.enc_seq := enc_seq;
      CN.dec_seq_fuel := dec_seq_fuel
    |}.

End C_002_Coding_R.

Export C_002_Coding_R.


(* ---- theories/M001__BHK_R_Arithmetic/C002__Additive_Hilbert_System/P4_S__Coding.v ---- *)

(* P4_S__Coding.v *)

From Coq Require Import Init.Logic.

From ATP.C002 Require Import P1_S__Kernel_Spec.

From ATP.C002 Require Import P4_R__Coding_Nucleus.
From ATP.C002 Require Import P4_R__Coding_Carryless.

Set Implicit Arguments.
Unset Strict Implicit.

(*************************************************************************)
(*                                                                       *)
(*  C_002 / Phase 4 (S): Coding façade.                                  *)
(*                                                                       *)
(*  Role: stable surface for coding infrastructure used by downstream    *)
(*  developments.                                                        *)
(*                                                                       *)
(*  Policy.                                                              *)
(*    (i) We expose the effective codec device.                          *)
(*   (ii) We do NOT expose a CODEC_OK witness in Phase T.                *)
(*                                                                       *)
(*************************************************************************)

Module C_002_Coding_S.

  Import C_002_Prelim.
  Module CN := ATP.C002.P4_R__Coding_Nucleus.C_002_Coding_Nucleus_R.

  Module R := ATP.C002.P4_R__Coding_Carryless.C_002_Coding_R.

  Definition CODEC : Type := CN.CODEC.

  Definition CanonicalCodec : CODEC := R.Codec.

End C_002_Coding_S.

Export C_002_Coding_S.
Export C_002_Coding_Nucleus_R.


(* ---- theories/M001__BHK_R_Arithmetic/C002__Additive_Hilbert_System/P5_T__Proof_Theory.v ---- *)

(* P5_T__Proof_Theory.v *)

From Coq Require Import Init.Logic.

From ATP.C002 Require Export
  P1_S__Kernel_Spec
  P2_S__Provability_Interface
  P3_S__Additive_Theory
  P4_S__Coding.

Set Implicit Arguments.
Unset Strict Implicit.

(*************************************************************************)
(*                                                                       *)
(*  C002 / Phase 5 (T) : Additive Proof Theory (Public Surface)          *)
(*                                                                       *)
(*  Role.                                                                *)
(*                                                                       *)
(*    (i) This module exports the stable API for the Additive Theory of  *)
(*   (ii) Provability. It hides the distinction between R (Realization)  *)
(*  (iii) S (Semantic) layers, presenting a unified view of the logic.   *)
(*                                                                       *)
(*  Components.                                                          *)
(*                                                                       *)
(*    (i) Prelude: The arithmetic nucleus (re-exported).                 *)
(*   (ii) ATP: The core logic (formulas, implication, provability).      *)
(*  (iii) Coding: The canonical codec (formulas <-> nat).                *)
(*                                                                       *)
(*************************************************************************)

Module Prelude.
  Include ATP.C002.P1_S__Kernel_Spec.C_002_Prelim.
  Include BHK_R.C000.P0__Reflexica.Prelude.
End Prelude.

Module ATP    := ATP.C002.P3_S__Additive_Theory.C_002_Additive_Theory_S.
Module Coding := ATP.C002.P4_S__Coding.C_002_Coding_S.

(*
  Preferred downstream surface: additive provability nucleus.
*)

Definition ATP_Form : Type := ATP.ATP_Form.
Definition ATP_Imp  : ATP_Form -> ATP_Form -> ATP_Form := ATP.ATP_Imp.
Definition ATP_Bot  : ATP_Form := ATP.ATP_Bot.
Definition ATP_Prov : ATP_Form -> Prop := ATP.ATP_Prov.

Definition Bot : ATP_Form := ATP_Bot.
Definition Imp : ATP_Form -> ATP_Form -> ATP_Form := ATP_Imp.

Notation "A --> B" := (ATP_Imp A B) (at level 60, right associativity).

(*
  This is the main "feature" of C002: The logic supports Modus Ponens.
  It is witnessed by the constructive proof in P3_R.
*)

Theorem ATP_Prov_MP :
  forall (A B : ATP_Form),
    ATP_Prov (A --> B) -> ATP_Prov A -> ATP_Prov B.
Proof.
  exact ATP.ATP_Prov_MP.
Qed.

(* Alias for convenience *)

Theorem Prov_app :
  forall (A B : ATP_Form),
    ATP_Prov (A --> B) -> ATP_Prov A -> ATP_Prov B.
Proof.
  exact ATP_Prov_MP.
Qed.

(*
  This section exposes the "Checker-First" nature of the logic.
  It allows users to prove theorems by computation:
  If 'check pf phi' returns true, then 'Prov phi' holds.
*)

Module ProvIntf := ATP.C002.P2_S__Provability_Interface.C_002_Provability_S.

Definition Prov_Form : Type := ProvIntf.Form.
Definition Prov_Imp  : Prov_Form -> Prov_Form -> Prov_Form := ProvIntf.Imp.
Definition Prov_Bot  : ProvIntf.Form := ProvIntf.Bot.
Definition Prov      : Prov_Form -> Prop := ProvIntf.Prov.

Theorem Prov_from_check :
  forall (pf : ATP.C002.P2_R__Hilbert_Kernel.C_002_HilbertKernel_R.Proof)
         (phi : Prov_Form),
    ATP.C002.P2_R__Hilbert_Kernel.C_002_HilbertKernel_R.check pf phi = true ->
    Prov phi.
Proof.
  exact ProvIntf.Prov_from_check.
Qed.

(*
  Coding Re-exports.
  Exposes the canonical codec interface and instance.
*)

Definition CODEC : Type :=
  ATP.C002.P4_R__Coding_Nucleus.C_002_Coding_Nucleus_R.CODEC.
  
Definition CanonicalCodec : CODEC := Coding.CanonicalCodec.


(* ---- theories/M001__BHK_R_Arithmetic/C002__Additive_Hilbert_System/P6_P__Effectivity.v ---- *)

(* P4_T__Effectivity.v *)

From Coq Require Import Init.Logic.

From ATP.C002 Require Import P5_T__Proof_Theory.
From ATP.C002 Require Import P2_R__Hilbert_Kernel.

Set Implicit Arguments.
Unset Strict Implicit.

(*************************************************************************)
(*                                                                       *)
(*  P4_T__Effectivity.v                                                  *)
(*                                                                       *)
(*  This file is intentionally not part of the logical development       *)
(*  chain (C003+). It is an effectivity witness and executable           *)
(*  documentation for C_002, in the same spirit as C_001's               *)
(*  P4_T__Effectivity.v.                                                 *)
(*                                                                       *)
(*  Methodology note (BHK_R discipline):                                 *)
(*  All correctness statements here are witnessed by computation         *)
(*  (vm_compute), not by propositional reasoning or axioms.              *)
(*                                                                       *)
(*  What is tested.                                                      *)
(*                                                                       *)
(*     (i) The proof kernel checker recognizes axiom instances.          *)
(*                                                                       *)
(*    (ii) The checker validates a small MP-derived script.              *)
(*                                                                       *)
(*   (iii) The canonical codec (using C_001 pairing) round-trips on      *)
(*         small examples with explicit fuel (computational check).      *)
(*                                                                       *)
(*  What is also tested.                                                 *)
(*                                                                       *)
(*     (i) Effectivity: The diagonal function `diag(t)` actually         *)
(*         computes to a concrete syntax tree for specific inputs.       *)
(*                                                                       *)
(*    (ii) The Diagonal Law: The fundamental equation                    *)
(*         encU (diag t) = eval E_t (selfpack (encU delta_t))            *)
(*         holds by DEFINITIONAL equality (normalization).               *)
(*                                                                       *)
(*   (iii) No Smuggling: The computation succeeds without any opaque     *)
(*         constants (like Reflexica certificates) blocking reduction.   *)
(*                                                                       *)
(*   Methodology note (BHK_R discipline):                                *)
(*   All correctness statements here are witnessed by computation        *)
(*   (vm_compute), not by propositional reasoning or axioms.             *)
(*                                                                       *)
(*  Summary.                                                             *)
(*                                                                       *)
(*     (i) KERNEL (C002)                                                 *)
(*         (a) recognition (EFQ, K, S)                                   *)
(*         (b) checking (Modus Ponens)                                   *)
(*                                                                       *)
(*    (ii) CODING (C002)                                                 *)
(*         (a) Carryless codec round-trip on small examples              *)
(*                                                                       *)
(*   (iii) DIAGONAL (C003)                                               *)
(*         (a) Compilation of templates                                  *)
(*         (b) Execution of the Diagonalizer                             *)
(*         (c) Verification of the “Diagonal Law”                        *)
(*                                                                       *)
(*************************************************************************)

Module Test_Kernel_Small.

  Module HK := ATP.C002.P2_R__Hilbert_Kernel.C_002_HilbertKernel_R.

  (*
    Shorthands
  *)

  Definition Bot : HK.Form := HK.Bot.
  Definition Imp : HK.Form -> HK.Form -> HK.Form := HK.Imp.

  Definition lnil : HK.Proof := nil.
  Definition lcons (x : HK.Form) (xs : HK.Proof) : HK.Proof := cons x xs.
  Definition l1 (x : HK.Form) : HK.Proof := lcons x lnil.
  Definition l3 (a b c : HK.Form) : HK.Proof := lcons a (lcons b (lcons c lnil)).

  (*
    Concrete formulas, no atoms in the object language.
  *)

  Definition A0 : HK.Form := Imp Bot Bot.
  Definition B0 : HK.Form := Imp Bot (Imp Bot Bot).

  (*
    Basic sanity: check rejects empty scripts.
  *)

  Example test_check_empty_rejects :
    HK.check lnil A0 = false.
  Proof. vm_compute. reflexivity. Qed.

  (*
    recognition + single-line checking.
  *)

  Example test_is_axiom_efq :
    HK.is_axiom (Imp Bot Bot) = true.
  Proof. vm_compute. reflexivity. Qed.

  Example test_check_single_axiom :
    HK.check (l1 A0) A0 = true.
  Proof. vm_compute. reflexivity. Qed.

  (*************************************************************************)
  (*                                                                       *)
  (*  MP script: from A0 and (A0 -> (B0 -> A0)) derive (B0 -> A0).         *)
  (*                                                                       *)
  (*  line1: A0                 (EFQ instance)                             *)
  (*  line2: A0 -> (B0 -> A0)   (K instance)                               *)
  (*  line3: B0 -> A0           (MP from line1,line2)                      *)
  (*                                                                       *)
  (*************************************************************************)

  Definition line1 : HK.Form := A0.
  Definition line2 : HK.Form := Imp A0 (Imp B0 A0).
  Definition line3 : HK.Form := Imp B0 A0.

  Example test_check_mp_script :
    HK.check (l3 line1 line2 line3) line3 = true.
  Proof. vm_compute. reflexivity. Qed.

End Test_Kernel_Small.

Module Test_Coding_Small.

  Module CN := ATP.C002.P4_R__Coding_Nucleus.C_002_Coding_Nucleus_R.
  Module Coding := ATP.C002.P5_T__Proof_Theory.Coding.

  Module CP := Carryless_Pairing.C001.P5_T__Carryless_Pairing.
  Module N := CP.Prelude.

  Fixpoint of_nat (n : Coq.Init.Datatypes.nat) : N.nat :=
    match n with
    | Coq.Init.Datatypes.O => N.O
    | Coq.Init.Datatypes.S k => N.S (of_nat k)
    end.

  (* Local list constructors for C_002's list type. *)

  Definition lnil : Prelude.list N.nat := Prelude.nil.
  Definition lcons (a : Coq.Init.Datatypes.nat) (xs : Prelude.list N.nat) : Prelude.list N.nat :=
    Prelude.cons (of_nat a) xs.
  Definition l1 (a : Coq.Init.Datatypes.nat) : Prelude.list N.nat := lcons a lnil.
  Definition l2 (a b : Coq.Init.Datatypes.nat) : Prelude.list N.nat := lcons a (l1 b).

  (*
    Canonical codec: computational spot-check with explicit fuel.
  *)

  Module Carry := ATP.C002.P4_R__Coding_Carryless.C_002_Coding_R.

  Example test_carryless_enc_nil :
    Carry.enc_seq lnil = N.O.
  Proof. vm_compute. reflexivity. Qed.

  Example test_carryless_roundtrip_nil :
    Carry.dec_seq_fuel (of_nat 1) (Carry.enc_seq lnil) = Prelude.Some lnil.
  Proof. vm_compute. reflexivity. Qed.

  Example test_carryless_roundtrip_1_1 :
    Carry.dec_seq_fuel (of_nat 10) (Carry.enc_seq (l2 1 1)) = Prelude.Some (l2 1 1).
  Proof. vm_compute. reflexivity. Qed.

  Example test_carryless_roundtrip_1_2 :
    Carry.dec_seq_fuel (of_nat 10) (Carry.enc_seq (l2 1 2)) = Prelude.Some (l2 1 2).
  Proof. vm_compute. reflexivity. Qed.

(******************************************)
(******************************************)
(******************************************)
(******************************************)
(******************************************)
(******************************************)
(******      ****          *          *****)
(****   ░░░░   *░░   ░░░░░ ░░   ░░░░   ****)
(***   ****░░   *░   ** *░**░   ***░░   ***)
(**░   *****░   *░      ****░   ****░   ***)
(**░   ***  ░   *░   ░░ ****░   ****░   ***)
(**░░   *░░    **░   *░*** *░   ****   ****)
(***░░░      ░  *          *          *****)
(*****░░░░░░*░░*░░░░░░░░░░*░░░░░░░░░░******)
(******************************************)
(******************************************)
(******************************************)
(******************************************)
(******************************************)
(******************************************)

End Test_Coding_Small.




(* ---- theories/M002__Carryless_Proof_Theory/C003__Carryless_Diagonal_Lemma/P1_S__Syntax.v ---- *)

(* P1_S__Syntax.v *)

From Coq Require Import Init.Logic.

Set Implicit Arguments.
Unset Strict Implicit.

(*************************************************************************)
(*                                                                       *)
(*  C003 / Phase P1: Carryless Diagonal Operator (axiom-free skeleton)   *)
(*                                                                       *)
(*                                                                       *)
(*  This file is designed to be instantiated using C001’s effective      *)
(*  carryless pairing device (no Reflexica certificate required).        *)
(*                                                                       *)
(*  Discipline:                                                          *)
(*                                                                       *)
(*    (i)   Total definitions only (Fixpoint / Definition).              *)
(*    (ii)  No decoding theorems.                                        *)
(*    (iii) Quotation is syntactically inert under substitution:         *)
(*           subst₀(⌜e⌝, w) = ⌜e⌝.                                       *)
(*    (iv)  Correctness exported is code-level (an equality in ℕ).       *)
(*                                                                       *)
(*************************************************************************)

Module C003_P1.

  (*
    Minimal backend signature. C003 depends only on a nat type
    and an effective pair/unpair device over ℕ.

    No inversion law is assumed here (no Reflexica import).
  *)

  Module Type BACKEND.
    Parameter nat : Type.

    Parameter pair   : nat -> nat -> nat.
    Parameter unpair : nat -> nat * nat.

    (*
      Syntax tags (small constant naturals):

        Logic:  ⊥, →, □, ⌜ ⌝
        Arith:  var, const, pair, unpairₗ, unpairᵣ
    *)
    
    Parameter tag_bot tag_imp tag_hole tag_quote : nat.
    Parameter tag_var tag_const tag_pair tag_unpairL tag_unpairR : nat.
  End BACKEND.

  Module Make (B : BACKEND).

    Definition tag_bot : B.nat := B.tag_bot.
    Definition tag_imp : B.nat := B.tag_imp.
    Definition tag_hole : B.nat := B.tag_hole.
    Definition tag_quote : B.nat := B.tag_quote.

    Definition tag_var : B.nat := B.tag_var.
    Definition tag_const : B.nat := B.tag_const.
    Definition tag_pair : B.nat := B.tag_pair.
    Definition tag_unpairL : B.nat := B.tag_unpairL.
    Definition tag_unpairR : B.nat := B.tag_unpairR.

    (*
      Code Expressions (CExp) — Arithmetic DSL over ℕ

      A tiny total language describing how an input w ∈ ℕ is unpacked
      into components and recombined via pairing primitives.

      Operational Semantics:

        ⟦Var⟧(w)          ≜  w
        ⟦Const n⟧(w)      ≜  n
        ⟦Pair e₁ e₂⟧(w)   ≜  pair(⟦e₁⟧(w), ⟦e₂⟧(w))
        ⟦UnpairL e⟧(w)    ≜  π₁(unpair(⟦e⟧(w)))
        ⟦UnpairR e⟧(w)    ≜  π₂(unpair(⟦e⟧(w)))

      Note: This is purely operational. No decoding theorem about
      pair/unpair inversion is assumed here.
    *)

    Inductive CExp : Type :=
      | Var     : CExp
      | Const   : B.nat -> CExp
      | Pair    : CExp -> CExp -> CExp
      | UnpairL : CExp -> CExp
      | UnpairR : CExp -> CExp.

    Fixpoint eval (e : CExp) (w : B.nat) : B.nat :=
      match e with
      | Var => w
      | Const n => n
      | Pair e1 e2 => B.pair (eval e1 w) (eval e2 w)
      | UnpairL e' => fst (B.unpair (eval e' w))
      | UnpairR e' => snd (B.unpair (eval e' w))
      end.

    (*
      Template Language — Single-Hole Formulas with Inert Quotation

      Constructors:

        Bot          —  ⊥  (falsity)
        Imp a b      —  a → b  (implication)
        Hole         —  □  (unique substitution site)
        Quote0 e     —  ⌜e⌝  (inert quotation of code expression)

      Key Invariant:

        Substitution does NOT recurse under Quote0.
        Quotation is syntactically inert: subst(⌜e⌝, w) = ⌜e⌝.
    *)

    Inductive Template : Type :=
      | Bot   : Template
      | Imp   : Template -> Template -> Template
      | Hole  : Template
      | Quote0 : CExp -> Template.

    (*
      Packed Substitution (Quote0-Inert)

      The input w is treated operationally as a packed pair w ≡ ⟨v,s⟩.

      The hole □ is filled by quoting the left component v as literal data:

        subst₀(□, w)  ≜  ⌜const v⌝,  where v = π₁(unpair(w)).

      This computes v from w, then injects it as data (not as expression).

      Properties:

        (i)  Total and axiom-free (structural recursion only).
        (ii) Quote0-inert: subst₀(⌜e⌝, w) = ⌜e⌝ (quotation blocks descent).
    *)

    Fixpoint subst0 (t : Template) (w : B.nat) : Template :=
      match t with
      | Bot => Bot
      | Imp a b => Imp (subst0 a w) (subst0 b w)
      | Hole =>
          let v := fst (B.unpair w) in
          Quote0 (Const v)
      | Quote0 e => Quote0 e
      end.

    Theorem subst0_quote_inert : forall e w, subst0 (Quote0 e) w = Quote0 e.
    Proof. intros; exact (eq_refl _). Qed.

    (*
      Gödel Encoding — Structural and Total

      We give a minimal encoder into ℕ using only pairing as constructor.

      Tags are kept abstract as small constants. For concrete backend (C001),
      these can be instantiated as small numerals.

      Encoding Functions:

        encE : CExp → ℕ       (code expressions)
        encU : Template → ℕ   (formulas/templates)

      Both are total, structural, and axiom-free.
    *)

    Fixpoint encE (e : CExp) : B.nat :=
      match e with
      | Var => B.pair tag_var tag_bot
      | Const n => B.pair tag_const n
      | Pair e1 e2 => B.pair tag_pair (B.pair (encE e1) (encE e2))
      | UnpairL e' => B.pair tag_unpairL (encE e')
      | UnpairR e' => B.pair tag_unpairR (encE e')
      end.

    Fixpoint encU (t : Template) : B.nat :=
      match t with
      | Bot => B.pair tag_bot tag_bot
      | Imp a b => B.pair tag_imp (B.pair (encU a) (encU b))
      | Hole => B.pair tag_hole tag_bot
      | Quote0 e => B.pair tag_quote (encE e)
      end.

    (*
      Delta Compilation Interface

      The diagonal operator δ is expressed via compilation:

        compile_δ(t) = (δₜ, Eₜ)

      where δₜ is a template and Eₜ is a code expression, satisfying:

        Compilation Invariant:

          ∀w. encU(subst₀(δₜ, w)) = ⟦Eₜ⟧(w)

      This invariant is proved by computational unfolding once δₜ and Eₜ
      are explicitly constructed (in Phase P2 — Realization).

      Phase P1 pins only the *interface shape* (axiom-free skeleton).
    *)

    Record COMPILED (t : Template) : Type := {
      delta_t : Template;
      E_t     : CExp;
      compile_inv :
        forall w : B.nat,
          encU (subst0 delta_t w) = eval E_t w
    }.

    (*
      Diagonal Operator — Knot-Tying Without Decoding

      The self-packed argument (Quinean knot):

        selfpack(n) ≜ ⟨n, n⟩

      The diagonal is defined by substitution into δₜ using the self-pack:

        diag(t) ≜ subst₀(δₜ, selfpack(⌈δₜ⌉))

      Exported Code-Level Specification:

        ⌈diag(t)⌉ = ⟦Eₜ⟧(selfpack(⌈δₜ⌉))

      This follows immediately from the compilation invariant.
      No decoding theorem is required.
    *)

    Definition selfpack (n : B.nat) : B.nat := B.pair n n.

    Definition diag (t : Template) (c : COMPILED t) : Template :=
      subst0 (delta_t c) (selfpack (encU (delta_t c))).

    Theorem diag_spec_code :
      forall (t : Template) (c : COMPILED t),
        encU (diag (t := t) c)
        =
        eval (E_t c) (selfpack (encU (delta_t c))).
    Proof.
      intros t c.
      unfold diag.
      exact (compile_inv c (selfpack (encU (delta_t c)))).
    Qed.

  End Make.

End C003_P1.


(* ---- theories/M002__Carryless_Proof_Theory/C003__Carryless_Diagonal_Lemma/P2_R__Backend.v ---- *)

(* P2_R__Backend.v *)

From Coq Require Import Init.Logic.
From Diagonallemma.C003 Require Import P1_S__Syntax.
From Carryless_Pairing.C001 Require Import P5_T__Carryless_Pairing.

Set Implicit Arguments.
Unset Strict Implicit.

(*************************************************************************)
(*                                                                       *)
(*  C003 / Phase 2 (R): Carryless backend instantiation.                 *)
(*                                                                       *)
(*  Provides an effective nat + pair/unpair device sourced from C001.    *)
(*  No Reflexica certificate is assumed.                                 *)
(*                                                                       *)
(*************************************************************************)

Module C003_Backend_Carryless <: C003_P1.BACKEND.
  Module N := Prelude.
  Module P := Pairing.

  Definition nat : Type := N.nat.
  Definition O : nat := N.O.
  Definition S : nat -> nat := N.S.

  Definition pair (x y : nat) : nat :=
    P.pair CarrylessPair x y.

  Definition unpair (z : nat) : nat * nat :=
    let p := P.unpair CarrylessPair z in (P.fst p, P.snd p).

  (*
    Tag Assignment (Small Numerals)

    Tags are assigned as small natural numbers using successor notation.
    N.O is zero, N.S is the successor function.

      ⊥ ↦ 0,  → ↦ 1,  □ ↦ 2,  ⌜⌝ ↦ 3
      var ↦ 4,  const ↦ 5,  pair ↦ 6,  unpairₗ ↦ 7,  unpairᵣ ↦ 8
  *)

  Definition tag_bot : nat := N.O.
  Definition tag_imp : nat := N.S N.O.
  Definition tag_hole : nat := N.S (N.S N.O).
  Definition tag_quote : nat := N.S (N.S (N.S N.O)).

  Definition tag_var : nat := N.S (N.S (N.S (N.S N.O))).
  Definition tag_const : nat := N.S (N.S (N.S (N.S (N.S N.O)))).
  Definition tag_pair : nat := N.S (N.S (N.S (N.S (N.S (N.S N.O))))).
  Definition tag_unpairL : nat := N.S (N.S (N.S (N.S (N.S (N.S (N.S N.O)))))).
  Definition tag_unpairR : nat := N.S (N.S (N.S (N.S (N.S (N.S (N.S (N.S N.O))))))).
End C003_Backend_Carryless.


(* ---- theories/M002__Carryless_Proof_Theory/C003__Carryless_Diagonal_Lemma/P2_R__Compiler.v ---- *)

(* P2_R__Compiler.v *)

From Coq Require Import Init.Logic.
From Diagonallemma.C003 Require Import P1_S__Syntax.
From Diagonallemma.C003 Require Import P2_R__Backend.

Set Implicit Arguments.
Unset Strict Implicit.

(*************************************************************************)
(*                                                                       *)
(*  C003 / Phase 2 (R): Compiler artifact (total, certificate-free).     *)
(*                                                                       *)
(*  This phase provides a concrete, total compile_delta that produces    *)
(*  a COMPILED witness for any template via a structural compiler.       *)
(*                                                                       *)
(*  The compiled expression computes the code of subst0 t w. The only    *)
(*  w-dependence is in the Hole case, via UnpairL Var.                   *)
(*                                                                       *)
(*************************************************************************)

Module C003_Compiler_R.

  Module Make (B : C003_P1.BACKEND).

    Module D := C003_P1.Make(B).

    (*
      Structural compiler: computes encU (subst0 t w).
    *)

    Fixpoint compU (t : D.Template) : D.CExp :=
      match t with
      | D.Bot => D.Const (D.encU D.Bot)
      | D.Imp a b =>
          D.Pair
            (D.Const D.tag_imp)
            (D.Pair (compU a) (compU b))
      | D.Hole =>
          D.Pair
            (D.Const D.tag_quote)
            (D.Pair (D.Const D.tag_const) (D.UnpairL D.Var))
      | D.Quote0 e => D.Const (D.encU (D.Quote0 e))
      end.

    (*
      Compile artifact: delta_t := t, E_t := compU t.
    *)

    Definition compile_delta (t : D.Template) : D.COMPILED t :=
      {| D.delta_t := t
       ; D.E_t := compU t
       ; D.compile_inv :=
           let fix compile_inv (u : D.Template) :
               forall w : B.nat,
                 D.encU (D.subst0 u w) = D.eval (compU u) w :=
               match u with
               | D.Bot =>
                   fun w => eq_refl _
               | D.Imp u1 u2 =>
                   fun w =>
                     let IH1 := compile_inv u1 w in
                     let IH2 := compile_inv u2 w in
                     f_equal2
                       (fun x y => B.pair D.tag_imp (B.pair x y))
                       IH1 IH2
               | D.Hole =>

                    (*
                      Hole: both sides reduce to pair tag_quote (pair tag_const (fst (unpair w))).
                    *)
                    
                   fun w => eq_refl _
               | D.Quote0 e =>
                   fun w => eq_refl _
               end
           in
           compile_inv t
      |}.

  End Make.

  Module Default := Make(C003_Backend_Carryless).
  Module D := Default.D.
  Definition compile_delta := Default.compile_delta.

End C003_Compiler_R.


(* ---- theories/M002__Carryless_Proof_Theory/C003__Carryless_Diagonal_Lemma/P2_T__Diagonal.v ---- *)

(* P2_T__Diagonal.v *)

From Coq Require Import Init.Logic.
From Diagonallemma.C003 Require Export P1_S__Syntax.
From Diagonallemma.C003 Require Import P2_R__Backend.
From Diagonallemma.C003 Require Import P2_R__Compiler.

(*************************************************************************)
(*                                                                       *)
(*  C003 / Phase 5 (T): Public surface for the diagonal operator.        *)
(*                                                                       *)
(*  Guard: do not import any A/TA module here.                           *)
(*                                                                       *)
(*************************************************************************)

Set Implicit Arguments.
Unset Strict Implicit.

(*
  Parametric Functor Construction

  We use C003_P1.BACKEND directly to ensure we get the Module Type,
  avoiding any ambiguity if BACKEND is defined elsewhere.
*)

Module Diagonal_Functor (B : C003_P1.BACKEND).

  (*
    Instantiate the compiler with the provided abstract backend B.
  *)

  Module Compiler := C003_Compiler_R.Make(B).
  Module D := Compiler.D.

  (*
    Stable re-exports: syntax, encoding, compilation interface, diag.
  *)

  Definition CExp : Type := D.CExp.
  Definition Template : Type := D.Template.

  (*
    Use B.nat (abstract) instead of a concrete nat
  *)

  Definition eval : CExp -> B.nat -> B.nat := D.eval.

  Definition subst0 : Template -> B.nat -> Template := D.subst0.

  Definition encE : CExp -> B.nat := D.encE.
  Definition encU : Template -> B.nat := D.encU.

  Definition COMPILED (t : Template) : Type := D.COMPILED t.

  (*
    Public wrappers for internal projections.
  *)

  Definition delta_t {t : Template} (c : COMPILED t) : Template := D.delta_t c.
  Definition E_t     {t : Template} (c : COMPILED t) : CExp     := D.E_t c.
  Definition selfpack (n : B.nat) : B.nat := D.selfpack n.

  Definition compile_delta (t : Template) : COMPILED t :=
    Compiler.compile_delta t.

  Definition diag (t : Template) (c : COMPILED t) : Template :=
    D.diag (t := t) c.

  (*
    The Main Diagonal Specification (Code-Level)

    For any template t with compilation c = compile_δ(t):

      ⌈diag(t)⌉ = ⟦Eₜ⟧(selfpack(⌈δₜ⌉))

    This is the Quinean knot: the encoding of the diagonal equals
    the evaluation of Eₜ on the self-packed code of δₜ.
  *)

  Theorem diag_spec_code :
    forall (t : Template) (c : COMPILED t),
      encU (diag (t := t) c)
      =
      eval (E_t c) (selfpack (encU (delta_t c))).
  Proof.
    intros t c.
    unfold E_t, selfpack, delta_t.
    exact (@D.diag_spec_code t c).
  Qed.

End Diagonal_Functor.

(*
  Default Instantiation — Carryless Backend

  This instantiates the Diagonal_Functor with C003_Backend_Carryless,
  preserving the original public API while keeping the functor available
  for parametric uses.
*)

Module Diagonal := Diagonal_Functor(C003_Backend_Carryless).

(*
  Stable re-exports: syntax, encoding, compilation interface, diag.
*)

Definition CExp : Type := Diagonal.CExp.
Definition Template : Type := Diagonal.Template.

Definition eval :
  CExp -> C003_Backend_Carryless.nat -> C003_Backend_Carryless.nat :=
  Diagonal.eval.

Definition subst0 :
  Template -> C003_Backend_Carryless.nat -> Template :=
  Diagonal.subst0.

Definition encE : CExp -> C003_Backend_Carryless.nat := Diagonal.encE.
Definition encU : Template -> C003_Backend_Carryless.nat := Diagonal.encU.

Definition COMPILED (t : Template) : Type := Diagonal.COMPILED t.

Definition compile_delta (t : Template) : COMPILED t :=
  Diagonal.compile_delta t.

Definition diag (t : Template) (c : COMPILED t) : Template :=
  Diagonal.diag (t := t) c.

(*
  Public Re-export of the Diagonal Specification
*)

Theorem diag_spec_code :
  forall (t : Template) (c : COMPILED t),
    encU (diag (t := t) c)
    =
    eval (Diagonal.E_t c) (Diagonal.selfpack (encU (Diagonal.delta_t c))).
Proof.
  exact Diagonal.diag_spec_code.
Qed.

(*
  “Where Did the Incompleteness Go?” (Part One)

  The diagonal construction is total and axiom-free.
  So where did Gödel's incompleteness hide?

  Answer: It retreated to the only place left to hide —
  the inversion law for Carryless Pairing.

  The pairing inversion is:

    (i)   Computationally trivial (effective, total, primitive recursive).
    (ii)  NOT provable in this minimal arithmetic core.

  Crucially, we do NOT need to introduce the inversion lemma (Reflexica)
  for the diagonal computation to work.

  The incompleteness is isolated in the gap between:

    R-layer (realization):  pair/unpair compute correctly
    A-layer (certificate):  inversion law is unprovable here

  This stratification leads us to the "Mirror Lemma" (C004).
*)

(*************************************************************************)
(*                                                                       *)
(*  Conjecture.                                                          *)
(*                                                                       *)
(*  No method of pairing can reduce its inversion law from Π₂ uniformity *)
(*  to a Σ₀ formula (bounded quantifiers only).                          *)
(*                                                                       *)
(*  The carryless pairing pushes incompleteness to the boundary between  *)
(*  effective computation and provability.                               *)
(*                                                                       *)
(*************************************************************************)

(* ---- theories/M002__Carryless_Proof_Theory/C003__Carryless_Diagonal_Lemma/P3_T__Flip_Instance.v ---- *)

(* P3_T__Flip_Instance.v *)

(*************************************************************************)
(*                                                                       *)
(*  C003 / Phase 3 (T): Canonical Flip Template Instance                 *)
(*                                                                       *)
(*  Purpose                                                              *)
(*                                                                       *)
(*    Provides a concrete, canonical instantiation of a flip template    *)
(*    for use in diagonal barrier proofs (C006, C007).                   *)
(*                                                                       *)
(*  What This File Provides                                              *)
(*                                                                       *)
(*    (i)   Canonical_Flip_Template : Template                           *)
(*          A simple, total template suitable for diagonalization.       *)
(*                                                                       *)
(*    (ii)  Canonical_Flip_Compiled : COMPILED Canonical_Flip_Template   *)
(*          Compile evidence via the structural compiler.                *)
(*                                                                       *)
(*   (iii)  Diagonal witness construction utilities.                     *)
(*                                                                       *)
(*  Design Notes                                                         *)
(*                                                                       *)
(*    The canonical flip template is simply Hole (□).                    *)
(*    This is the minimal template that supports self-reference:         *)
(*                                                                       *)
(*      Hole is the substitution placeholder, and when diagonalized,     *)
(*      it produces the Quinean knot - a formula that refers to          *)
(*      its own Gödel number.                                            *)
(*                                                                       *)
(*    The flip behavior emerges not from the template itself, but        *)
(*    from the Form_of_Template translation function, which must be      *)
(*    defined appropriately by the consumer (C006/C007).                 *)
(*                                                                       *)
(*************************************************************************)

From Coq Require Import Init.Logic.
From Diagonallemma.C003 Require Export P2_T__Diagonal.
From Diagonallemma.C003 Require Import P2_R__Backend.

Set Implicit Arguments.
Unset Strict Implicit.

Module C003_Flip_Instance.

  Module Diag := Diagonallemma.C003.P2_T__Diagonal.
  Module Backend := C003_Backend_Carryless.

  (*************************************************************************)
  (*                                                                       *)
  (*  Canonical Flip Template — The Hole Template                          *)
  (*                                                                       *)
  (*  Definition:                                                          *)
  (*                                                                       *)
  (*    T_flip := □  (Hole)                                                *)
  (*                                                                       *)
  (*  Properties:                                                          *)
  (*                                                                       *)
  (*    (i)   Minimal: Hole is the simplest template that supports         *)
  (*          substitution and self-reference.                             *)
  (*                                                                       *)
  (*    (ii)  Universal: Any diagonal construction requires at least       *)
  (*          one substitution site (Hole).                                *)
  (*                                                                       *)
  (*   (iii)  Total: Compilation and diagonalization are purely            *)
  (*          structural operations.                                       *)
  (*                                                                       *)
  (*  The Quinean Knot:                                                    *)
  (*                                                                       *)
  (*    diag(Hole) = subst₀(Hole, selfpack(⌈Hole⌉))                        *)
  (*                = Quote0(Const(⌈Hole⌉))                                *)
  (*                                                                       *)
  (*    This is a formula that quotes its own Gödel number.                *)
  (*                                                                       *)
  (*************************************************************************)

  Definition Canonical_Flip_Template : Diag.Template :=
    Diag.Diagonal.D.Hole.

  (*
    Compile the canonical flip template.

    The compiler produces:
      - delta_t := Hole
      - E_t := compU(Hole) = Pair tag_quote (Pair tag_const (UnpairL Var))
      - compile_inv : proof that encU(subst₀(Hole, w)) = eval(E_t, w)
  *)

  Definition Canonical_Flip_Compiled : Diag.COMPILED Canonical_Flip_Template :=
    Diag.compile_delta Canonical_Flip_Template.

  (*************************************************************************)
  (*                                                                       *)
  (*  Diagonal Witness Construction                                        *)
  (*                                                                       *)
  (*  From the canonical flip template, we can construct the diagonal      *)
  (*  witness used in barrier proofs.                                      *)
  (*                                                                       *)
  (*************************************************************************)

  (*
    The diagonalized template: D_t = diag(T_flip)
  *)

  Definition Canonical_Diagonal_Template : Diag.Template :=
    Diag.diag (t := Canonical_Flip_Template) Canonical_Flip_Compiled.

  (*
    The diagonal index: d = ⌈D_t⌉
  *)

  Definition Canonical_Diagonal_Index : Backend.nat :=
    Diag.encU Canonical_Diagonal_Template.

  (*************************************************************************)
  (*                                                                       *)
  (*  Verification: The Diagonal Specification                             *)
  (*                                                                       *)
  (*  The canonical flip satisfies the diagonal specification:             *)
  (*                                                                       *)
  (*    ⌈diag(T_flip)⌉ = ⟦E_flip⟧(selfpack(⌈Hole⌉))                        *)
  (*                                                                       *)
  (*  This follows immediately from the generic diagonal specification.    *)
  (*                                                                       *)
  (*************************************************************************)

  Theorem Canonical_Flip_Diagonal_Spec :
    Diag.encU Canonical_Diagonal_Template
    =
    Diag.eval
      (Diag.Diagonal.E_t Canonical_Flip_Compiled)
      (Diag.Diagonal.selfpack (Diag.encU Canonical_Flip_Template)).
  Proof.
    unfold Canonical_Diagonal_Template.
    exact (Diag.diag_spec_code Canonical_Flip_Compiled).
  Qed.

  (*************************************************************************)
  (*                                                                       *)
  (*  Usage Notes                                                          *)
  (*                                                                       *)
  (*  To use this canonical flip template in a barrier proof (C006/C007):  *)
  (*                                                                       *)
  (*    1. Import this module.                                             *)
  (*                                                                       *)
  (*    2. Use Canonical_Flip_Template as the flip template parameter.     *)
  (*                                                                       *)
  (*    3. Use Canonical_Flip_Compiled as the COMPILED evidence.           *)
  (*                                                                       *)
  (*    4. Define Form_of_Template : Template -> ATP_Form that             *)
  (*       translates the diagonal template to the target logic.           *)
  (*                                                                       *)
  (*    5. Prove Diag_As_Flip: D = Flip(sigma, d) using the specific      *)
  (*       Form_of_Template definition.                                    *)
  (*                                                                       *)
  (*  Example (C006 Audit Adapter):                                        *)
  (*                                                                       *)
  (*    Section Audit_Instance.                                            *)
  (*      (* Problem class and decider *)                                  *)
  (*      Variable A : nat -> Form.                                        *)
  (*      Variable sigma : nat -> bool.                                    *)
  (*                                                                       *)
  (*      (* Use canonical flip *)                                         *)
  (*      Let Flip_Template := Canonical_Flip_Template.                    *)
  (*      Let Compiled := Canonical_Flip_Compiled.                         *)
  (*                                                                       *)
  (*      (* Define translation (must encode flip logic) *)                *)
  (*      Definition Form_of_Template (t : Template) : Form := ...        *)
  (*                                                                       *)
  (*      (* Diagonal witness *)                                           *)
  (*      Let D_t := diag Flip_Template Compiled.                          *)
  (*      Let d := encU D_t.                                               *)
  (*      Let D := Form_of_Template D_t.                                   *)
  (*                                                                       *)
  (*      (* Prove flip property *)                                        *)
  (*      Lemma Instance_Diag_As_Flip :                                    *)
  (*        D = (if sigma d then NotF (A d) else A d).                     *)
  (*      Proof. (* Depends on Form_of_Template definition *) Qed.         *)
  (*    End Audit_Instance.                                                *)
  (*                                                                       *)
  (*************************************************************************)

End C003_Flip_Instance.

(*
  Public re-exports for convenient access.
*)

Export C003_Flip_Instance.


(* ---- theories/M002__Carryless_Proof_Theory/C004__Mirror_Lemma/P1_S__Context.v ---- *)

(* P1_S__Context.v *)

From Coq Require Import Init.Logic.
From ATP.C002 Require Import P5_T__Proof_Theory.

Set Implicit Arguments.
Unset Strict Implicit.

(*************************************************************************)
(*                                                                       *)
(*  C004 / Phase 1 (S): Mirror Context & Negation Definition             *)
(*                                                                       *)
(*  What This File Provides                                              *)
(*                                                                       *)
(*      (i) The local logical context for the "Mirror Lemma."            *)
(*          We re-export the Additive Theory of Provability (C002)       *)
(*          under a minimal, stable vocabulary.                          *)
(*                                                                       *)
(*     (ii) The canonical definition of object-language negation (¬).    *)
(*          Since the C002 object language is an implicational fragment  *)
(*          with ⊥, negation is derived, not primitive:                  *)
(*                                                                       *)
(*           ¬φ  ≜  φ → ⊥                                                *)
(*                                                                       *)
(*  Role in the Mirror Lemma                                             *)
(*                                                                       *)
(*      Meta-level non-refutability  ←→  Object-level "As-If" bounding   *)
(*                                                                       *)
(*    This requires a precise definition of "refutation" inside the      *)
(*    object logic. We fix:                                              *)
(*                                                                       *)
(*      Refute(φ) ≜ Prov(¬φ) ≜ Prov(φ → ⊥)                               *)
(*                                                                       *)
(*  The Recursive Mirror Lemma                                           *)
(*                                                                       *)
(*     (i)  Final frontier: The theorem itself becomes its own fixed     *)
(*          point (Quinean self-reference).                              *)
(*                                                                       *)
(*    (ii)  Yet it still obeys the laws of logic (consistency is         *)
(*          preserved through stratification).                           *)
(*                                                                       *)
(*  Design Discipline                                                    *)
(*                                                                       *)
(*     (i)  Alias Stability: Local names (Form, Prov, Imp) decouple      *)
(*          the Core (P2) and Recursive (P3) layers from the specific    *)
(*          import path of C002.                                         *)
(*                                                                       *)
(*    (ii)  Negation as Implication: Defining NotF explicitly prevents   *)
(*          ambiguity between intuitionistic negation and potential      *)
(*          classical extensions in downstream use.                      *)
(*                                                                       *)
(*************************************************************************)

Module C_004_Context.

  Module Prelude := ATP.C002.P5_T__Proof_Theory.Prelude.
  Module ATP     := ATP.C002.P5_T__Proof_Theory.ATP.

  Definition nat  : Type := Prelude.nat.
  Definition Form : Type := ATP.ATP_Form.

  Definition Imp  : Form -> Form -> Form := ATP.ATP_Imp.
  Definition Bot  : Form := ATP.ATP_Bot.
  Definition Prov : Form -> Prop := ATP.ATP_Prov.

  (*
    Object-Language Negation

    Since the object logic is an implicational fragment with ⊥,
    negation is derived:

      ¬φ  ≜  φ → ⊥

    This is the standard intuitionistic treatment of negation.
  *)

  Definition NotF (phi : Form) : Form := Imp phi Bot.

End C_004_Context.

Export C_004_Context.


(* ---- theories/M002__Carryless_Proof_Theory/C004__Mirror_Lemma/P2_R__Mirror_Core.v ---- *)

(* P2_R__Mirror_Core.v *)

(*************************************************************************)
(*                                                                       *)
(*  C004 / Phase 2 (R): The Mirror Lemma.                                *)
(*                                                                       *)
(*    Provides,                                                          *)
(*                                                                       *)
(*      (i) “Mirror Parameters” (REG, BND, ProvT_P).                     *)
(*          Abstract interface decoupling logic from C005 realization.   *)
(*                                                                       *)
(*     (ii) The “As-If” Predicate:                                       *)
(*                                                                       *)
(*          AsIF(φ) ≜ ∃i,b. REG(i,b) ∧ BND(φ,b) ∧                        *)
(*                          Prov(φ→b) ∧ ¬Prov(¬φ)                        *)
(*                                                                       *)
(*          Formal container for "true but unprovable."                  *)
(*                                                                       *)
(*    (iii) The Fixed-Witness Theorem:                                   *)
(*                                                                       *)
(*          Regulator + ¬Prov(¬φ) → AsIF(φ)                              *)
(*                                                                       *)
(*************************************************************************)

(*
  “Where Did the Incompleteness Go?” (Part Two)

  It became the "As-If" operator.
  This file formalizes the status of the “unprovable-but-true”
  (classically trivial) pairing inversion law through the Mirror Schema.

  The Three-Stage Argument             

     (i)  The inversion law is computationally effective (total),
          therefore impossible to refute.

    (ii)  The Mirror Schema dictates:
          Non-Refutability → "As-If" Existence.

  Therefore, we can interact with the pairing law as a bounded witness (As-If),
  awaiting upgrade by the Reflexica certificate (C001/P6_A).
*)

From Coq Require Import Init.Logic.
From ATP.C004__Mirror_Lemma Require Import P1_S__Context.

Set Implicit Arguments.
Unset Strict Implicit.

Module C_004_Mirror_Core_R.

  Import C_004_Context.

  (*************************************************************************)
  (*                                                                       *)
  (*  The Mirror Lemma bridges:                                            *)
  (*                                                                       *)
  (*    Meta-level epistemology:  ¬Prov(¬φ)  (non-refutability)            *)
  (*    Object-level evaluation:    AsIF(φ)     (bounded witness)          *)
  (*                                                                       *)
  (*************************************************************************)

  (*
    The Symbolic Regulator — Key Predicates

    (i) REG (Regulator):

        REG(i, b) ≜ "Index i is regulated to bound b"

        The regulator assigns an index i to a class bound b.
        It acts as the internal witness for the As-If condition.

        Interpretation: When a separator exists, it provides REG —
        the separator's decision at index i determines which bound
        (A(i) or B(i)) regulates that index.

    (ii) BND (Bound):

        BND(φ, b) ≜ "Formula φ is bounded by b"

        The syntactic implication bound in the object logic.
        Captures provable entailment: when φ is bounded by b,
        the system proves φ → b.

    (iii) AsIF (As-If Witness):

        AsIF(φ) ≜ "φ acts as-if provable under bound b"

        The "forced" state where φ behaves as-if true within bound b.
  *)

  (*************************************************************************)
  (*                                                                       *)
  (*  Philosophical Interlude: The Story Analogy                           *)
  (*                                                                       *)
  (*************************************************************************)

  (*
    Analogy. Characters inside the story could derive the Diagonal Lemma and
    conclude that their formal system is incomplete, a “book”.

    Yet they will treat the ground truth relative to the ambient story
    "as if" complete, because they do not have access to a richer theory.

    Whatever they do, it will always be relatively consistent to the book.

    Key Insight:

      Consistent agents confined to a delimited informational horizon
      construct internally coherent models that omit what lies beyond reach.

    The Mirror Lemma is epistemic, but also structural:

      - Derive the Diagonal Lemma at object level.
      - Treat the accessible fragment "as if" complete.
      - Acknowledge that its boundary is intrinsic, not eliminable.
  *)

  (*************************************************************************)
  (*                                                                       *)
  (*  The Mirror Schema — Formal Statement                                 *)
  (*                                                                       *)
  (*************************************************************************)

  (*
    For better intuition, our theory becomes a “regulator”.
    We Conclude:

      AsIF(φ) — φ is in a forced state.

    The lemma creates a mirror between two levels:

      (i)  Meta-level:    ¬Prov(¬φ)   (cannot prove φ false)
      (ii) Object-level:  AsIF(φ)     (φ behaves as-if true)

    If the proof system is incomplete (cannot prove or refute φ),
    and a regulator exists pairing indices to bounds, then the
    Mirror Lemma forces φ into an As-If state — a bounded witness
    where φ acts "as-if" provable.

    This is "weak forcing" because:

        (i) No axioms added (unlike Cohen forcing).
       (ii) No model extension (stays in current universe).
      (iii) Purely proof-theoretic (syntactic bounds, not semantic).
       (iv) Incompleteness guarantees witness existence.

    The regulator plays a crucial role: it provides the "regulation"
    that incompleteness exploits. When a separator tries to regulate
    the diagonal sentence, the Mirror Lemma forces it into an As-If
    state that clashes with the separator's certificate.
  *)

  Record MirrorParams : Type := {
    REG      : nat -> Form -> Prop;
    BND      : Form -> Form -> Prop;
    ProvT_P  : Form -> Prop
  }.

  (*
    As-If Predicate — The Forced State

    AsIF(φ) ≜ ∃i,b. BND(φ,b) ∧ REG(i,b) ∧ Prov(φ→b) ∧ ¬Prov(¬φ)

    This is the formal witness for "true but unprovable" statements.
  *)

  Definition AsIF (MP : MirrorParams) (phi : Form) : Prop :=
    exists i : nat,
    exists b : Form,
      MP.(BND) phi b /\
      MP.(REG) i b /\
      Prov (Imp phi b) /\
      ~ MP.(ProvT_P) (NotF phi).

  (*
    Simplified As-If — Non-Refutability Only

    AsIF_simple(φ) ≜ ¬Prov(¬φ)

    Used when regulator context is implicit.
  *)

  Definition AsIF_simple (MP : MirrorParams) (phi : Form) : Prop :=
    ~ MP.(ProvT_P) (NotF phi).

  (*
    Mirror Schema — The Bridge

    Mir(φ) ≜ ¬Prov(¬φ) → AsIF(φ)

    "Non-refutability implies As-If existence."
  *)

  Definition Mir (MP : MirrorParams) (phi : Form) : Prop :=
    ~ MP.(ProvT_P) (NotF phi) -> AsIF MP phi.

  (*************************************************************************)
  (*                                                                       *)
  (*  The Mirror Lemma — Fixed-Witness Form                                *)
  (*                                                                       *)
  (*  Given a fixed regulator (i₀, b₀) and universal bounding:            *)
  (*                                                                       *)
  (*    ∀φ. ¬Prov(¬φ) → AsIF(φ)                                           *)
  (*                                                                       *)
  (*  This is the core bridge theorem.                                     *)
  (*                                                                       *)
  (*************************************************************************)

  Section FixedWitness.
    Context (MP : MirrorParams).

    Variable i0 : nat.
    Variable b0 : Form.

    (*
      Context Hypotheses:

        REG0: i₀ is regulated to b₀
        BND0: All formulas are bounded by b₀
        PRV0: All formulas provably imply b₀
    *)

    Hypothesis REG0 : MP.(REG) i0 b0.
    Hypothesis BND0 : forall phi : Form, MP.(BND) phi b0.
    Hypothesis PRV0 : forall phi : Form, Prov (Imp phi b0).

    (*
      Main Theorem: Non-Refutability → As-If

      For any φ: if φ is non-refutable, then AsIF(φ).
    *)

    Theorem Mirror_fixed_witness :
      forall phi : Form,
        ~ MP.(ProvT_P) (NotF phi) -> AsIF MP phi.
    Proof.
      intros phi Hnr.
      exists i0. exists b0.
      repeat split.
      - apply BND0.
      - exact REG0.
      - apply PRV0.
      - exact Hnr.
    Qed.

    (*
      Mirror Schema Instance

      Under the fixed-witness context, Mir(φ) holds for all φ.
    *)

    Theorem Mir_schema_fixed_witness :
      forall phi : Form, Mir MP phi.
    Proof.
      intro phi; unfold Mir.
      intro Hnr; apply Mirror_fixed_witness; exact Hnr.
    Qed.

  End FixedWitness.

  (*************************************************************************)
  (*                                                                       *)
  (*  Diagonal Interface — Representable Transformers                      *)
  (*                                                                       *)
  (*  This interface abstracts the diagonal construction for use with      *)
  (*  the Mirror Lemma in the recursive extension (P3).                    *)
  (*                                                                       *)
  (*************************************************************************)

  (*
    Transformer — Representable Formula Mapping

    A transformer G is a function trF : Form → Form with a
    representability witness trRep.
  *)

  Record Transformer : Type := {
    trF   : Form -> Form;
    trRep : Prop
  }.

  Definition applyT (G : Transformer) : Form -> Form := trF G.

  (*
    Diagonal Device — Fixed-Point Constructor

    A diagonal device constructs fixed points for transformers:

      Given G, construct θ such that:

        Prov(θ → G(θ))  ∧  Prov(G(θ) → θ)

    Equivalently:

        Prov(θ ↔ G(θ))

    This is the Diagonal Lemma abstracted as a constructive device.
  *)

  Record DiagDevice : Type := {
    diag : Transformer -> Form;
    diag_fwd :
      forall (G : Transformer),
        Prov (Imp (diag G) (applyT G (diag G)));
    diag_bwd :
      forall (G : Transformer),
        Prov (Imp (applyT G (diag G)) (diag G))
  }.

End C_004_Mirror_Core_R.

Export C_004_Mirror_Core_R.


(* ---- theories/M002__Carryless_Proof_Theory/C004__Mirror_Lemma/P2_R__Mirror_Transport.v ---- *)

(* P2_R__Mirror_Transport.v *)

From Coq Require Import Init.Logic.
From ATP.C004__Mirror_Lemma Require Import P1_S__Context.
From ATP.C004__Mirror_Lemma Require Import P2_R__Mirror_Core.

Set Implicit Arguments.
Unset Strict Implicit.

(*************************************************************************)
(*                                                                       *)
(*  C_004 / Phase 2 (R): Mirror Transport (Recursive Extension)          *)
(*                                                                       *)
(*  What this file provides.                                             *)
(*                                                                       *)
(*    (i) The "Mirror Point" Functional (MirrorPointF).                  *)
(*        This function maps a formula phi to the implication:           *)
(*                                                                       *)
(*             MirF(phi) := (notF ProvT(notF phi)) -> phi                *)
(*                                                                       *)
(*        Intuitively: "If I am non-refutable, then I am true."          *)
(*                                                                       *)
(*   (ii) The Fixed Point (theta).                                       *)  
(*                                                                       *)                                     
(*        We use the Diagonal Device (from C003) to find the fixed       *)
(*        point of the Mirror Point functional.                          *)
(*                                                                       *)
(*             theta <-> ( ~Prov(~theta) -> theta )                      *)
(*                                                                       *)
(*  (iii) The Transport Lemma.                                           *)
(*        We prove that the diagonal logic holds inside the proof        *)
(*        system. This allows us to "transport" the Mirror property      *)
(*        recursive definition.                                          *)
(*                                                                       *)
(*************************************************************************)

Module C_004_Recursive_Mirror_R.

  Import C_004_Context.
  Module Core := ATP.C004__Mirror_Lemma.P2_R__Mirror_Core.C_004_Mirror_Core_R.
  Import Core.

  (*
    Abstract object-language provability former
  *)
  
  Record ProvFormer : Type := {
    ProvT_F : Form -> Form
  }.

  Section RecursiveMirrorPoint.

    Context (MP : MirrorParams).
    Context (PF : ProvFormer).
    Context (D  : DiagDevice).

    (*
      MirF(phi) := (notF ProvT_F(notF phi)) -> phi
    *)

    Definition MirrorPointF (phi : Form) : Form :=
      Imp (NotF (PF.(ProvT_F) (NotF phi))) phi.

    (*
      Evidence that MirF is representable (supplied downstream).
    *)
    
    Variable MirrorPointF_rep : Prop.

    Definition MirrorPointT : Transformer :=
      {| trF := MirrorPointF; trRep := MirrorPointF_rep |}.

    Definition theta : Form := D.(diag) MirrorPointT.

    Theorem Recursive_Mirror_Lemma :
      Prov (Imp theta (MirrorPointF theta)) /\ Prov (Imp (MirrorPointF theta) theta).
    Proof.
      split.
      - exact (D.(diag_fwd) MirrorPointT).
      - exact (D.(diag_bwd) MirrorPointT).
    Qed.

  End RecursiveMirrorPoint.

End C_004_Recursive_Mirror_R.

Export C_004_Recursive_Mirror_R.


(* ---- theories/M002__Carryless_Proof_Theory/C004__Mirror_Lemma/P2_S__Mirror_Lemma.v ---- *)

(* P2_S__Mirror_Lemma.v *)

From Coq Require Import Init.Logic.
From ATP.C004__Mirror_Lemma Require Import P1_S__Context.
From ATP.C004__Mirror_Lemma Require Import P2_R__Mirror_Core.

Set Implicit Arguments.
Unset Strict Implicit.

(*************************************************************************)
(*                                                                       *)
(*  C004 / Phase 2 (S): Mirror Lemma Façade                              *)
(*                                                                       *)
(*  What This File Provides                                              *)
(*                                                                       *)
(*    (i) Semantic Façade for the Mirror Core.                           *)
(*        Aggregates the Context (P1) and the Realization (P2_R)         *)
(*        into a single module structure.                                *)
(*                                                                       *)
(*    (i) Usage Policy.                                                  *)
(*        This layer hides the internal R-file organization.             *)
(*        Consumers of the fixed-witness theorem should import this      *)
(*        file (or the T-layer), not the P2_R realization directly.      *)
(*                                                                       *)
(*  The Mirror Lemma (Fixed-Witness Pattern)                             *)
(*                                                                       *)
(*    For any formula φ, there exists a fixed point ψ such that:         *)
(*                                                                       *)
(*      Prov(ψ ↔ φ(⌜ψ⌝))                                                 *)
(*                                                                       *)
(*    This is the semantic foundation for the Recursive Mirror Lemma.    *)
(*                                                                       *)
(*************************************************************************)

Module C_004_Mirror_S.
  Include C_004_Context.

  (*
    The Core Lemma — Fixed-Witness Pattern

    Imported from the realization layer (P2_R__Mirror_Core).
  *)

  Include C_004_Mirror_Core_R.
End C_004_Mirror_S.

Export C_004_Mirror_S.


(* ---- theories/M002__Carryless_Proof_Theory/C004__Mirror_Lemma/P3_S__Recursive_Mirror_Lemma.v ---- *)

(* P3_S__Recursive_Mirror_Lemma.v *)

(*************************************************************************)
(*                                                                       *)
(*  C004 / Phase 3 (S): Recursive Mirror Façade                          *)
(*                                                                       *)
(*  What This File Provides                                              *)
(*                                                                       *)
(*     (i)  Semantic Façade for the Recursive Extension.                 *)
(*          Exposes the machinery required to apply the Mirror Lemma     *)
(*          to self-referential sentences (via the Diagonal Device).     *)
(*                                                                       *)
(*    (ii)  Why is this separate?                                        *)
(*                                                                       *)
(*          Core (P2):       Static formulas φ                           *)
(*          Recursive (P3):  Dynamic fixed points ψ ≜ diag(φ)            *)
(*                                                                       *)
(*          This separation ensures that the core "As-If" logic is not   *)
(*          entangled with the complexity of diagonal construction.      *)
(*                                                                       *)
(*  The Recursive Mirror Schema                                          *)
(*                                                                       *)
(*    Combines the Mirror Lemma with the Diagonal Device:                *)
(*                                                                       *)
(*      Given template φ(□), construct ψ ≜ diag(φ) such that:            *)
(*                                                                       *)
(*        Prov(ψ ↔ φ(⌜ψ⌝))                                               *)
(*                                                                       *)
(*    This is the semantic foundation for Gödel's First Incompleteness   *)
(*    Theorem and Löb's Theorem.                                         *)
(*                                                                       *)
(*************************************************************************)

From Coq Require Import Init.Logic.
From ATP.C004__Mirror_Lemma Require Import P1_S__Context.
From ATP.C004__Mirror_Lemma Require Import P2_R__Mirror_Transport.

Set Implicit Arguments.
Unset Strict Implicit.

Module C_004_Recursive_Mirror_S.
  Include C_004_Context.

  (*
    The Recursive Extension,
    Mirror + Diagonal
    Imported from the realization layer (P2_R__Mirror_Transport).
  *)

  Include C_004_Recursive_Mirror_R.
End C_004_Recursive_Mirror_S.

Export C_004_Recursive_Mirror_S.


(* ---- theories/M002__Carryless_Proof_Theory/C004__Mirror_Lemma/P3_T__Weakforcing.v ---- *)

(* P3_T__Weakforcing.v *)

(*************************************************************************)
(*                                                                       *)
(*  C004 / Phase 3 (T): Weak Forcing (Public Surface)                    *)
(*                                                                       *)
(*  What is "Weak Forcing"?                                              *)
(*                                                                       *)
(*    Standard Cohen Forcing:                                            *)
(*      Extends the universe to make a statement true.                   *)
(*      (Adds new sets, changes the model.)                              *)
(*                                                                       *)
(*    Weak Forcing (C004):                                               *)
(*      Locates a bounded state within the EXISTING universe where       *)
(*      the statement behaves "As-If" it were true.                      *)
(*      (Never leaves the universe, exploits incompleteness.)            *)
(*                                                                       *)
(*  Key Insight                                                          *)
(*                                                                       *)
(*    We do NOT add axioms. We discover that incompleteness itself       *)
(*    "forces" the existence of bounded witnesses.                       *)
(*                                                                       *)
(*    Result Context: First-order logic (C002's additive fragment).      *)
(*                                                                       *)
(*  Downstream API                                                       *)
(*                                                                       *)
(*      (i) MirrorParams — Interface for regulators/separators.          *)
(*                                                                       *)
(*     (ii) AsIF(φ) — The predicate identifying "forced" statements:     *)
(*                                                                       *)
(*           ∃i. REG(i, b) ∧ BND(φ, b)                                   *)
(*                                                                       *)
(*    (iii) Mirror_fixed_witness — The main engine:                      *)
(*                                                                       *)
(*           ¬Prov(¬φ) + Regulator → AsIF(φ)                             *)
(*                                                                       *)
(*     (iv) Recursive_Mirror_Lemma — Extension for diagonal sentences:   *)
(*                                                                       *)
(*           Prov(θ ↔ MirrorPoint(θ))                                    *)
(*                                                                       *)
(*************************************************************************)

From Coq Require Import Init.Logic.

  (*
    Guard: No A/TA (axiom/theorem-axiom) modules imported here.
    This is a pure semantic surface.
  *)

From ATP.C004__Mirror_Lemma Require Export
  P1_S__Context
  P2_S__Mirror_Lemma
  P3_S__Recursive_Mirror_Lemma.

Set Implicit Arguments.
Unset Strict Implicit.

  (*
    Conceptual Namespaces
  *)

Module Prelude := ATP.C004__Mirror_Lemma.P1_S__Context.C_004_Context.
Module Mirror  := ATP.C004__Mirror_Lemma.P2_S__Mirror_Lemma.C_004_Mirror_S.
Module RecMirror := ATP.C004__Mirror_Lemma.P3_S__Recursive_Mirror_Lemma.C_004_Recursive_Mirror_S.

  (*
    Type Re-exports
  *)

Definition nat  : Type := Prelude.nat.
Definition Form : Type := Prelude.Form.
Definition Imp  : Form -> Form -> Form := Prelude.Imp.
Definition Bot  : Form := Prelude.Bot.
Definition Prov : Form -> Prop := Prelude.Prov.
Definition NotF (phi : Form) : Form := Prelude.NotF phi.

  (*
    Mirror Core API
  *)

Definition MirrorParams : Type := Mirror.MirrorParams.
Definition AsIF        : MirrorParams -> Form -> Prop := Mirror.AsIF.
Definition AsIF_simple : MirrorParams -> Form -> Prop := Mirror.AsIF_simple.
Definition Mir         : MirrorParams -> Form -> Prop := Mirror.Mir.

  (*
    Fixed-witness Lemma
  *)

Definition Mirror_fixed_witness
  (MP : MirrorParams) (i0 : nat) (b0 : Form)
  (REG0 : MP.(Mirror.REG) i0 b0)
  (BND0 : forall phi : Form, MP.(Mirror.BND) phi b0)
  (PRV0 : forall phi : Form, Prov (Imp phi b0))
  : forall phi : Form, ~ MP.(Mirror.ProvT_P) (NotF phi) -> AsIF MP phi
  := Mirror.Mirror_fixed_witness (MP := MP) (i0 := i0) (b0 := b0) REG0 BND0 PRV0.

  (*
    Restricted Diagonal Interface
  *)

Definition Transformer : Type := Mirror.Transformer.
Definition DiagDevice  : Type := Mirror.DiagDevice.
Definition trF   (G : Transformer) : Form -> Form := Mirror.trF G.

  (*
    Recursive Mirror Extensions
  *)

Definition ProvFormer : Type := RecMirror.ProvFormer.

Definition MirrorPointF
  (_MP : MirrorParams) (PF : ProvFormer) (_D : DiagDevice) (phi : Form) : Form :=
  RecMirror.MirrorPointF PF phi.

Definition theta
  (_MP : MirrorParams) (PF : ProvFormer) (D : DiagDevice) (rep : Prop) : Form :=
  RecMirror.theta PF D rep.

(*
  The Recursive Mirror Lemma (Main Public Theorem)

  For any diagonal sentence θ constructed via diagonal device D:

    Prov(θ → MirrorPoint(θ))  ∧  Prov(MirrorPoint(θ) → θ)

  Equivalently:

    Prov(θ ↔ MirrorPoint(θ))

  This establishes that θ is provably equivalent to its mirror point,
  enabling self-referential constructions for incompleteness theorems.
*)

Theorem Recursive_Mirror_Lemma
  (MP : MirrorParams) (PF : ProvFormer) (D : DiagDevice) (rep : Prop) :
  Prov (Imp (theta MP PF D rep) (MirrorPointF MP PF D (theta MP PF D rep)))
  /\
  Prov (Imp (MirrorPointF MP PF D (theta MP PF D rep)) (theta MP PF D rep)).
Proof.
  exact (RecMirror.Recursive_Mirror_Lemma PF D rep).
Qed.

(******************************************)
(******************************************)
(******************************************)
(******************************************)
(******************************************)
(******************************************)
(******      ****          *          *****)
(****   ░░░░   *░░   ░░░░░ ░░   ░░░░   ****)
(***   ****░░   *░   ** *░**░   ***░░   ***)
(**░   *****░   *░      ****░   ****░   ***)
(**░   ***  ░   *░   ░░ ****░   ****░   ***)
(**░░   *░░    **░   *░*** *░   ****   ****)
(***░░░      ░  *          *          *****)
(*****░░░░░░*░░*░░░░░░░░░░*░░░░░░░░░░******)
(******************************************)
(******************************************)
(******************************************)
(******************************************)
(******************************************)
(******************************************)


(* ---- theories/M003__Delian_Barrier/C005__Adversarial_Barrier/P1_S__Barrier_Definition.v ---- *)

(* P1_S__Barrier_Definition.v *)

(*************************************************************************)
(*                                                                       *)
(*  C005 / Phase 1 (S): Barrier Vocabulary & The Separator               *)
(*                                                                       *)
(*  What This File Provides                                              *)
(*                                                                       *)
(*     (i) The Semantic Context (A, B, Truth).                           *)
(*                                                                       *)
(*          Two classes of sentences indexed by ℕ:                       *)
(*                                                                       *)
(*            A, B : ℕ → Form                                            *)
(*            Truth : Form → Prop                                        *)
(*                                                                       *)
(*          Crucially, "Truth" is kept abstract. We only require that    *)
(*          reality is consistent (Semantic Disjointness):               *)
(*                                                                       *)
(*            ∀n. Truth(A(n)) ∧ Truth(B(n)) → ⊥                          *)
(*                                                                       *)
(*    (ii) The Target Device: SEPARATOR.                                 *)
(*                                                                       *)
(*          This is the object we will prove impossible.                 *)
(*          It consists of:                                              *)
(*                                                                       *)
(*          (a) An effective decision function σ : ℕ → bool.             *)
(*          (b) An internal certificate proving the decision is          *)
(*              formally justifiable:                                    *)
(*                                                                       *)
(*                σ(n) = true  → Prov(A(n))                              *)
(*                σ(n) = false → Prov(B(n))                              *)
(*                                                                       *)
(*   (iii) The Adversarial Mechanism: "Flip Logic."                      *)
(*                                                                       *)
(*          A function that observes the separator and intentionally     *)
(*          outputs the code for the *opposite* class:                   *)
(*                                                                       *)
(*            Flip(S, n) ≜ if σ(n) then B(n) else A(n)                   *)
(*                                                                       *)
(*          This creates the impredicative leak that drives the barrier. *)
(*                                                                       *)
(*   “Device-First Architecture”.                                        *)
(*                                                                       *)
(*      Solvability is a concrete Record (SEPARATOR), not an abstract    *)
(*      existential predicate (∃x. ...).                                 *)
(*                                                                       *)
(*      This allows the Flip Logic to "run" the separator and observe    *)
(*      its output, creating the diagonal construction.                  *)
(*                                                                       *)
(*************************************************************************)

From Coq Require Import Init.Logic.
From ATP.C002 Require Import P5_T__Proof_Theory.

Set Implicit Arguments.
Unset Strict Implicit.

Module Type C005_Barrier_Ctx.
  Module N := ATP.C002.P5_T__Proof_Theory.Prelude.
  Module P := ATP.C002.P5_T__Proof_Theory.ATP.

  Parameter A : N.nat -> P.ATP_Form.
  Parameter B : N.nat -> P.ATP_Form.
  Parameter Truth : P.ATP_Form -> Prop.
End C005_Barrier_Ctx.

Module C005_Barrier_Def_F (Ctx : C005_Barrier_Ctx).

  Module N := ATP.C002.P5_T__Proof_Theory.Prelude.
  Module P := ATP.C002.P5_T__Proof_Theory.ATP.

  Definition A : N.nat -> P.ATP_Form := Ctx.A.
  Definition B : N.nat -> P.ATP_Form := Ctx.B.
  Definition Truth : P.ATP_Form -> Prop := Ctx.Truth.

  (*
    Semantic Disjointness — Reality is Consistent

    The two classes A and B are semantically disjoint:

      ∀n. Truth(A(n)) ∧ Truth(B(n)) → ⊥

    This is the only requirement on the semantic model.
  *)

  Definition Semantic_Disjointness : Prop :=
    forall n : N.nat, Truth (A n) -> Truth (B n) -> False.

  (*
    The SEPARATOR — Certified Decision Device

    A separator is a total decision procedure with proof certificates:

      SOLVING (extensional):  σ : ℕ → bool
      PROVING (intensional):  σ(n) = true  → Prov(A(n))
                              σ(n) = false → Prov(B(n))

    This device will be proven impossible via the Adversarial Barrier.
  *)

  Record SEPARATOR : Type := {
    (* Extensional decision function *)
    sigma : N.nat -> N.bool;

    (* Intensional certificate *)
    cert : forall n : N.nat,
      if sigma n
      then P.ATP_Prov (A n)
      else P.ATP_Prov (B n)
  }.

  (*
    Flip Logic — The Adversarial Mechanism

    Observes the separator's decision and returns the opposite class:

      Flip(S, n) ≜ { B(n)  if σ(n) = true
                   { A(n)  if σ(n) = false

    This creates the impredicative loop:
      - S tries to separate A from B
      - Flip(S) outputs whichever class S rejects
      - This forces a contradiction via the Mirror Lemma
  *)

  Definition Flip_Logic (S : SEPARATOR) (n : N.nat) : P.ATP_Form :=
    if S.(sigma) n then B n else A n.

End C005_Barrier_Def_F.

(*
  Main Exported Module — Standalone Barrier Definition

  This module provides the barrier vocabulary without requiring
  a functor instantiation.
*)

Module C005_Barrier_Def_S.

  Module N := ATP.C002.P5_T__Proof_Theory.Prelude.
  Module P := ATP.C002.P5_T__Proof_Theory.ATP.

  (*
    Semantic Context — Two Disjoint Classes

    A, B : ℕ → Form  (indexed sentence classes)
  *)

  Parameter A : N.nat -> P.ATP_Form.
  Parameter B : N.nat -> P.ATP_Form.

  (*
    Truth — Semantic Bridge

    Truth : Form → Prop

    The semantic model for the logic. Kept abstract to ensure
    generality of the barrier construction.
  *)

  Parameter Truth : P.ATP_Form -> Prop.

  (*
    Semantic Disjointness — Reality is Consistent

    ∀n. Truth(A(n)) ∧ Truth(B(n)) → ⊥

    The classes are semantically disjoint: at most one can be true.
  *)

  Definition Semantic_Disjointness : Prop :=
    forall n : N.nat, Truth (A n) -> Truth (B n) -> False.

  (*
    The SEPARATOR — Certified Decision Device

    A separator combines:

      SOLVING:  σ : ℕ → bool        (extensional decision)
      PROVING:  Certificate mapping  (intensional justification)

    For each n ∈ ℕ:

      σ(n) = true  → Prov(A(n))
      σ(n) = false → Prov(B(n))

    This device will be proven impossible via adversarial argument.
  *)

  Record SEPARATOR : Type := {

    (*
      Extensional Decision Function

      σ : ℕ → bool

      Total, effective, computable decision.
    *)

    sigma : N.nat -> N.bool;

    (*
      Intensional Certificate

      For each index n, provides a proof of the chosen class.
    *)

    cert : forall n : N.nat,
      if sigma n
      then P.ATP_Prov (A n)
      else P.ATP_Prov (B n)
  }.

  (*
    Flip Logic — The Adversarial Mechanism

    Flip(S, n) ≜ { B(n)  if σ(n) = true
                 { A(n)  if σ(n) = false

    The impredicative leak:
      - S certifies one class
      - Flip returns the opposite class
      - When Flip is applied to its own encoding, contradiction ensues
  *)

  Definition Flip_Logic (S : SEPARATOR) (n : N.nat) : P.ATP_Form :=
    if S.(sigma) n then B n else A n.

End C005_Barrier_Def_S.

Export C005_Barrier_Def_S.


(* ---- theories/M003__Delian_Barrier/C005__Adversarial_Barrier/P2_R__Barrier_Proof.v ---- *)

(* P2_R__Barrier_Proof.v *)

From Coq Require Import Init.Logic.
From ATP.C002 Require Import P5_T__Proof_Theory.
From Adversarial_Barrier.C005 Require Import P1_S__Barrier_Definition.

Set Implicit Arguments.
Unset Strict Implicit.

Module C005_Barrier_Proof_F (Ctx : C005_Barrier_Ctx).

  Module Def := C005_Barrier_Def_F(Ctx).
  Module P := ATP.C002.P5_T__Proof_Theory.ATP.

  Section The_Trap.

  Variable S : Def.SEPARATOR.

  (* 
    Disjointness: Program is consistent (A and B cannot both be true).
  *)

  Hypothesis Is_Disjoint : Def.Semantic_Disjointness.

  (*
    Soundness: The system respects the Program (Prov -> Truth).
  *)

  Hypothesis Soundness : forall phi, P.ATP_Prov phi -> Def.Truth phi.

  (*
    Diagonal existence and truth tracking.
  *)

  Hypothesis Adversarial_Diagonal :
    exists (d : Def.N.nat) (D : P.ATP_Form),
      (Def.Truth D <-> Def.Truth (Def.Flip_Logic S d)) /\
      (Def.Truth (Def.A d) <-> Def.Truth D) /\
      (Def.Truth (Def.B d) <-> Def.Truth D).

  Theorem Barrier_Law : False.
  Proof.
    destruct Adversarial_Diagonal as [d [D [H_FixedPoint [H_TrackA H_TrackB]]]].

    destruct (S.(Def.sigma) d) eqn:Heq_dec.

    - (*
        Decision = true: certified A, flip gives B.
      *)

      pose proof (S.(Def.cert) d) as H_Prov_Outcome.
      rewrite Heq_dec in H_Prov_Outcome.
      pose proof (Soundness (phi := Def.A d) H_Prov_Outcome) as HTruthA.

      pose proof (proj1 H_TrackA HTruthA) as HTruthD.
      unfold Def.Flip_Logic in H_FixedPoint; rewrite Heq_dec in H_FixedPoint.
      pose proof (proj1 H_FixedPoint HTruthD) as HTruthB.

      exact (Is_Disjoint (n := d) HTruthA HTruthB).

    - (*
        Decision = false: certified B, flip gives A.
      *)

      pose proof (S.(Def.cert) d) as H_Prov_Outcome.
      rewrite Heq_dec in H_Prov_Outcome.
      pose proof (Soundness (phi := Def.B d) H_Prov_Outcome) as HTruthB.

      pose proof (proj1 H_TrackB HTruthB) as HTruthD.
      unfold Def.Flip_Logic in H_FixedPoint; rewrite Heq_dec in H_FixedPoint.
      pose proof (proj1 H_FixedPoint HTruthD) as HTruthA.

      exact (Is_Disjoint (n := d) HTruthA HTruthB).
  Qed.

  End The_Trap.

End C005_Barrier_Proof_F.

Module C005_Barrier_Proof_R.

  Module Def := C005_Barrier_Def_S.
  Module P := ATP.C002.P5_T__Proof_Theory.ATP.

  Section The_Trap.

  Variable S : Def.SEPARATOR.

  (*
    Disjointness: Program is consistent (A and B cannot both be true).
  *)

  Hypothesis Is_Disjoint : Def.Semantic_Disjointness.

  (*
    Soundness: The system respects the Program (Prov -> Truth).
  *)

  Hypothesis Soundness : forall phi, P.ATP_Prov phi -> Def.Truth phi.

  (* 
    Diagonal existence and truth tracking.
  *)

  Hypothesis Adversarial_Diagonal :
    exists (d : Def.N.nat) (D : P.ATP_Form),
      (Def.Truth D <-> Def.Truth (Def.Flip_Logic S d)) /\
      (Def.Truth (Def.A d) <-> Def.Truth D) /\
      (Def.Truth (Def.B d) <-> Def.Truth D).

  Theorem Barrier_Law : False.
  Proof.
    destruct Adversarial_Diagonal as [d [D [H_FixedPoint [H_TrackA H_TrackB]]]].

    destruct (S.(Def.sigma) d) eqn:Heq_dec.

    - (*
        Decision = true: certified A, flip gives B.
      *)

      pose proof (S.(Def.cert) d) as H_Prov_Outcome.
      rewrite Heq_dec in H_Prov_Outcome.
      pose proof (Soundness (phi := Def.A d) H_Prov_Outcome) as HTruthA.

      pose proof (proj1 H_TrackA HTruthA) as HTruthD.
      unfold Def.Flip_Logic in H_FixedPoint; rewrite Heq_dec in H_FixedPoint.
      pose proof (proj1 H_FixedPoint HTruthD) as HTruthB.

      exact (Is_Disjoint (n := d) HTruthA HTruthB).

    - (*
        Decision = false: certified B, flip gives A.
      *)

      pose proof (S.(Def.cert) d) as H_Prov_Outcome.
      rewrite Heq_dec in H_Prov_Outcome.
      pose proof (Soundness (phi := Def.B d) H_Prov_Outcome) as HTruthB.

      pose proof (proj1 H_TrackB HTruthB) as HTruthD.
      unfold Def.Flip_Logic in H_FixedPoint; rewrite Heq_dec in H_FixedPoint.
      pose proof (proj1 H_FixedPoint HTruthD) as HTruthA.

      exact (Is_Disjoint (n := d) HTruthA HTruthB).
  Qed.

  End The_Trap.

End C005_Barrier_Proof_R.

Export C005_Barrier_Proof_R.


(* ---- theories/M003__Delian_Barrier/C005__Adversarial_Barrier/P2_T__Barrier.v ---- *)

(* P2_T__Barrier.v *)

(*************************************************************************)
(*                                                                       *)
(*  C005 / Phase 2 (T): The Adversarial Barrier Theorem (Public Surface) *)
(*                                                                       *)
(*  What This File Provides                                              *)
(*                                                                       *)
(*    The public-facing Adversarial Barrier theorem:                     *)
(*                                                                       *)
(*      ∀S : SEPARATOR. Diagonal_Witness(S) → ⊥                          *)
(*                                                                       *)
(*    A packaged impossibility result for certified separators.          *)
(*                                                                       *)
(*************************************************************************)

From Coq Require Import Init.Logic.
From Adversarial_Barrier.C005 Require Export P1_S__Barrier_Definition.
From Adversarial_Barrier.C005 Require Import P2_R__Barrier_Proof.

Set Implicit Arguments.
Unset Strict Implicit.

(*************************************************************************)
(*                                                                       *)
(*  Module: C005_Barrier_T_F (Functor for Parametric Export)             *)
(*                                                                       *)
(*  Provides the barrier theorem parametrized by barrier context Ctx.    *)
(*                                                                       *)
(*  Purpose:                                                             *)
(*                                                                       *)
(*    Enables modular composition with varying semantic interpretations  *)
(*    of A, B, and Truth.                                                *)
(*                                                                       *)
(*************************************************************************)

Module C005_Barrier_T_F (Ctx : C005_Barrier_Ctx).
  Module Proof := C005_Barrier_Proof_F(Ctx).
  Module Def := Proof.Def.

  (*
    Type Exports for Public Interface

    SEPARATOR    — Certified decision device (parametric)
    Disjointness — Semantic disjointness predicate
  *)

  Definition SEPARATOR := Def.SEPARATOR.
  Definition Disjointness := Def.Semantic_Disjointness.

  (***********************************************************************)
  (*                                                                     *)
  (*  Theorem: Adversarial_Barrier (Functor Version)                     *)
  (*                                                                     *)
  (*  The main impossibility theorem for certified separators.           *)
  (*                                                                     *)
  (*    No certified separator can exist when fed to a diagonal device   *)
  (*    that creates self-referential sentences via flip logic.          *)
  (*                                                                     *)
  (*    The diagonal witness D collapses A(d) and B(d) together,         *)
  (*    violating semantic disjointness.                                 *)
  (*                                                                     *)
  (***********************************************************************)

  Theorem Adversarial_Barrier :
    forall (S : Def.SEPARATOR)
           (Is_Disjoint : Def.Semantic_Disjointness)
           (Soundness : forall phi, Def.P.ATP_Prov phi -> Def.Truth phi),
      (exists (d : Def.N.nat) (D : Def.P.ATP_Form),
        (Def.Truth D <-> Def.Truth (Def.Flip_Logic S d)) /\
        (Def.Truth (Def.A d) <-> Def.Truth D) /\
        (Def.Truth (Def.B d) <-> Def.Truth D))
      -> False.
  Proof.
    intros S Is_Disjoint Soundness Hdiag.

    (*
      Direct application of Barrier_Law from realization layer (P2_R).
    *)

    exact (@Proof.Barrier_Law S Is_Disjoint Soundness Hdiag).
  Qed.

End C005_Barrier_T_F.

(***********************************************************************)
(*                                                                     *)
(*  Recommended Usage:                                                 *)
(*                                                                     *)
(*   Users want to import this module rather than the functor.         *)
(*                                                                     *)
(***********************************************************************)

Module C005_Barrier_T.
  Module Def := C005_Barrier_Def_S.

  (*
    Type Exports for Public Interface

    SEPARATOR    — Certified decision device record
    Disjointness — Semantic disjointness predicate
  *)
  
  Definition SEPARATOR := Def.SEPARATOR.
  Definition Disjointness := Def.Semantic_Disjointness.

  (***********************************************************************)
  (*                                                                     *)
  (*  Theorem: Adversarial_Barrier (Canonical Export)                    *)
  (*                                                                     *)
  (*  This is the recommended entry point for downstream use.            *)
  (*                                                                     *)
  (*  Statement (Informal):                                              *)
  (*                                                                     *)
  (*    “No certified separator can exist.”                              *)
  (*                                                                     *)
  (*  Statement (Formal):                                                *)
  (*                                                                     *)
  (*    ∀S : SEPARATOR.                                                  *)
  (*      Disjoint(A, B) ∧ Sound(Prov) ∧ Diagonal(S) → ⊥                 *)
  (*                                                                     *)
  (*    There exists (d, D) such that:                                   *)
  (*                                                                     *)
  (*      Truth(D) ↔ Truth(Flip(S, d))                                   *)
  (*      Truth(A(d)) ↔ Truth(D)                                         *)
  (*      Truth(B(d)) ↔ Truth(D)                                         *)
  (*                                                                     *)
  (*    This forces Truth(A(d)) ↔ Truth(B(d)), violating disjointness.   *)
  (*                                                                     *)
  (***********************************************************************)

  Theorem Adversarial_Barrier :
    forall (S : Def.SEPARATOR)
           (Is_Disjoint : Def.Semantic_Disjointness)
           (Soundness : forall phi, Def.P.ATP_Prov phi -> Def.Truth phi),
      (exists (d : Def.N.nat) (D : Def.P.ATP_Form),
        (Def.Truth D <-> Def.Truth (Def.Flip_Logic S d)) /\
        (Def.Truth (Def.A d) <-> Def.Truth D) /\
        (Def.Truth (Def.B d) <-> Def.Truth D))
      -> False.
  Proof.
    intros S Is_Disjoint Soundness Hdiag.

    (*
      Apply Barrier_Law from realization layer (P2_R).
      Uses eapply/eauto for clean proof interface.
    *)

    eapply C005_Barrier_Proof_R.Barrier_Law; eauto.
  Qed.

End C005_Barrier_T.

Export C005_Barrier_T.

(* ---- theories/M003__Delian_Barrier/C005__Adversarial_Barrier/P2_T__Mirror_Instance.v ---- *)

(* P2_T__Mirror_Instance.v *)

From Coq Require Import Init.Logic.

From ATP.C004__Mirror_Lemma Require Import P3_T__Weakforcing.

From Adversarial_Barrier.C005 Require Import P2_T__Barrier.

From ATP.C002 Require Import P2_R__Hilbert_Kernel.

Set Implicit Arguments.
Unset Strict Implicit.

(*************************************************************************)
(*                                                                       *)
(*  C005 / Phase 3 (T): The Mirror Instance (Separator as Regulator)     *)
(*                                                                       *)
(*  The Metatheoretic Bridge                                             *)
(*                                                                       *)
(*  This file re-interprets the Adversarial Barrier through the lens     *)
(*  of the Mirror Lemma (C004). It demonstrates that the impossibility   *)
(*  of a separator is a structural necessity derived from the Mirror     *)
(*  Schema.                                                              *)
(*                                                                       *)
(*  Key Insights                                                         *)
(*                                                                       *)
(*      (i) The Separator as Regulator                                   *)
(*                                                                       *)
(*          The SEPARATOR record (σ, cert) provides exactly the data     *)
(*          needed to satisfy the Mirror Lemma's REG and BND predicates. *)
(*                                                                       *)
(*          It "regulates" the diagonal sentence by forcing a formal     *)
(*          classification into A or B.                                  *)
(*                                                                       *)
(*     (ii) From "As-If" to "Collision"                                  *)
(*                                                                       *)
(*          The Mirror Lemma proves that the diagonal sentence D exists  *)
(*          in an As-If state: AsIF(D).                                  *)
(*                                                                       *)
(*          The Barrier shows that under Soundness, this As-If state     *)
(*          collides with Flip Logic, refuting the separator:            *)
(*                                                                       *)
(*            AsIF(D) + Sound + Flip(S,d) → Truth(A(d)) ∧ Truth(B(d))    *)
(*                                                                       *)
(*          This violates semantic disjointness.                         *)
(*                                                                       *)
(*    (iii) Constructive Hilbert Witness                                 *)
(*                                                                       *)
(*          To derive the necessary weakening rules without axioms,      *)
(*          we explicitly witness the Hilbert K-combinator:              *)
(*                                                                       *)
(*            K : φ → (ψ → φ)                                            *)
(*                                                                       *)
(*          This allows: Prov(φ) → Prov(ψ → φ) (weakening rule).         *)
(*                                                                       *)
(*************************************************************************)

Module Barrier_As_Mirror.

  Module Mirror := ATP.C004__Mirror_Lemma.P3_T__Weakforcing.
  Module Barrier := Adversarial_Barrier.C005.P2_T__Barrier.C005_Barrier_T.
  Module Def := Barrier.Def.
  Module P := Def.P.
  Module Pre := ATP.C002.P1_S__Kernel_Spec.C_002_Prelim.
  Module HK := ATP.C002.P2_R__Hilbert_Kernel.C_002_HilbertKernel_R.
  Module Core := ATP.C004__Mirror_Lemma.P2_S__Mirror_Lemma.C_004_Mirror_S.
  
  (*************************************************************************)
  (*                                                                       *)
  (*  Hilbert K-Combinator: Constructive Witness for Weakening             *)
  (*                                                                       *)
  (*  The Additive Theory (ATP) exports Modus Ponens.                      *)
  (*  The underlying kernel implements Hilbert axioms K and S.             *)
  (*  We witness K explicitly here to derive the weakening rule.           *)
  (*                                                                       *)
  (*************************************************************************)

  (*
    Hilbert K Axiom

    For all formulas φ, ψ:

      Prov(φ → (ψ → φ))

    This is the fundamental combinator for weakening.
  *)

  Theorem Prov_K : forall phi psi : P.ATP_Form,
    P.ATP_Prov (P.ATP_Imp phi (P.ATP_Imp psi phi)).
  Proof.
    intros phi psi.

    (*
      Define the K instance: φ → (ψ → φ)
    *)

    pose (K_inst := P.ATP_Imp phi (P.ATP_Imp psi phi)).
    
    (*
      Use Pre.cons/nil (the kernel's list type) to build the proof object.
    *)

    pose (pf := (Pre.cons K_inst Pre.nil) : HK.Proof).

    (*
      Build a direct kernel proof object (no checker bridge needed).
    *)

    unfold P.ATP_Prov.
    exists pf.
    apply HK.Prf_intro with (phi := K_inst).
    - simpl. exact (eq_refl _).
    - apply HK.Prf_lines_cons_Ax.
      + apply HK.Ax_K.
      + apply HK.Prf_lines_nil.
  Qed.

  (*
    Derived Weakening Rule

    From Prov(A), derive Prov(B → A).

    Proof: Apply Modus Ponens to K and the hypothesis:

      1. K axiom: Prov(A → (B → A))
      2. Hypothesis: Prov(A)
      3. MP: Prov(B → A)
  *)

  Lemma Prov_weakening : forall A B, P.ATP_Prov A -> P.ATP_Prov (P.ATP_Imp B A).
  Proof.
    intros A B H_Prov_A.

    (*
      Instantiate K: Prov(A → (B → A))
    *)

    pose proof (Prov_K A B) as H_K.

    (*
      Apply Modus Ponens: (A → (B → A)), A ⊢ B → A
    *)

    eapply P.ATP_Prov_MP; eauto.
  Qed.

  (*************************************************************************)
  (*                                                                       *)
  (*  Wrapping Barrier Flip Logic as Mirror Transform                      *)
  (*                                                                       *)
  (*  The separator's Flip Logic becomes a representable transformer:      *)
  (*                                                                       *)
  (*    trF(φ) = Flip(S, code(φ))                                          *)
  (*                                                                       *)
  (*  This allows the Mirror Lemma to construct diagonal sentences.        *)
  (*                                                                       *)
  (*************************************************************************)

  Definition Flip_Transformer
    (S : Barrier.SEPARATOR)
    (code : Mirror.Form -> Def.N.nat)
    (Flip_Rep : Prop) :
    Mirror.Transformer :=
    {|
       Core.trF   := fun phi => Barrier.Def.Flip_Logic S (code phi);
       Core.trRep := Flip_Rep
    |}.

  (*************************************************************************)
  (*                                                                       *)
  (*  Mirror Parameters — Instantiating the Mirror Schema for Barriers     *)
  (*                                                                       *)
  (*  The separator provides exactly the structure needed for the Mirror   *)
  (*  Lemma's abstract parameters.                                         *)
  (*                                                                       *)
  (*************************************************************************)

  (*
    Barrier_REG — The Separator as Regulator

    REG(i, b) ≜ { b = A(i)  if σ(i) = true
                { b = B(i)  if σ(i) = false

    The separator's decision σ(i) determines which class bound regulates
    index i. This is exactly the REG predicate needed by the Mirror Lemma.
  *)

  Definition Barrier_REG (S : Barrier.SEPARATOR) (i : Def.N.nat) (b : P.ATP_Form) : Prop :=
    if S.(Def.sigma) i
    then b = Def.A i
    else b = Def.B i.

  (*
    Barrier_BND — Syntactic Implication Bound

    BND(φ, b) ≜ Prov(φ → b)

    The bound predicate is simply provable implication.
  *)

  Definition Barrier_BND (phi b : P.ATP_Form) : Prop :=
    P.ATP_Prov (P.ATP_Imp phi b).

  (*
    Barrier_MP — Complete Mirror Parameters

    Bundles REG, BND, and ProvT_P into the MirrorParams record
    required by the Mirror Lemma.
  *)

  Definition Barrier_MP (S : Barrier.SEPARATOR) : Mirror.MirrorParams :=
    {|
       Mirror.REG     := Barrier_REG S;
       Mirror.BND     := Barrier_BND;
       Mirror.ProvT_P := P.ATP_Prov
    |}.

  (***********************************************************************)
  (*                                                                     *)
  (*  The Separator Witnesses As-If                                      *)
  (*                                                                     *)
  (*  The separator suddenly acts as a regulator witness for the         *)
  (*  diagonal sentence!                                                 *)
  (*                                                                     *)
  (*  Theorem: For any diagonal sentence D = Flip(S, d), there exists    *)
  (*  a bound b such that:                                               *)
  (*                                                                     *)
  (*    BND(D, b) ∧ Prov(D → b)                                          *)
  (*                                                                     *)
  (*  This is a key component of the As-If predicate.                    *)
  (*                                                                     *)
  (***********************************************************************)

  Theorem Separator_Witnesses_AsIF :
    forall (S : Barrier.SEPARATOR) (D : Mirror.Form) (d : Barrier.Def.N.nat),
    (* Assumption: D is the diagonal fixed point *)
    (D = Barrier.Def.Flip_Logic S d) ->
    (* Conclusion: D satisfies the As-If bound condition *)
    exists (b : Mirror.Form),
      Mirror.BND (Barrier_MP S) D b /\
      P.ATP_Prov (P.ATP_Imp D b).
  Proof.
    intros S D d H_Fix.

    (*
      Run the separator on the code d
    *)

    destruct (Barrier.Def.sigma S d) eqn:Heq.
    -
      (*
        Case σ(d) = true: Separator chooses class A
      *)

      exists (Def.A d).
      split.
      +
        (*
          Goal: BND(D, A(d)), i.e., Prov(D → A(d))
        *)

        unfold Barrier_MP, Barrier_BND.

        (*
          Separator certificate: Prov(A(d))
        *)

        pose proof (S.(Def.cert) d) as H_Prov_A.
        rewrite Heq in H_Prov_A.

        (*
          Weakening: Prov(A(d)) → Prov(D → A(d))
        *)

        apply Prov_weakening.
        exact H_Prov_A.
      +
        (*
          Goal: Prov(D → A(d)) (repeated for second conjunct)
        *)

        pose proof (S.(Def.cert) d) as H_Prov_A.
        rewrite Heq in H_Prov_A.
        apply Prov_weakening. exact H_Prov_A.

    -
      (*
        Case σ(d) = false: Separator chooses class B
      *)

      exists (Def.B d).
      split.
      +
        (*
          Goal: BND(D, B(d)), i.e., Prov(D → B(d))
        *)

        unfold Barrier_MP, Barrier_BND.
        pose proof (S.(Def.cert) d) as H_Prov_B.
        rewrite Heq in H_Prov_B.
        apply Prov_weakening. exact H_Prov_B.
      + pose proof (S.(Def.cert) d) as H_Prov_B.
        rewrite Heq in H_Prov_B.
        apply Prov_weakening. exact H_Prov_B.
  Qed.

  (*************************************************************************)
  (*                                                                       *)
  (*  Collision Theorem — Two Evaluators Cannot Coexist                    *)
  (*                                                                       *)
  (*  The contradiction is re-derived by showing that the separator        *)
  (*  creates two competing evaluations of truth for the same index:       *)
  (*                                                                       *)
  (*    1. PROOF EVALUATOR (Soundness + Certificate):                      *)
  (*       σ(d) = true  → Prov(A(d)) → Truth(A(d))                         *)
  (*       σ(d) = false → Prov(B(d)) → Truth(B(d))                         *)
  (*                                                                       *)
  (*    2. FLIP EVALUATOR (Flip Logic + Diagonal):                         *)
  (*       Truth(D) ↔ Truth(Flip(S,d))                                     *)
  (*       σ(d) = true  → Flip(S,d) = B(d) → Truth(B(d))                   *)
  (*       σ(d) = false → Flip(S,d) = A(d) → Truth(A(d))                   *)
  (*                                                                       *)
  (*  Combined:                                                            *)
  (*                                                                       *)
  (*        σ(d) = true  → Truth(A(d)) ∧ Truth(B(d))                       *)
  (*        σ(d) = false → Truth(B(d)) ∧ Truth(A(d))                       *)
  (*                                                                       *)
  (*  In a consistent setting (Semantic Disjointness), these cannot        *)
  (*  both be true. Contradiction.                                         *)
  (*                                                                       *)
  (*************************************************************************)

  Theorem Barrier_Contradiction_via_Mirror :
    forall (S : Barrier.SEPARATOR) (d : Def.N.nat) (D : P.ATP_Form),
      Barrier.Disjointness ->
      (forall phi, P.ATP_Prov phi -> Def.Truth phi) ->

      (*
        Assumption: D is the Semantic Fixed Point of Flip Logic
      *)

      (Def.Truth D <-> Def.Truth (Def.Flip_Logic S d)) ->
      
      (*
        Assumption: D tracks A and B (Crucial for Barrier)
      *)

      (Def.Truth (Def.A d) <-> Def.Truth D) ->
      (Def.Truth (Def.B d) <-> Def.Truth D) ->
      False.
  Proof.
    intros S d D Disjoint Sound H_Fix H_TrackA H_TrackB.

    (*
      Case analysis on separator's decision: σ(d) = true or false?
    *)

    destruct (Def.sigma S d) eqn:Heq.

    -
      (*
        Case σ(d) = true: Separator chooses A(d)
      *)

      (*
        PROOF EVALUATOR: σ(d) = true → Prov(A(d))
      *)

      pose proof (Def.cert S d) as H_Prov_A.
      rewrite Heq in H_Prov_A.

      (*
        Soundness: Prov(A(d)) → Truth(A(d))
      *)

      apply Sound in H_Prov_A.

      (*
        Truth Tracking: Truth(A(d)) ↔ Truth(D)
        So: Truth(D)
      *)

      apply H_TrackA in H_Prov_A.

      (*
        FLIP EVALUATOR: Truth(D) ↔ Truth(Flip(S,d))
        Since σ(d) = true, Flip(S,d) = B(d)
        So: Truth(B(d))
      *)

      apply H_Fix in H_Prov_A.
      unfold Def.Flip_Logic in H_Prov_A.
      rewrite Heq in H_Prov_A.

      (*
        Now we have: Truth(B(d))
        Re-establish: Truth(A(d)) from certificate
      *)

      pose proof (Def.cert S d) as H_Prov_A_again.
      rewrite Heq in H_Prov_A_again.
      apply Sound in H_Prov_A_again.

      (*
        COLLISION: Truth(A(d)) ∧ Truth(B(d))
        Semantic Disjointness gives ⊥
      *)

      eapply Disjoint.
      apply H_Prov_A_again. apply H_Prov_A.

    -
      (*
        Case σ(d) = false: Separator chooses B(d)
      *)

      (*
        PROOF EVALUATOR: σ(d) = false → Prov(B(d))
      *)

      pose proof (Def.cert S d) as H_Prov_B.
      rewrite Heq in H_Prov_B.

      (*
        Soundness: Prov(B(d)) → Truth(B(d))
      *)

      apply Sound in H_Prov_B.

      (*
        Truth Tracking: Truth(B(d)) ↔ Truth(D)
        So: Truth(D)
      *)

      apply H_TrackB in H_Prov_B.

      (*
        FLIP EVALUATOR: Truth(D) ↔ Truth(Flip(S,d))
        Since σ(d) = false, Flip(S,d) = A(d)
        So: Truth(A(d))
      *)

      apply H_Fix in H_Prov_B.
      unfold Def.Flip_Logic in H_Prov_B.
      rewrite Heq in H_Prov_B.

      (*
        Now we have: Truth(A(d))
        Re-establish: Truth(B(d)) from certificate
      *)

      pose proof (Def.cert S d) as H_Prov_B_again.
      rewrite Heq in H_Prov_B_again.
      apply Sound in H_Prov_B_again.

      (*
        COLLISION: Truth(B(d)) ∧ Truth(A(d))
        Semantic Disjointness gives ⊥
      *)

      eapply Disjoint. apply H_Prov_B. apply H_Prov_B_again.
  Qed.

  (*************************************************************************)
  (*                                                                       *)
  (*  Separator Implies Class Collapse                                     *)
  (*                                                                       *)
  (*  The Five-Step Argument (Barrier via Mirror):                         *)
  (*                                                                       *)
  (*      (i) Assume a SEPARATOR exists (hypothesis for reductio).         *)
  (*                                                                       *)
  (*     (ii) The Mirror Lemma forces the diagonal into an As-If state:    *)
  (*          AsIF(D).                                                     *)
  (*                                                                       *)
  (*    (iii) Soundness lifts As-If to semantic Truth:                     *)
  (*          AsIF(D) + Sound → Truth(D).                                  *)
  (*                                                                       *)
  (*     (iv) Flip Logic derives both:                                     *)
  (*          Truth(A(d)) ∧ Truth(B(d)).                                   *)
  (*                                                                       *)
  (*      (v) Semantic Disjointness gives ⊥ (contradiction).               *)
  (*                                                                       *)
  (*  From ⊥, we can derive anything, including A = B (class collapse).    *)
  (*                                                                       *)
  (*************************************************************************)

  Theorem Separator_Implies_Class_Collapse :
    forall (S : Barrier.SEPARATOR),
      Barrier.Disjointness ->
      (forall phi, P.ATP_Prov phi -> Def.Truth phi) ->
      (exists (d : Def.N.nat) (D : P.ATP_Form),
        (Def.Truth D <-> Def.Truth (Def.Flip_Logic S d)) /\
        (Def.Truth (Def.A d) <-> Def.Truth D) /\
        (Def.Truth (Def.B d) <-> Def.Truth D)) ->

      (forall n, Def.A n = Def.B n).
  Proof.
    intros S Disjoint Sound Hdiag n.

    (*
      Step 1: Extract the diagonal witness
    *)

    destruct Hdiag as [d [D [H_Fix [H_TrackA H_TrackB]]]].

    (*
      Step 2: Derive the barrier contradiction (⊥)
    *)

    pose proof
      (@Barrier_Contradiction_via_Mirror S d D Disjoint Sound H_Fix H_TrackA H_TrackB)
      as H_False.

    (*
      Step 3: Ex Falso Quodlibet

      From ⊥, derive anything — in particular, A(n) = B(n).

      In the BHK_R nucleus, False is the empty type,
      so elimination gives any proposition.
    *)

    destruct H_False.
  Qed.

End Barrier_As_Mirror.


(* ---- theories/M003__Delian_Barrier/C006__Audit_Barrier/P1_S__Context.v ---- *)

(* P1_S__Context.v *)

(*************************************************************************)
(*                                                                       *)
(*  C006 / Phase 1 (S): Audit Barrier Context and Interfaces             *)
(*                                                                       *)
(*  What This File Provides                                              *)
(*                                                                       *)
(*    (i)   The Hilbert-Bernays Interface (HILBERT_BERNAYS)              *)
(*                                                                       *)
(*          Specifies the provability operator □ (Box) with properties:  *)
(*                                                                       *)
(*          (a) HB1 (Distribution):                                      *)
(*              Prov(A → B) → Prov(□A → □B)                              *)
(*                                                                       *)
(*          (b) HB2 (Internalization/Necessitation):                     *)
(*              Prov(A) → Prov(□A)                                       *)
(*                                                                       *)
(*          (c) Löb's Rule (Self-Reference):                             *)
(*              Prov(□A → A) → Prov(A)                                   *)
(*                                                                       *)
(*    (ii)  The Decider Specification (DECIDER_T)                        *)
(*                                                                       *)
(*          A total decision function σ : ℕ → bool with certificates:    *)
(*                                                                       *)
(*          (a) σ(n) = true  → Prov(A(n))                                *)
(*          (b) σ(n) = false → Prov(¬A(n))                               *)
(*                                                                       *)
(*    (iii) The Audit Condition (AuditInt)                               *)
(*                                                                       *)
(*          Self-verification requirement at diagonal index d:           *)
(*                                                                       *)
(*          (a) Prov(□A(d) → A(d))      (reflection for A)               *)
(*          (b) Prov(□¬A(d) → ¬A(d))    (reflection for ¬A)              *)
(*                                                                       *)
(*  Design Notes                                                         *)
(*                                                                       *)
(*    The Hilbert-Bernays conditions are specified as a module type,     *)
(*    allowing multiple realizations while keeping the barrier proof     *)
(*    parametric.                                                        *)
(*                                                                       *)
(*  The Audit Barrier Impossibility                                      *)
(*                                                                       *)
(*    DECIDER_T and AuditInt cannot coexist:                             *)
(*                                                                       *)
(*      Attempting self-verification via □ triggers Löb's rule,          *)
(*      forcing Prov(⊥) via the diagonal flip mechanism.                 *)
(*                                                                       *)
(*    "Self-auditing systems collapse."                                  *)
(*                                                                       *)
(*************************************************************************)

From Coq Require Import Init.Logic.
From ATP.C002 Require Import P5_T__Proof_Theory.

Set Implicit Arguments.
Unset Strict Implicit.

(*
  Stable Context for Audit Barrier Constructions

  Re-exports ATP types and defines the Hilbert-Bernays interface
  for provability logic.
*)

Module C006_Context_S.

  (*
    Import the ATP kernel from C002 (Additive Hilbert System).
  *)

  Module Prelude := ATP.C002.P5_T__Proof_Theory.Prelude.
  Module ATP := ATP.C002.P5_T__Proof_Theory.ATP.

  (*
    Type Exports — Arithmetic and Logic

    nat  : ℕ (natural numbers)
    Form : Formula type
    Imp  : → (implication)
    Bot  : ⊥ (falsity)
    Prov : Provability predicate
  *)

  Definition nat  : Type := Prelude.nat.
  Definition Form : Type := ATP.ATP_Form.
  Definition Imp  : Form -> Form -> Form := ATP.ATP_Imp.
  Definition Bot  : Form := ATP.ATP_Bot.
  Definition Prov : Form -> Prop := ATP.ATP_Prov.

  (*************************************************************************)
  (*                                                                       *)
  (*  Module Type: HILBERT_BERNAYS                                         *)
  (*                                                                       *)
  (*  Minimal requirements for a provability operator □ (Box) that        *)
  (*  supports self-referential reasoning via Löb's rule.                  *)
  (*                                                                       *)
  (*  This is the foundation for the Audit Barrier proof.                  *)
  (*                                                                       *)
  (*************************************************************************)

  Module Type HILBERT_BERNAYS.

    (*
      Provability Predicate

      Prov : Form → Prop

      Meta-level predicate stating that a formula is provable.
    *)

    Parameter Prov : Form -> Prop.

    (*
      Box — The Provability Operator (Modal Necessity)

      □ : Form → Form

      □φ is the formula expressing "φ is provable."
      This is the syntactic internalization of the Prov predicate.

      In modal logic notation: □ is the necessity operator.
    *)

    Parameter Box : Form -> Form.

    (*
      HB1: Distribution Law

      Prov(A → B) → Prov(□A → □B)

      If provability of implication holds, then the implication
      lifts through the Box operator.

      Modal logic: □(A → B) → (□A → □B)
    *)

    Parameter HB1 : forall A B : Form, Prov (Imp A B) -> Prov (Imp (Box A) (Box B)).

    (*
      HB2: Internalization (Necessitation)

      Prov(A) → Prov(□A)

      If A is provable at the meta-level, then □A is provable
      at the object level.

      This allows provability to "talk about itself."
    *)

    Parameter HB2 : forall A : Form, Prov A -> Prov (Box A).

    (*************************************************************************)
    (*                                                                       *)
    (*  Löb's Rule — The Self-Reference Principle                            *)
    (*                                                                       *)
    (*  Prov(□A → A) → Prov(A)                                               *)
    (*                                                                       *)
    (*  If the system proves "provability implies truth" for A,              *)
    (*  then it proves A itself.                                             *)
    (*                                                                       *)
    (*  Key Insight:                                                         *)
    (*                                                                       *)
    (*    This is the rule that enables the Audit Barrier proof.             *)
    (*                                                                       *)
    (*    Löb's rule is what makes self-auditing impossible:                 *)
    (*    combining it with AuditInt (self-verification) sacrifices          *)
    (*    consistency for provability, forcing Prov(⊥).                      *)
    (*                                                                       *)
    (*  Modal Logic Perspective:                                             *)
    (*                                                                       *)
    (*    In Gödel-Löb logic (GL), this is the Löb axiom:                    *)
    (*                                                                       *)
    (*      □(□A → A) → □A                                                   *)
    (*                                                                       *)
    (*    Our formulation is the inference rule version.                     *)
    (*                                                                       *)
    (*************************************************************************)

    Parameter Loeb : forall A : Form, Prov (Imp (Box A) A) -> Prov A.

  End HILBERT_BERNAYS.

  (*************************************************************************)
  (*                                                                       *)
  (*  Certified Decider and Self-Audit Definitions                         *)
  (*                                                                       *)
  (*  These predicates define:                                             *)
  (*                                                                       *)
  (*    - What it means for a decision procedure to be "certified"         *)
  (*      (DECIDER_T)                                                      *)
  (*                                                                       *)
  (*    - What it means to satisfy "self-audit" conditions (AuditInt)      *)
  (*                                                                       *)
  (*************************************************************************)

  (*
    Negation — Implication to Falsity

    ¬A ≜ A → ⊥

    Standard intuitionistic treatment of negation.
  *)

  Definition NotF (A : Form) : Form := Imp A Bot.

  (*************************************************************************)
  (*                                                                       *)
  (*  Definition: DECIDER_T — Certified Decision Procedure                *)
  (*                                                                       *)
  (*  A certified decider for a problem class A : ℕ → Form.                *)
  (*                                                                       *)
  (*  Given:                                                               *)
  (*                                                                       *)
  (*    A : ℕ → Form      (problem class, indexed by naturals)             *)
  (*    σ : ℕ → bool      (decision function)                              *)
  (*                                                                       *)
  (*  DECIDER_T(A, σ) holds when:                                          *)
  (*                                                                       *)
  (*    ∀n ∈ ℕ.                                                            *)
  (*      (i)  σ(n) = true  → Prov(A(n))                                   *)
  (*      (ii) σ(n) = false → Prov(¬A(n))                                  *)
  (*                                                                       *)
  (*  Interpretation:                                                      *)
  (*                                                                       *)
  (*    The decider provides proof certificates for both positive and      *)
  (*    negative classifications.                                          *)
  (*                                                                       *)
  (*    This is a complete decider: it decides the problem and certifies   *)
  (*    its decision via formal proof.                                     *)
  (*                                                                       *)
  (*************************************************************************)

  Definition DECIDER_T (A : nat -> Form) (sigma : nat -> Prelude.bool) : Prop :=
    forall n : nat,
      (sigma n = Prelude.true -> Prov (A n)) /\
      (sigma n = Prelude.false -> Prov (ATP.ATP_Imp (A n) Bot)).

  (*************************************************************************)
  (*                                                                       *)
  (*  Definition: AuditInt — Self-Audit Internalization                    *)
  (*                                                                       *)
  (*  The audit internalization condition at diagonal index d.             *)
  (*                                                                       *)
  (*  AuditInt(□, A, d) holds when the system proves both:                 *)
  (*                                                                       *)
  (*    (i)  Prov(□A(d) → A(d))      (reflection for A)                    *)
  (*    (ii) Prov(□¬A(d) → ¬A(d))    (reflection for ¬A)                   *)
  (*                                                                       *)
  (*  Interpretation:                                                      *)
  (*                                                                       *)
  (*    This expresses "self-audit capability":                            *)
  (*                                                                       *)
  (*      The decider can verify its own correctness via the □ operator.   *)
  (*                                                                       *)
  (*    In other words:                                                    *)
  (*                                                                       *)
  (*      - If the system proves "A(d) is provable", then A(d) holds.      *)
  (*      - If the system proves "¬A(d) is provable", then ¬A(d) holds.    *)
  (*                                                                       *)
  (*    This is a form of soundness reflection at the diagonal index.      *)
  (*                                                                       *)
  (*  The Audit Barrier Theorem:                                           *)
  (*                                                                       *)
  (*    DECIDER_T and AuditInt cannot coexist.                             *)
  (*                                                                       *)
  (*    Attempting self-audit triggers Löb's rule, forcing Prov(⊥)         *)
  (*    via the diagonal flip mechanism.                                   *)
  (*                                                                       *)
  (*  Key Insight:                                                         *)
  (*                                                                       *)
  (*    "Self-auditing systems are impossible."                            *)
  (*                                                                       *)
  (*    A system cannot both:                                              *)
  (*      (a) Decide a problem completely (DECIDER_T)                      *)
  (*      (b) Verify its own correctness (AuditInt)                        *)
  (*                                                                       *)
  (*    The diagonal construction forces a choice between completeness     *)
  (*    and self-verification.                                             *)
  (*                                                                       *)
  (*************************************************************************)

  Definition AuditInt (Box : Form -> Form) (A : nat -> Form) (d : nat) : Prop :=
    (Prov (Imp (Box (A d)) (A d))) /\
    (Prov (Imp (Box (NotF (A d))) (NotF (A d)))).

End C006_Context_S.

Export C006_Context_S.

(* ---- theories/M003__Delian_Barrier/C006__Audit_Barrier/P2_R__Audit_Logic.v ---- *)

(* P2_R__Audit_Logic.v *)

From Coq Require Import Init.Logic.
From ATP.C002 Require Import P5_T__Proof_Theory.
From Diagonallemma.C003 Require Import P2_T__Diagonal.
From Audit_Barrier.C006 Require Import P1_S__Context.

Set Implicit Arguments.
Unset Strict Implicit.

(*************************************************************************)
(*                                                                       *)
(*  C_006 / Phase 2 (R): Audit Logic (Code-Level Flip Mechanism)         *)
(*                                                                       *)
(*  The code-level flip mechanism for audit barrier construction.        *)
(*                                                                       *)
(*    (i) This file implements the flip at the code level,               *)
(*        providing the abstract infrastructure for connecting,          *)
(*        (a) Decision function sigma_code (nat -> bool)                 *)
(*        (b) Code manipulation (codeA, neg_code)                        *)
(*        (c) Flip operator (flip_code)                                  *)
(*                                                                       *)
(*   (ii) abstract parameters,                                           *)
(*        (a) codeA: maps indices to codes                               *)
(*        (b) neg_code: code-level negation                              *)
(*        (c) sigma_code: decision function at code level                *)
(*                                                                       *)
(*    The flip_code function mirrors the semantic flip logic from        *)
(*    C005, but operates at the code/arithmetization level rather        *)
(*    than the formula level.                                            *)
(*                                                                       *)
(*    This file provides the arithmetic substrate for the audit          *)
(*    barrier. The actual barrier proof uses the diagonal device         *)
(*    (C003) to realize these abstract codes as concrete formulas.       *)
(*                                                                       *)
(*************************************************************************)

Module C006_Audit_Logic_R.

  Module Ctx := C006_Context_S.
  Module Cod := ATP.C002.P5_T__Proof_Theory.Coding.
  Module CN := ATP.C002.P4_R__Coding_Nucleus.C_002_Coding_Nucleus_R.

  (*
    Code type from C002 coding nucleus
  *)

  Definition Code : Type := CN.Code Cod.CanonicalCodec.

  (*************************************************************************)
  (*                                                                       *)
  (*  Concrete realizations provide:                                       *)
  (*                                                                       *)
  (*    (i) codeA: encoding of formula family A                            *)
  (*   (ii) neg_code: code-level negation operator                         *)
  (*  (iii) sigma_code: decision function operating on codes               *)
  (*                                                                       *)
  (*************************************************************************)

  (*
    Primitive recursive code operator for formula family A
  *)

  Parameter codeA : Ctx.nat -> Code.

  (*
    Code-level negation (corresponds to NotF at formula level)
  *)

  Parameter neg_code : Code -> Code.

  (*
    Boolean decision function at code level
  *)

  Parameter sigma_code : Ctx.nat -> Ctx.Prelude.bool.

  (***********************************************************************)
  (*                                                                     *)
  (*  The code-level flip mechanism.                                     *)
  (*                                                                     *)
  (*  Given index n:                                                     *)
  (*    (i) If sigma_code(n) = true,  return neg_code(codeA n)           *)
  (*   (ii) If sigma_code(n) = false, return codeA n                     *)
  (*                                                                     *)
  (*  The flip_code function provides the adversarial input to the       *)
  (*  diagonal device, creating a self-referential sentence that         *)
  (*  triggers the audit barrier contradiction.                          *)
  (*                                                                     *)
  (***********************************************************************)

  Definition flip_code (n : Ctx.nat) : Code :=
    match sigma_code n with
    | Ctx.Prelude.true => neg_code (codeA n)
    | Ctx.Prelude.false => codeA n
    end.

End C006_Audit_Logic_R.

Export C006_Audit_Logic_R.



(* ---- theories/M003__Delian_Barrier/C006__Audit_Barrier/P2_T__Audit_Barrier.v ---- *)

(* P2_T__Audit_Barrier.v *)

(*************************************************************************)
(*                                                                       *)
(*  C006 / Phase 2 (T): Audit Barrier Theorem (Public Surface)           *)
(*                                                                       *)
(*  The Main Impossibility Theorem                                       *)
(*                                                                       *)
(*    DECIDER_T → ¬AuditInt                                              *)
(*                                                                       *)
(*  Informal Statement:                                                  *)
(*                                                                       *)
(*    "A certified decider cannot self-audit."                           *)
(*                                                                       *)
(*  Formal Statement:                                                    *)
(*                                                                       *)
(*    A certified decider cannot satisfy self-audit conditions at the    *)
(*    diagonal index. Attempting to do so triggers Löb's rule,           *)
(*    forcing Prov(⊥).                                                   *)
(*                                                                       *)
(*  What This File Exports                                               *)
(*                                                                       *)
(*      (i) Hilbert-Bernays Conditions (HB1, HB2, Löb)                   *)
(*          Required for provability operator □.                         *)
(*                                                                       *)
(*     (ii) Diagonal Fixed Point D at Index d                            *)
(*          The self-referential witness from diagonal construction.     *)
(*                                                                       *)
(*    (iii) Impossibility Proof                                          *)
(*          Via case analysis on σ(d), both cases force Prov(⊥).         *)
(*                                                                       *)
(*  Key Insight                                                          *)
(*                                                                       *)
(*    Self-verification via □ reflection triggers Löb's rule,            *)
(*    forcing the system to prove the diagonal sentence, which           *)
(*    collides with the decider's certificates.                          *)
(*                                                                       *)
(*    This is Russell's vicious circle: impredicative self-reference.    *)
(*                                                                       *)
(*************************************************************************)

From Coq Require Import Init.Logic.
From Audit_Barrier.C006 Require Import P1_S__Context.

Set Implicit Arguments.
Unset Strict Implicit.

(*************************************************************************)
(*                                                                       *)
(*  This module provides the main audit barrier impossibility theorem.   *)
(*                                                                       *)
(*************************************************************************)

Module C006_Audit_Barrier_T.

  Module Ctx := C006_Context_S.

  (*
    Negation — Implication to Falsity

    ¬A ≜ A → ⊥
  *)

  Definition NotF (A : Ctx.Form) : Ctx.Form := Ctx.Imp A Ctx.Bot.

  (*************************************************************************)
  (*                                                                       *)
  (*  Section: Audit_Barrier — The Main Impossibility Proof                *)
  (*                                                                       *)
  (*  Parameters:                                                          *)
  (*                                                                       *)
  (*    A : ℕ → Form           (problem class)                             *)
  (*    σ : ℕ → bool           (decision function)                         *)
  (*    □ : Form → Form        (provability operator)                      *)
  (*    D : Form               (diagonal sentence)                         *)
  (*    d : ℕ                  (diagonal index)                            *)
  (*                                                                       *)
  (*  Hypotheses:                                                          *)
  (*                                                                       *)
  (*    HB1:        Prov(A → B) → Prov(□A → □B)    (distribution)          *)
  (*    HB2:        Prov(A) → Prov(□A)              (internalization)      *)
  (*    Löb:        Prov(□A → A) → Prov(A)          (Löb's rule)           *)
  (*    MP:         Prov(A → B) ∧ Prov(A) → Prov(B) (modus ponens)         *)
  (*    Consistent: ¬Prov(⊥)                        (consistency)          *)
  (*    D_eq_Flip:  D = Flip(σ, d)                  (diagonal equation)    *)
  (*                                                                       *)
  (*************************************************************************)

  Section Audit_Barrier.
    Variable A : Ctx.nat -> Ctx.Form.
    Variable sigma : Ctx.nat -> Ctx.Prelude.bool.

    Variable Box : Ctx.Form -> Ctx.Form.

    (*
      HB1: Distribution Law

      Prov(X → Y) → Prov(□X → □Y)

      Provability distributes through implication.
    *)

    Hypothesis HB1 : forall X Y : Ctx.Form, Ctx.Prov (Ctx.Imp X Y) -> Ctx.Prov (Ctx.Imp (Box X) (Box Y)).

    (*
      HB2: Internalization (Necessitation)

      Prov(X) → Prov(□X)

      Meta-level provability internalizes to object-level □.
    *)

    Hypothesis HB2 : forall X : Ctx.Form, Ctx.Prov X -> Ctx.Prov (Box X).

    (*
      Löb's Rule — The Key to Impossibility

      Prov(□X → X) → Prov(X)

      This is the critical rule that makes self-auditing impossible.
      When combined with AuditInt, it forces Prov(⊥).
    *)

    Hypothesis Loeb : forall X : Ctx.Form, Ctx.Prov (Ctx.Imp (Box X) X) -> Ctx.Prov X.

    (*
      Modus Ponens

      Prov(X → Y) ∧ Prov(X) → Prov(Y)

      Standard inference rule.
    *)

    Hypothesis MP : forall X Y : Ctx.Form, Ctx.Prov (Ctx.Imp X Y) -> Ctx.Prov X -> Ctx.Prov Y.

    (*
      Consistency Hypothesis

      ¬Prov(⊥)

      We assume the system is consistent (does not prove falsity).
      Both proof cases will derive Prov(⊥), contradicting this.
    *)

    Hypothesis Consistent : ~ Ctx.Prov Ctx.Bot.

    (*
      Diagonal Sentence and Index

      D : Form  (the diagonal sentence)
      d : ℕ     (the diagonal index)
    *)

    Variable D : Ctx.Form.
    Variable d : Ctx.nat.

    (*************************************************************************)
    (*                                                                       *)
    (*  Diagonal Flip Equation                                               *)
    (*                                                                       *)
    (*  D is the flip formula at diagonal index d:                           *)
    (*                                                                       *)
    (*    D = { ¬A(d)  if σ(d) = true                                        *)
    (*        { A(d)   if σ(d) = false                                       *)
    (*                                                                       *)
    (*  This is the self-referential witness from the diagonal device        *)
    (*  (C003), creating the impredicative loop.                             *)
    (*                                                                       *)
    (*  Key Property:                                                        *)
    (*                                                                       *)
    (*    D always "flips" away from what the decider certifies.             *)
    (*                                                                       *)
    (*************************************************************************)

    Hypothesis D_eq_Flip : D = (if sigma d then NotF (A d) else A d).

    (*
      Local Abbreviations for Main Predicates

      DECIDER_T : σ is a certified decider for A
      AuditInt  : A satisfies self-audit at index d via □
    *)

    Definition DECIDER_T : Prop := Ctx.DECIDER_T A sigma.
    Definition AuditInt : Prop := Ctx.AuditInt Box A d.

    (*************************************************************************)
    (*                                                                       *)
    (*  Theorem: Audit_Barrier — The Main Impossibility Result               *)
    (*                                                                       *)
    (*  Statement:                                                           *)
    (*                                                                       *)
    (*    DECIDER_T → ¬AuditInt                                              *)
    (*                                                                       *)
    (*  A certified decider cannot satisfy self-audit conditions at the      *)
    (*  diagonal index without proving ⊥ (collapsing the system).            *)
    (*                                                                       *)
    (*  Proof Strategy:                                                      *)
    (*                                                                       *)
    (*    1. Assume DECIDER_T ∧ AuditInt (for reductio)                      *)
    (*    2. Extract audit conditions:                                       *)
    (*         • Prov(□A(d) → A(d))                                          *)
    (*         • Prov(□¬A(d) → ¬A(d))                                        *)
    (*    3. Case split on σ(d):                                             *)
    (*                                                                       *)
    (*       Case σ(d) = true:                                               *)
    (*         • D = ¬A(d) (by flip equation)                                *)
    (*         • AuditInt gives: Prov(□D → D)                                *)
    (*         • Löb's rule: Prov(D), i.e., Prov(¬A(d))                      *)
    (*         • DECIDER_T gives: Prov(A(d))                                 *)
    (*         • MP: Prov(⊥) ← contradiction                                 *)
    (*                                                                       *)
    (*       Case σ(d) = false:                                              *)
    (*         • D = A(d) (by flip equation)                                 *)
    (*         • AuditInt gives: Prov(□D → D)                                *)
    (*         • Löb's rule: Prov(D), i.e., Prov(A(d))                       *)
    (*         • DECIDER_T gives: Prov(¬A(d))                                *)
    (*         • MP: Prov(⊥) ← contradiction                                 *)
    (*                                                                       *)
    (*    4. Both cases contradict Consistent hypothesis                     *)
    (*                                                                       *)
    (*************************************************************************)

    Theorem Audit_Barrier : DECIDER_T -> ~ AuditInt.
    Proof.
      intros HDec HAudit.

      (*
        Step 1: Extract the two audit conditions from AuditInt
      *)

      destruct HAudit as [HAudA HAudNotA].

      (*
        We now have:
          HAudA    : Prov(□A(d) → A(d))
          HAudNotA : Prov(□¬A(d) → ¬A(d))
      *)

      (*
        Step 2: Case analysis on σ(d)
      *)

      destruct (sigma d) eqn:Hs.

      - (*************************************************************************)
        (*                                                                       *)
        (*  Case σ(d) = true — Decider Certifies A(d)                            *)
        (*                                                                       *)
        (*  The decider classifies d as belonging to class A.                    *)
        (*  We derive Prov(⊥) via Löb's rule and Modus Ponens.                   *)
        (*                                                                       *)
        (*************************************************************************)

        (*
          Step 1: Derive Prov(□D → D) from audit condition

          By the flip equation: D = ¬A(d) when σ(d) = true.
          So we need: Prov(□¬A(d) → ¬A(d)).
          This is exactly HAudNotA.
        *)

        assert (Ctx.Prov (Ctx.Imp (Box D) D)) as HBoxD.
        {
          rewrite D_eq_Flip.
          (*
            Goal: Prov(□(¬A(d)) → ¬A(d))
            This is HAudNotA (audit condition for negation).
          *)
          exact HAudNotA.
        }

        (*
          Step 2: Apply Löb's rule

          Löb: Prov(□D → D) → Prov(D)

          We have HBoxD: Prov(□D → D)
          Therefore: Prov(D)
        *)

        pose proof (Loeb (X := D) HBoxD) as HProvD.

        (*
          HProvD : Prov(D)

          Step 3: Unfold D = ¬A(d)
        *)

        rewrite D_eq_Flip in HProvD.

        (*
          HProvD : Prov(¬A(d)) = Prov(A(d) → ⊥)

          Step 4: Extract decider certificate

          DECIDER_T says: σ(d) = true → Prov(A(d))
        *)

        specialize (HDec d) as [HDecT _].
        pose proof (HDecT Hs) as HProvA.

        (*
          HProvA : Prov(A(d))

          Step 5: Apply Modus Ponens

          We have:
            • Prov(A(d) → ⊥)  (from HProvD)
            • Prov(A(d))      (from HProvA)

          MP gives: Prov(⊥)
        *)

        pose proof (MP (X := A d) (Y := Ctx.Bot) HProvD HProvA) as HProvBot.

        (*
          HProvBot : Prov(⊥)

          Step 6: Contradiction with consistency hypothesis
        *)

        exact (Consistent HProvBot).

      - (*************************************************************************)
        (*                                                                       *)
        (*  Case σ(d) = false — Decider Certifies ¬A(d)                          *)
        (*                                                                       *)
        (*  The decider classifies d as NOT belonging to class A.                *)
        (*  Symmetric argument to Case 1.                                        *)
        (*                                                                       *)
        (*************************************************************************)

        (*
          Step 1: Derive Prov(□D → D) from audit condition

          By the flip equation: D = A(d) when σ(d) = false.
          So we need: Prov(□A(d) → A(d)).
          This is exactly HAudA.
        *)

        assert (Ctx.Prov (Ctx.Imp (Box D) D)) as HBoxD.
        {
          rewrite D_eq_Flip.
          (*
            Goal: Prov(□A(d) → A(d))
            This is HAudA (audit condition for positive case).
          *)
          exact HAudA.
        }

        (*
          Step 2: Apply Löb's rule

          Löb: Prov(□D → D) → Prov(D)

          We have HBoxD: Prov(□D → D)
          Therefore: Prov(D)
        *)

        pose proof (Loeb (X := D) HBoxD) as HProvD.

        (*
          HProvD : Prov(D)

          Step 3: Unfold D = A(d)
        *)

        rewrite D_eq_Flip in HProvD.

        (*
          HProvD : Prov(A(d))

          Step 4: Extract decider certificate

          DECIDER_T says: σ(d) = false → Prov(¬A(d))
        *)

        specialize (HDec d) as [_ HDecF].
        pose proof (HDecF Hs) as HProvNotA.

        (*
          HProvNotA : Prov(¬A(d)) = Prov(A(d) → ⊥)

          Step 5: Apply Modus Ponens

          We have:
            • Prov(A(d) → ⊥)  (from HProvNotA)
            • Prov(A(d))      (from HProvD)

          MP gives: Prov(⊥)
        *)

        pose proof (MP (X := A d) (Y := Ctx.Bot) HProvNotA HProvD) as HProvBot.

        (*
          HProvBot : Prov(⊥)

          Step 6: Contradiction with consistency hypothesis
        *)

        exact (Consistent HProvBot).
    Qed.

  End Audit_Barrier.

End C006_Audit_Barrier_T.

Export C006_Audit_Barrier_T.

(*************************************************************************)
(*                                                                       *)
(*  The Audit Barrier — Key Insights                                     *)
(*                                                                       *)
(*  The Impossibility Trade-Off:                                         *)
(*                                                                       *)
(*     A system cannot simultaneously:                                   *)
(*       (a) Be a complete decider (DECIDER_T)                           *)
(*       (b) Self-audit via provability operator (AuditInt)              *)
(*       (c) Remain consistent (¬Prov(⊥))                                *)
(*                                                                       *)
(*     At most two of these can hold.                                    *)
(*                                                                       *)
(*  Connection to Gödel's Second Incompleteness Theorem:                 *)
(*                                                                       *)
(*       If the system proves its own consistency (via □),               *)
(*       it must be inconsistent. It has to assume it.                   *)
(*                                                                       *)
(*  Here, AuditInt is a strengthened form of consistency reflection.     *)
(*                                                                       *)
(*************************************************************************)


(* ---- theories/M003__Delian_Barrier/C006__Audit_Barrier/P2_T__Audit_Adapter.v ---- *)

(* P2_T__Audit_Adapter.v *)

(*************************************************************************)
(*                                                                       *)
(*  C_006 / Phase 3 (T): Audit Adapter                                   *)
(*                                                                       *)
(*  Connects C003 diagonal device with the C006 audit barrier.           *)
(*                                                                       *)
(*************************************************************************)

From Coq Require Import Init.Logic.
From Audit_Barrier.C006 Require Import P1_S__Context.
From Audit_Barrier.C006 Require Import P2_T__Audit_Barrier.
From Diagonallemma.C003 Require Import P2_T__Diagonal.

Set Implicit Arguments.
Unset Strict Implicit.

Module C006_Audit_Adapter_T.

  Module Ctx := C006_Context_S.
  Module Diag := Diagonallemma.C003.P2_T__Diagonal.

  Section Adapter.

    Variable A : Ctx.nat -> Ctx.Form.
    Variable sigma : Ctx.nat -> Ctx.Prelude.bool.

    Variable Box : Ctx.Form -> Ctx.Form.

    Hypothesis HB1 : forall X Y : Ctx.Form, Ctx.Prov (Ctx.Imp X Y) -> Ctx.Prov (Ctx.Imp (Box X) (Box Y)).
    Hypothesis HB2 : forall X : Ctx.Form, Ctx.Prov X -> Ctx.Prov (Box X).
    Hypothesis Loeb : forall X : Ctx.Form, Ctx.Prov (Ctx.Imp (Box X) X) -> Ctx.Prov X.
    Hypothesis MP : forall X Y : Ctx.Form, Ctx.Prov (Ctx.Imp X Y) -> Ctx.Prov X -> Ctx.Prov Y.
    Hypothesis Consistent : ~ Ctx.Prov Ctx.Bot.

    (*
      Diagonal device instantiation (abstract adapter).
    *)
    
    Variable Flip_Template : Diag.Template.
    Variable Compiled : Diag.COMPILED Flip_Template.

    Variable Form_of_Template : Diag.Template -> Ctx.Form.

    Definition D_t : Diag.Template := Diag.diag (t := Flip_Template) Compiled.
    Definition d : Ctx.nat := Diag.encU D_t.
    Definition D : Ctx.Form := Form_of_Template D_t.

    (*
      Bridge: the diagonal instance realizes the flip at code d.
    *)
    
    Hypothesis Diag_As_Flip :
      D = (if sigma d then Ctx.NotF (A d) else A d).

    Theorem Audit_Barrier_Concrete :
      Ctx.DECIDER_T A sigma -> ~ Ctx.AuditInt Box A d.
    Proof.
      exact (@C006_Audit_Barrier_T.Audit_Barrier
               A sigma Box Loeb MP Consistent D d Diag_As_Flip).
    Qed.

  End Adapter.

End C006_Audit_Adapter_T.

Export C006_Audit_Adapter_T.


(* ---- theories/M003__Delian_Barrier/C006__Audit_Barrier/P3_A__Provability_Logic.v ---- *)

(* P3_A__Provability_Logic.v *)

(*************************************************************************)
(*                                                                       *)
(*  C006 / Phase 3 (A): Provability Logic Instance (Axiom Layer)         *)
(*                                                                       *)
(*  Purpose                                                              *)
(*                                                                       *)
(*    Provides a concrete axiomatized instance of the HILBERT_BERNAYS    *)
(*    module type for use in the audit barrier proof.                    *)
(*                                                                       *)
(*  What This File Provides                                              *)
(*                                                                       *)
(*    (i)   Box operator: □ : Form → Form                                *)
(*          The provability modality for ATP formulas.                   *)
(*                                                                       *)
(*    (ii)  HB_Instance: Concrete module implementing HILBERT_BERNAYS    *)
(*          Includes proofs of HB1, HB2, and Löb's rule.                 *)
(*                                                                       *)
(*   (iii)  Opt-in axiomatization: Similar to Reflexica certificate.     *)
(*          Consumers explicitly import to gain access to □.             *)
(*                                                                       *)
(*  Design Notes                                                         *)
(*                                                                       *)
(*    The ATP logic (C002) provides Imp and Bot but no Box operator.     *)
(*    This file axiomatizes Box and its Hilbert-Bernays properties,      *)
(*    following the same discipline as the Reflexica certificate.        *)
(*                                                                       *)
(*    Justification:                                                     *)
(*                                                                       *)
(*      The Box operator represents proof reflection — the ability of    *)
(*      a system to internalize its own provability predicate as a       *)
(*      formula constructor.                                             *)
(*                                                                       *)
(*      This is a meta-logical capability that cannot be constructed     *)
(*      from the base logic alone. It must be postulated as an           *)
(*      extension (similar to how modal logic extends propositional      *)
(*      logic).                                                          *)
(*                                                                       *)
(*    Usage Pattern:                                                     *)
(*                                                                       *)
(*      Module HB := C006_Provability_Logic.HB_Instance.                 *)
(*      (* Now HB.Box, HB.HB1, HB.HB2, HB.Loeb are available *)          *)
(*                                                                       *)
(*************************************************************************)

From Coq Require Import Init.Logic.
From Audit_Barrier.C006 Require Import P1_S__Context.

Set Implicit Arguments.
Unset Strict Implicit.

Module C006_Provability_Logic.

  Module Ctx := C006_Context_S.

  (*************************************************************************)
  (*                                                                       *)
  (*  Axiomatized Provability Logic                                        *)
  (*                                                                       *)
  (*  We postulate the existence of a Box operator (□) satisfying the      *)
  (*  Hilbert-Bernays conditions.                                          *)
  (*                                                                       *)
  (*  This is analogous to the Reflexica certificate: a single point       *)
  (*  of failure that isolates non-constructive proof reflection.          *)
  (*                                                                       *)
  (*************************************************************************)

  Module HB_Axiomatized <: C006_Context_S.HILBERT_BERNAYS.

    (*
      Provability Predicate — Re-export from ATP.C002
    *)

    Definition Prov : Ctx.Form -> Prop := Ctx.Prov.

    (*
      Box Operator — Axiomatized Extension

      □ : Form → Form

      Box(φ) is the formula expressing "φ is provable."

      This is the syntactic internalization of the Prov predicate.
      In modal logic: □ is the necessity operator (K4/GL modality).
    *)

    Parameter Box : Ctx.Form -> Ctx.Form.

    (*************************************************************************)
    (*                                                                       *)
    (*  HB1: Distribution Law (K-axiom)                                      *)
    (*                                                                       *)
    (*  Prov(A → B) → Prov(□A → □B)                                          *)
    (*                                                                       *)
    (*  If the implication A → B is provable, then the lifted implication    *)
    (*  □A → □B is also provable.                                            *)
    (*                                                                       *)
    (*  Modal logic: □(A → B) → (□A → □B)                                    *)
    (*                                                                       *)
    (*  Justification:                                                       *)
    (*                                                                       *)
    (*    If we have a proof of A → B, and we have a proof of A, then by     *)
    (*    modus ponens we can derive a proof of B. The Box operator          *)
    (*    preserves this implication structure.                              *)
    (*                                                                       *)
    (*************************************************************************)

    Axiom HB1 : forall A B : Ctx.Form,
      Prov (Ctx.Imp A B) -> Prov (Ctx.Imp (Box A) (Box B)).

    (*************************************************************************)
    (*                                                                       *)
    (*  HB2: Internalization (Necessitation Rule)                            *)
    (*                                                                       *)
    (*  Prov(A) → Prov(□A)                                                   *)
    (*                                                                       *)
    (*  If A is provable at the meta-level, then □A is provable at the      *)
    (*  object level.                                                        *)
    (*                                                                       *)
    (*  Modal logic: If ⊢ A then ⊢ □A                                        *)
    (*                                                                       *)
    (*  Justification:                                                       *)
    (*                                                                       *)
    (*    This is the "soundness reflection" property: if we have a proof    *)
    (*    of A, we can construct a formula asserting that fact.              *)
    (*                                                                       *)
    (*    This allows the system to "talk about" its own proofs.             *)
    (*                                                                       *)
    (*************************************************************************)

    Axiom HB2 : forall A : Ctx.Form,
      Prov A -> Prov (Box A).

    (*************************************************************************)
    (*                                                                       *)
    (*  Löb's Rule — The Self-Reference Principle                            *)
    (*                                                                       *)
    (*  Prov(□A → A) → Prov(A)                                               *)
    (*                                                                       *)
    (*  If the system proves "provability implies truth" for A, then it      *)
    (*  proves A itself.                                                     *)
    (*                                                                       *)
    (*  Modal logic: □(□A → A) → □A  (Löb's theorem in GL)                   *)
    (*                                                                       *)
    (*  Justification:                                                       *)
    (*                                                                       *)
    (*    This is the key principle that enables:                            *)
    (*      (a) Self-referential proofs (Gödelian fixed points)              *)
    (*      (b) The audit barrier impossibility                              *)
    (*                                                                       *)
    (*    Löb's rule captures the essence of Gödel's incompleteness:         *)
    (*    A system powerful enough to formalize "provability implies truth"  *)
    (*    for its own sentences must either prove the sentence or be         *)
    (*    inconsistent.                                                      *)
    (*                                                                       *)
    (*  Connection to Incompleteness:                                        *)
    (*                                                                       *)
    (*    Gödel's Second Incompleteness Theorem follows from Löb's rule:     *)
    (*                                                                       *)
    (*      Con := ¬□⊥  (consistency statement)                              *)
    (*                                                                       *)
    (*    Löb's rule with A = ⊥ gives:                                       *)
    (*      Prov(□⊥ → ⊥) → Prov(⊥)                                           *)
    (*                                                                       *)
    (*    Since Prov(□⊥ → ⊥) is equivalent to Prov(Con), we have:            *)
    (*      Prov(Con) → Prov(⊥)                                              *)
    (*                                                                       *)
    (*    Therefore, if the system is consistent, it cannot prove Con.       *)
    (*                                                                       *)
    (*************************************************************************)

    Axiom Loeb : forall A : Ctx.Form,
      Prov (Ctx.Imp (Box A) A) -> Prov A.

  End HB_Axiomatized.

  (*
    Public Instance — Canonical HB Implementation
  *)

  Module HB_Instance := HB_Axiomatized.

  (*************************************************************************)
  (*                                                                       *)
  (*  Convenience Re-Exports                                               *)
  (*                                                                       *)
  (*  These allow downstream consumers to access the Box operator and      *)
  (*  Hilbert-Bernays properties without fully qualifying the module.      *)
  (*                                                                       *)
  (*************************************************************************)

  Definition Box : Ctx.Form -> Ctx.Form := HB_Instance.Box.

  Definition HB1 : forall A B : Ctx.Form,
    Ctx.Prov (Ctx.Imp A B) -> Ctx.Prov (Ctx.Imp (Box A) (Box B)) :=
    HB_Instance.HB1.

  Definition HB2 : forall A : Ctx.Form,
    Ctx.Prov A -> Ctx.Prov (Box A) :=
    HB_Instance.HB2.

  Definition Loeb : forall A : Ctx.Form,
    Ctx.Prov (Ctx.Imp (Box A) A) -> Ctx.Prov A :=
    HB_Instance.Loeb.

  (*************************************************************************)
  (*                                                                       *)
  (*  Usage Example: Audit Barrier Instantiation                           *)
  (*                                                                       *)
  (*  Section Example_Audit_Instantiation.                                 *)
  (*                                                                       *)
  (*    (* Import provability logic *)                                      *)
  (*    Import C006_Provability_Logic.                                      *)
  (*                                                                       *)
  (*    (* Problem class and decider *)                                     *)
  (*    Variable A : nat -> Form.                                           *)
  (*    Variable sigma : nat -> bool.                                       *)
  (*                                                                       *)
  (*    (* Use HB instance *)                                               *)
  (*    Definition My_Box := Box.                                           *)
  (*    Definition My_HB1 := HB1.                                           *)
  (*    Definition My_HB2 := HB2.                                           *)
  (*    Definition My_Loeb := Loeb.                                         *)
  (*                                                                       *)
  (*    (* Apply audit barrier theorem *)                                   *)
  (*    Theorem My_Audit_Barrier :                                          *)
  (*      DECIDER_T A sigma -> ~ AuditInt My_Box A d.                       *)
  (*    Proof.                                                              *)
  (*      apply (@Audit_Barrier A sigma My_Box My_Loeb ...).                *)
  (*    Qed.                                                                *)
  (*                                                                       *)
  (*  End Example_Audit_Instantiation.                                      *)
  (*                                                                       *)
  (*************************************************************************)

End C006_Provability_Logic.

(*
  Public re-exports for convenient access.
*)

Export C006_Provability_Logic.


(* ---- theories/M003__Delian_Barrier/C007__Resistance_Law/P1_S__Separation.v ---- *)

(* P1_S__Separation.v *)

From Coq Require Import Init.Logic.
From ATP.C002 Require Import P5_T__Proof_Theory.

Set Implicit Arguments.
Unset Strict Implicit.

(*************************************************************************)
(*                                                                       *)
(*  C007 / Phase 1 (S): Separation Context                               *)
(*                                                                       *)
(*  What This File Provides                                              *)
(*                                                                       *)
(*    Minimal context for the Resistance Law (diagonal resistance).      *)
(*                                                                       *)
(*    (i)   Two semantic classes A, B : ℕ → Form                         *)
(*    (ii)  Semantic disjointness: Truth(A(n)) ∧ Truth(B(n)) → ⊥         *)
(*    (iii) SEPARATOR: certified decision device                         *)
(*    (iv)  Soundness: Prov(φ) → Truth(φ)                                *)
(*    (v)   Flip Logic: adversarial flip mechanism                       *)
(*                                                                       *)
(*  This is the same context as C005, re-exported for C007.              *)
(*                                                                       *)
(*************************************************************************)

Module C007_Separation_S.

  (*
    Import ATP kernel (Additive Hilbert System from C002).
  *)

  Module Prelude := ATP.C002.P5_T__Proof_Theory.Prelude.
  Module ATP := ATP.C002.P5_T__Proof_Theory.ATP.

  (*
    Type Exports

    nat  : ℕ (natural numbers)
    Form : Formula type
    Prov : Provability predicate
  *)

  Definition nat  : Type := Prelude.nat.
  Definition Form : Type := ATP.ATP_Form.
  Definition Prov : Form -> Prop := ATP.ATP_Prov.

  (*
    Semantic Classes

    A, B : ℕ → Form  (two classes of indexed sentences)
    Truth : Form → Prop  (semantic model)
  *)

  Parameter A : nat -> Form.
  Parameter B : nat -> Form.
  Parameter Truth : Form -> Prop.

  (*
    Semantic Disjointness — Reality is Consistent

    ∀n. Truth(A(n)) ∧ Truth(B(n)) → ⊥

    The two classes are semantically disjoint: at most one can be true.
  *)

  Definition Semantic_Disjointness : Prop :=
    forall n : nat, Truth (A n) -> Truth (B n) -> False.

  (*
    SEPARATOR — Certified Decision Device

    A separator is a total decision procedure σ : ℕ → bool with
    proof certificates:

      σ(n) = true  → Prov(A(n))
      σ(n) = false → Prov(B(n))

    This device will be proven impossible via the Resistance Law.
  *)

  Record SEPARATOR : Type := {
    sigma : nat -> Prelude.bool;
    cert : forall n : nat,
      if sigma n then Prov (A n) else Prov (B n)
  }.

  (*
    Soundness — Provability Implies Truth

    ∀φ. Prov(φ) → Truth(φ)

    The proof system is sound with respect to the semantic model.
  *)

  Definition Soundness : Prop :=
    forall phi : Form, Prov phi -> Truth phi.

  (*
    Flip Logic — The Adversarial Mechanism

    Flip(S, n) ≜ { B(n)  if σ(n) = true
                 { A(n)  if σ(n) = false

    Returns the opposite class from what the separator certifies.
  *)

  Definition Flip_Logic (S : SEPARATOR) (n : nat) : Form :=
    if S.(sigma) n then B n else A n.

End C007_Separation_S.

Export C007_Separation_S.


(* ---- theories/M003__Delian_Barrier/C007__Resistance_Law/P2_R__Resistance_Proof.v ---- *)

(* P2_R__Resistance_Proof.v *)

(*************************************************************************)
(*                                                                       *)
(*  C007 / Phase 2 (R): Resistance Proof (Realization)                   *)
(*                                                                       *)
(*    (i) Scope.                                                         *)
(*                                                                       *)
(*        This file provides the core resistance proof: given a          *)
(*        separator S with diagonal witness (d, D), derive ⊥ via        *)
(*        disjointness collapse.                                         *)
(*                                                                       *)
(*   (ii) Proof Strategy.                                                *)
(*                                                                       *)
(*        The proof is a double case analysis on the separator's         *)
(*        decision σ(d) at the diagonal index d:                         *)
(*                                                                       *)
(*        Case σ(d) = true:                                              *)
(*          (a) Certificate gives: Prov(A(d))                            *)
(*          (b) Soundness lifts:   Truth(A(d))                           *)
(*          (c) Tracking gives:    Truth(D)                              *)
(*          (d) Flip witness:      Truth(B(d))                           *)
(*          (e) Disjointness:      ⊥                                     *)
(*                                                                       *)
(*        Case σ(d) = false:                                             *)
(*          (a) Certificate gives: Prov(B(d))                            *)
(*          (b) Soundness lifts:   Truth(B(d))                           *)
(*          (c) Tracking gives:    Truth(D)                              *)
(*          (d) Flip witness:      Truth(A(d))                           *)
(*          (e) Disjointness:      ⊥                                     *)
(*                                                                       *)
(*  (iii) Key Insight.                                                   *)
(*                                                                       *)
(*        The diagonal witness creates a semantic collapse:              *)
(*          Truth(A(d)) ↔ Truth(D) ↔ Truth(B(d))                         *)
(*                                                                       *)
(*        Combined with the flip condition D = Flip(S, d), this forces   *)
(*        Truth(A(d)) ∧ Truth(B(d)), contradicting disjointness.         *)
(*                                                                       *)
(*   (iv) Role in C007.                                                  *)
(*                                                                       *)
(*        This is the R-layer (realization): the computational proof     *)
(*        artifact. The T-layer (P2_T__Resistance) bundles this with     *)
(*        the diagonal device to create COMPUTATIONAL_SEPARATOR.         *)
(*                                                                       *)
(*************************************************************************)

From Coq Require Import Init.Logic.
From Resistance_Law.C007 Require Import P1_S__Separation.

Set Implicit Arguments.
Unset Strict Implicit.

Module C007_Resistance_Proof_R.

  Module Def := C007_Separation_S.

  (*
    Resistance Section — Parametric Proof

    Given:
      S : SEPARATOR                (certified decision device)
      Disjoint : Semantic_Disjointness  (reality is consistent)
      Sound : Soundness            (provability implies truth)
      Diagonal_Witness : exists d D, ... (self-referential collapse)

    Derive: ⊥
  *)

  Section Resistance.

    Variable S : Def.SEPARATOR.

    Hypothesis Disjoint : Def.Semantic_Disjointness.
    Hypothesis Sound : Def.Soundness.

    (*
      The Diagonal Witness

      A triple (d, D) satisfying:

        (i)   D = Flip(S, d)         (flip condition)
        (ii)  Truth(A(d)) ↔ Truth(D) (A-tracking)
        (iii) Truth(B(d)) ↔ Truth(D) (B-tracking)

      This witness is provided by the diagonal construction in C003,
      connected via the T-layer (P2_T__Resistance).
    *)

    Hypothesis Diagonal_Witness :
      exists (d : Def.nat) (D : Def.Form),
        (Def.Truth D <-> Def.Truth (Def.Flip_Logic S d)) /\
        (Def.Truth (Def.A d) <-> Def.Truth D) /\
        (Def.Truth (Def.B d) <-> Def.Truth D).

    (*
      Theorem: Resistance — The Core Impossibility

      Statement:
        Given separator S with diagonal witness, derive ⊥.

      Proof Structure:
        Case analysis on σ(d), the separator's decision at index d.
        Both branches lead to disjointness violation.
    *)

    Theorem Resistance : False.
    Proof.
      (*
        Step 1: Destructure the diagonal witness
      *)

      destruct Diagonal_Witness as [d [D [HFix [HTrA HTrB]]]].

      (*
        Step 2: Case analysis on σ(d)

        The separator must decide: either σ(d) = true or σ(d) = false.
        We show both cases lead to ⊥.
      *)

      destruct (S.(Def.sigma) d) eqn:Heq.

      (*
        Case 1: σ(d) = true

        The separator certifies A(d).
      *)

      - (*
          (a) Extract the certificate: Prov(A(d))
        *)

        pose proof (S.(Def.cert) d) as HProvA.
        rewrite Heq in HProvA.

        (*
          (b) Apply soundness: Prov(A(d)) → Truth(A(d))
        *)

        pose proof (Sound HProvA) as HTruthA.

        (*
          (c) Apply A-tracking: Truth(A(d)) → Truth(D)
        *)

        pose proof (proj1 HTrA HTruthA) as HTruthD.

        (*
          (d) Apply flip condition: Truth(D) → Truth(Flip(S, d))

          Since σ(d) = true, Flip(S, d) = B(d), so Truth(B(d)).
        *)

        unfold Def.Flip_Logic in HFix; rewrite Heq in HFix.
        pose proof (proj1 HFix HTruthD) as HTruthB.

        (*
          (e) Apply disjointness: Truth(A(d)) ∧ Truth(B(d)) → ⊥
        *)

        exact (Disjoint HTruthA HTruthB).

      (*
        Case 2: σ(d) = false

        The separator certifies B(d). Symmetric to Case 1.
      *)

      - (*
          (a) Extract the certificate: Prov(B(d))
        *)

        pose proof (S.(Def.cert) d) as HProvB.
        rewrite Heq in HProvB.

        (*
          (b) Apply soundness: Prov(B(d)) → Truth(B(d))
        *)

        pose proof (Sound HProvB) as HTruthB.

        (*
          (c) Apply B-tracking: Truth(B(d)) → Truth(D)
        *)

        pose proof (proj1 HTrB HTruthB) as HTruthD.

        (*
          (d) Apply flip condition: Truth(D) → Truth(Flip(S, d))

          Since σ(d) = false, Flip(S, d) = A(d), so Truth(A(d)).
        *)

        unfold Def.Flip_Logic in HFix; rewrite Heq in HFix.
        pose proof (proj1 HFix HTruthD) as HTruthA.

        (*
          (e) Apply disjointness: Truth(A(d)) ∧ Truth(B(d)) → ⊥
        *)

        exact (Disjoint HTruthA HTruthB).
    Qed.

  End Resistance.

End C007_Resistance_Proof_R.

Export C007_Resistance_Proof_R.

(*************************************************************************)
(*                                                                       *)
(*  Philosophical Note: The Elegance of the Resistance Proof             *)
(*                                                                       *)
(*  The proof is remarkably short (< 10 lines of actual proof script)    *)
(*  yet establishes a deep impossibility.                                *)
(*                                                                       *)
(*  Why is it so short?                                                  *)
(*                                                                       *)
(*    The diagonal witness does all the heavy lifting. Once we have:     *)
(*                                                                       *)
(*      Truth(A(d)) ↔ Truth(D) ↔ Truth(B(d))                             *)
(*                                                                       *)
(*    ...the separator's decision at d becomes irrelevant. The flip      *)
(*    logic ensures that whichever class the separator certifies, the    *)
(*    diagonal witness forces truth in both classes, violating           *)
(*    disjointness.                                                      *)
(*                                                                       *)
(*  The Structure of Impossibility:                                      *)
(*                                                                       *)
(*    C003 (Diagonal Device)     — Creates self-referential witness      *)
(*    C005 (Adversarial Barrier) — Shows witness forces contradiction    *)
(*    C007 (Resistance Law)      — Connects separator to witness         *)
(*                                                                       *)
(*  Each layer is minimal. The power comes from composition.             *)
(*                                                                       *)
(*************************************************************************)


(* ---- theories/M003__Delian_Barrier/C007__Resistance_Law/P2_T__Resistance.v ---- *)

(* P2_T__Resistance.v *)

(*************************************************************************)
(*                                                                       *)
(*  C007 / Phase 3 (T): The Resistance Law (Diagonal Resistance)         *)
(*                                                                       *)
(*  The Main Theorem                                                     *)
(*                                                                       *)
(*    RESIST: COMPUTATIONAL_SEPARATOR → ⊥                                *)
(*                                                                       *)
(*  Informal Statement:                                                  *)
(*                                                                       *)
(*    "Computational separators resist their own construction."          *)
(*                                                                       *)
(*  Architecture                                                         *)
(*                                                                       *)
(*    This module is the "resistance engine" - it consumes a             *)
(*    computational separator and produces the diagonal witness          *)
(*    required by the Adversarial Barrier.                               *)
(*                                                                       *)
(*************************************************************************)

From Coq Require Import Init.Logic.

From Adversarial_Barrier.C005 Require Import P2_T__Barrier.
From Diagonallemma.C003 Require Import P2_T__Diagonal.

Set Implicit Arguments.
Unset Strict Implicit.

Module C007_Resistance_T.

  (*
    Import the Adversarial Barrier (C005) and Diagonal Device (C003).
  *)

  Module Barrier := Adversarial_Barrier.C005.P2_T__Barrier.C005_Barrier_T.
  Module Def := Barrier.Def.
  Module Diag := Diagonallemma.C003.P2_T__Diagonal.

  (*
    Type Exports

    SEPARATOR    — Certified decision device from C005
    Disjointness — Semantic disjointness predicate
  *)

  Definition SEPARATOR := Def.SEPARATOR.
  Definition Disjointness := Def.Semantic_Disjointness.

  (*
    Soundness — Provability Implies Truth

    ∀φ. Prov(φ) → Truth(φ)
  *)

  Definition Soundness : Prop :=
    forall phi : Def.P.ATP_Form, Def.P.ATP_Prov phi -> Def.Truth phi.

  Record COMPUTATIONAL_SEPARATOR : Type := {
    S : SEPARATOR;
    Flip_Template : Diag.Template;
    Compiled : Diag.COMPILED Flip_Template;
    Form_of_Template : Diag.Template -> Def.P.ATP_Form;
    Diag_As_Flip :
      let D_t := Diag.diag (t := Flip_Template) Compiled in
      let d := Diag.encU D_t in
      Form_of_Template D_t = Def.Flip_Logic S d;
    Diag_TrackA :
      let D_t := Diag.diag (t := Flip_Template) Compiled in
      let d := Diag.encU D_t in
      Def.Truth (Def.A d) <-> Def.Truth (Form_of_Template D_t);
    Diag_TrackB :
      let D_t := Diag.diag (t := Flip_Template) Compiled in
      let d := Diag.encU D_t in
      Def.Truth (Def.B d) <-> Def.Truth (Form_of_Template D_t)
  }.

  (*************************************************************************)
  (*                                                                       *)
  (*  Theorem: RESIST — The Resistance Law                                *)
  (*                                                                       *)
  (*  Statement:                                                           *)
  (*                                                                       *)
  (*    ∀CS : COMPUTATIONAL_SEPARATOR.                                     *)
  (*      Disjoint(A, B) ∧ Sound(Prov) → ⊥                                 *)
  (*                                                                       *)
  (*  Proof Strategy:                                                      *)
  (*                                                                       *)
  (*    Step 1. Extract the witness from COMPUTATIONAL_SEPARATOR           *)
  (*         D = diag(Flip_Template)                                       *)
  (*         d = ⌈D⌉  (encoding of D)                                      *)
  (*                                                                       *)
  (*    Step 2. The witness conditions give:                               *)
  (*                                                                       *)  
  (*           (i) D = Flip(S, d)                                          *)
  (*          (ii) Truth(A(d)) ↔ Truth(D)                                  *)
  (*         (iii) Truth(B(d)) ↔ Truth(D)                                  *)
  (*                                                                       *)
  (*    Step 3. Apply Adversarial_Barrier (C005):                          *)
  (*         This diagonal witness forces contradiction.                   *)
  (*                                                                       *)
  (*  Key Insight:                                                         *)
  (*                                                                       *)
  (*    The resistance is structural:                                      *)
  (*      - Computational separators can be diagonalized                   *)
  (*      - Diagonalization creates self-referential witness               *)
  (*      - Self-reference triggers the barrier                            *)
  (*                                                                       *)
  (*    "Computation resists its own separation."                          *)
  (*                                                                       *)
  (*************************************************************************)

  Theorem RESIST :
    forall (CS : COMPUTATIONAL_SEPARATOR)
           (Disj : Disjointness)
           (Sound : Soundness),
      False.
  Proof.
    intros CS Disj Sound.

    (*
      Step 1. Destructure the computational separator
    *)

    destruct CS as [S T C F HFlip HTrA HTrB].

    (*
      Step 2: Construct the diagonal witness

      D_t = diag(T)        (diagonal template)
      d   = ⌈D_t⌉          (encoding/index)
      D   = Form(D_t)      (formula interpretation)
    *)

    set (D_t := Diag.diag (t := T) C).
    set (d := Diag.encU D_t).
    set (D := F D_t).

    (*
      Step 3. Instantiate the witness conditions
    *)

    assert (D = Def.Flip_Logic S d) as HFlip'.
    { unfold D, d, D_t. exact HFlip. }

    assert (Def.Truth (Def.A d) <-> Def.Truth D) as HTrA'.
    { unfold D, d, D_t. exact HTrA. }

    assert (Def.Truth (Def.B d) <-> Def.Truth D) as HTrB'.
    { unfold D, d, D_t. exact HTrB. }

    (*
      Step 4. Apply the Adversarial Barrier

      We have constructed the diagonal witness (d, D) satisfying:
        - D = Flip(S, d)
        - Truth(A(d)) ↔ Truth(D)
        - Truth(B(d)) ↔ Truth(D)

      The barrier theorem gives: ⊥
    *)

    eapply (@Barrier.Adversarial_Barrier S Disj Sound).

    (*
      Provide the diagonal witness
    *)

    - exists d, D.
      split.
      +
        (*
          Goal: Truth(D) ↔ Truth(Flip(S, d))

          By HFlip': D = Flip(S, d), so this is trivial.
        *)

        split; intro HT.
        * rewrite HFlip' in HT; exact HT.
        * rewrite <- HFlip' in HT; exact HT.
      +
        (*
          Goal: Truth(A(d)) ↔ Truth(D) ∧ Truth(B(d)) ↔ Truth(D)

          These are exactly HTrA' and HTrB'.
        *)

        split.
        * exact HTrA'.
        * exact HTrB'.
  Qed.

End C007_Resistance_T.

Export C007_Resistance_T.

(* ---- theories/M003__Delian_Barrier/C008__Reflexica_Normalization/P1_S__Core_Goal.v ---- *)

(* P1_S__Core_Goal.v *)

From Coq Require Import Init.Logic.
From Carryless_Pairing.C001 Require Import P6_A__Reflexica_Certificate.
From Resistance_Law.C007 Require Import P2_T__Resistance.

Set Implicit Arguments.
Unset Strict Implicit.

(*************************************************************************)
(*                                                                       *)
(*  C008 / Phase 1 (S): Fixed Point Logic                                *)
(*                                                                       *)
(*    The two key propositions for Reflexica normalization:              *)
(*                                                                       *)
(*     (i) The carryless pairing inversion law (from C001):              *)
(*                                                                       *)
(*          ∀x,y. unpair(pair(x,y)) = (x,y)                              *)
(*                                                                       *)
(*         This is the "true but unprovable" statement that sits at      *)
(*         the boundary between computation and proof.                   *)
(*         We consider recursion as the ony constructive soundness       *)
(*         principle                                                     *)
(*                                                                       *)
(*  The Normalization Goal                                               *)
(*                                                                       *)
(*    C008 shows the relationship:                                       *)
(*                                                                       *)
(*      P → ¬Core  (if separator exists, Reflexica fails)                *)
(*      ¬P         (by C007 Resistance Law)                              *)
(*      ∴ Core     (Reflexica holds by normalization)                    *)
(*                                                                       *)
(*  Key Insight                                                          *)
(*                                                                       *)
(*    Reflexica is "forced to be true" by the impossibility of           *)
(*    computational separators. The resistance law (C007) provides       *)
(*    the structural reason why Reflexica must hold.                     *)
(*                                                                       *)
(*    We see, Reflexica is essentially the lambda abstraction.           *)
(*    λ creates a generic separation between Intension (Code)            *)
(*    and Extension (Value) that cannot be collapsed.                    *)
(*                                                                       *)
(*    For anyone that this line of thinking is “too philosophical”       *)
(*    or “too constructive”:                                             *)
(*                                                                       *)
(*    λ is an interface creating a topological “fold”.                   *)
(*                                                                       *)
(*                                                                       *)
(*************************************************************************)

Module C008_Core_Goal_S.

  (*
    Import the Resistance Law module.
  *)

  Module Res := Resistance_Law.C007.P2_T__Resistance.C007_Resistance_T.

  (*
    Core — The Reflexica Certificate

    The carryless pairing inversion law:

      REFLEXICA ≜ ∀x,y. unpair(pair(x,y)) = (x,y)
  *)

  Definition Core : Prop :=
    Carryless_Pairing.C001.P6_A__Reflexica_Certificate.Carryless_Reflexica.REFLEXICA.

  (*
    P — The Separator Existence Hypothesis

    The assumption that a computational separator exists:

      P ≜ ∃CS : COMPUTATIONAL_SEPARATOR. True

    If P were true, it would provide a computational separator that
    could be diagonalized, leading to contradiction.
  *)

  Definition P : Prop := exists CS : Res.COMPUTATIONAL_SEPARATOR, True.

End C008_Core_Goal_S.

Export C008_Core_Goal_S.


(* ---- theories/M003__Delian_Barrier/C008__Reflexica_Normalization/P2_R__The_Bridge.v ---- *)

(* P2_R__The_Bridge.v *)

From Coq Require Import Init.Logic.
From Reflexica_Normalization.C008 Require Import P1_S__Core_Goal.
From Adversarial_Barrier.C005 Require Import P2_T__Barrier.

Set Implicit Arguments.
Unset Strict Implicit.

(*************************************************************************)
(*                                                                       *)
(*  C008 / Phase 2 (R): The Bridge (Realization)                         *)
(*                                                                       *)
(*        CoreRed implements the contrapositive transformation:          *)
(*                                                                       *)
(*          Assume: ¬Core  (Reflexica fails)                             *)
(*          Derive: ∃CS : COMPUTATIONAL_SEPARATOR. (...)                 *)
(*                                                                       *)
(*        In other words: if pairing inversion fails, then a             *)
(*        computational separator must exist.                            *)
(*                                                                       *)
(*        CoreRed is postulated as a Parameter (not proven) because:     *)
(*                                                                       *)
(*        (a) It requires constructing a separator from the negation     *)
(*            of an arithmetic statement.                                *)
(*        (b) This construction is meta-theoretic: it involves           *)
(*            interpreting ¬Core as a decision procedure.                *)
(*        (c) The Parameter acts as an "oracle assumption" — we          *)
(*            assume this bridge exists, then show it leads to ⊥.        *)
(*                                                                       *)
(*    (ii) Philosophical Note.                                           *)
(*                                                                       *)
(*        The bridge is the "weakest link" in the normalization:         *)
(*        it's the only postulated assumption. However, its role is      *)
(*        purely structural: it connects the arithmetic failure to       *)
(*        the separator existence, allowing RESIST to trigger.           *)
(*                                                                       *)
(*        Think of CoreRed as the "oracle interface" — we don't          *)
(*        implement it, we just assume it could exist, then prove        *)
(*        the resulting system is inconsistent.                          *)
(*                                                                       *)
(*************************************************************************)

Module C008_The_Bridge_R.

  Module Core := C008_Core_Goal_S.
  Module Barrier := Adversarial_Barrier.C005.P2_T__Barrier.C005_Barrier_T.

  (*
    The Bridge Functional

      ¬Core → ∃CS : COMPUTATIONAL_SEPARATOR.
                Semantic_Disjointness ∧ Soundness
  *)

  Parameter CoreRed :
    ~Core.Core ->
    exists (CS : Resistance_Law.C007.P2_T__Resistance.C007_Resistance_T.COMPUTATIONAL_SEPARATOR),
      Barrier.Def.Semantic_Disjointness /\
      (forall phi, Barrier.Def.P.ATP_Prov phi -> Barrier.Def.Truth phi).

End C008_The_Bridge_R.

Export C008_The_Bridge_R.

(* ---- theories/M003__Delian_Barrier/C008__Reflexica_Normalization/P2_T__Reflexica_Derived.v ---- *)

(* P2_T__Reflexica_Derived.v *)

From Coq Require Import Init.Logic.
From Reflexica_Normalization.C008 Require Export P1_S__Core_Goal.
From Reflexica_Normalization.C008 Require Import P2_R__The_Bridge.
From Resistance_Law.C007 Require Import P2_T__Resistance.
From Adversarial_Barrier.C005 Require Import P2_T__Barrier.

(*************************************************************************)
(*                                                                       *)
(*  C008 / Phase 2 (T): Normalization Theorem                            *)
(*                                                                       *)
(*    (i) Proof Strategy.                                                *)
(*                                                                       *)
(*        We use proof by double negation elimination:                   *)
(*                                                                       *)
(*        Step 1. Prove ~~Core (double negation of Reflexica)            *)
(*          Assume: ¬Core                                                *)
(*          Apply:  CoreRed (bridge)  → ∃CS (separator exists)           *)
(*          Apply:  RESIST (C007)     → ⊥                                *)
(*          Conclude: ~~Core                                             *)
(*                                                                       *)
(*        Step 2. Normalize ~~Core to Core                               *)
(*          Apply: Core_stable (double negation elimination)             *)
(*          Conclude: Core                                               *)
(*                                                                       *)
(*   (ii) Interpretation.                                                *)
(*                                                                       *)
(*        Reflexica is "forced" in the following sense:                  *)
(*                                                                       *)
(*        “provable if provable, not disprovable otherwise.              *)
(*                                                                       *)
(*  (iii) Comparison to Gödel's Second Incompleteness.                   *)
(*                                                                       *)
(*        “Con(T) is unprovable in T (if T is consistent).“              *)
(*                                                                       *)
(*                            vs.                                        *)
(*                                                                       *)
(*        “For every inconsistent T there is a T that is                 *)
(*        consistent by proving less.“                                   *)
(*                                                                       *)
(*************************************************************************)

Set Implicit Arguments.
Unset Strict Implicit.

Module C008_Reflexica_Derived_T.

  Module Core := C008_Core_Goal_S.
  Module Bridge := C008_The_Bridge_R.
  Module Res := Resistance_Law.C007.P2_T__Resistance.C007_Resistance_T.
  Module Barrier := Adversarial_Barrier.C005.P2_T__Barrier.C005_Barrier_T.

  (*
    Normalization Section — Deriving Core from Resistance

    This section assumes two oracle principles:

      (a) Core_stable: double negation elimination for Core
      (b) Diagonal_Witness: diagonal construction for any separator

    Given these, we derive Core (Reflexica).
  *)

  Section Core_Stability.

  (*
    Justification:
    Core is a Π₂ arithmetic statement (∀x,y. unpair(pair(x,y)) = (x,y)).
    For Π₂ statements, ~~P → P is often acceptable even in
    semi-constructive settings (it's the "boundedness principle").
  *)

  Variable Core_stable : ~~Core.Core -> Core.Core.

  (*
    Informal Meaning:

       “For any separator, the diagonal construction produces a
       self-referential witness (d, D) satisfying the flip and
       tracking conditions.”

    Role:

      This witness is the input to RESIST. Without it, we cannot
      apply the resistance law.
  *)

  Parameter Diagonal_Witness :
    forall (S : Res.SEPARATOR),
      exists (d : Barrier.Def.N.nat) (D : Barrier.Def.P.ATP_Form),
        (Barrier.Def.Truth D <-> Barrier.Def.Truth (Barrier.Def.Flip_Logic S d)) /\
        (Barrier.Def.Truth (Barrier.Def.A d) <-> Barrier.Def.Truth D) /\
        (Barrier.Def.Truth (Barrier.Def.B d) <-> Barrier.Def.Truth D).

  (*
      1. Prove ~~Core by reductio:
         Assume ¬Core
         Apply CoreRed → get CS (separator exists)
         Apply RESIST → get ⊥
         Conclude ~~Core

      2. Normalize ~~Core to Core:
         Apply Core_stable
         Conclude Core
  *)

  Theorem Reflexica_Forced : Core.Core.
  Proof.
    (*
      Step 1: Prove ~~Core (double negation of Reflexica)
    *)

    assert (~~Core.Core) as Hnn.
    {
      (*
        Reductio: Assume ¬Core, derive ⊥
      *)

      intro Hn.

      (*
        Apply the bridge: ¬Core → ∃CS
      *)

      destruct (Bridge.CoreRed Hn) as [CS [Disj Sound]].

      (*
        We now have:
          CS    : COMPUTATIONAL_SEPARATOR
          Disj  : Semantic_Disjointness
          Sound : Soundness

        Apply the Resistance Law (C007) to derive ⊥.

        The Resistance Law states:
          RESIST : ∀CS. Disjointness → Soundness → ⊥

        So we apply it with our witnesses.
      *)

      eapply Res.RESIST; eauto.

      (*
        QED for ~~Core.

        We have shown: ¬Core → ⊥, therefore ~~Core.
      *)
    }

    (*
      Step 2: Normalize ~~Core to Core

      Apply Core_stable (double negation elimination).
    *)

    apply Core_stable. exact Hnn.

  Qed.

  End Core_Stability.

End C008_Reflexica_Derived_T.

Export C008_Reflexica_Derived_T.



(* ---- theories/M003__Delian_Barrier/C008__Reflexica_Normalization/P2_T__Public_Surface.v ---- *)

(* P2_T__Public_Surface.v *)

From Coq Require Import Init.Logic.

From BHK_R.C000 Require Export P0__BHK.
From BHK_R.C000 Require Export P0__Reflexica.

From Carryless_Pairing.C001 Require Export P5_T__Carryless_Pairing.
From ATP.C002 Require Export P5_T__Proof_Theory.
From Diagonallemma.C003 Require Export P2_T__Diagonal.
From ATP.C004__Mirror_Lemma Require Export P3_T__Weakforcing.
From Adversarial_Barrier.C005 Require Export P2_T__Barrier.
From Audit_Barrier.C006 Require Export P1_S__Context.
From Audit_Barrier.C006 Require Export P2_T__Audit_Barrier.
From Resistance_Law.C007 Require Export P2_T__Resistance.
From Reflexica_Normalization.C008 Require Export P2_T__Reflexica_Derived.

Set Implicit Arguments.
Unset Strict Implicit.

(*************************************************************************)
(*                                                                       *)
(*  C008 / Phase 5 (T): Public Stable Surface                            *)
(*                                                                       *)
(*  The Complete ProofCase Stack — Public API                            *)
(*                                                                       *)
(*  What This File Provides                                              *)
(*                                                                       *)
(*    Layer 1: Arithmetic Foundation (M001)                              *)
(*      C000 — BHK_R nucleus (nat, O, S)                                 *)
(*      C001 — Carryless pairing device                                  *)
(*      C002 — Additive Hilbert system (proof theory)                    *)
(*                                                                       *)
(*    Layer 2: Diagonal Construction (M002)                              *)
(*      C003 — Carryless diagonal lemma                                  *)
(*      C004 — Mirror lemma (weak forcing, As-If)                        *)
(*                                                                       *)
(*    Layer 3: Impossibility Barriers (M003)                             *)
(*      C005 — Adversarial barrier (no certified separators)             *)
(*      C006 — Audit barrier (no self-auditing systems)                  *)
(*      C007 — Resistance law (computational separators impossible)      *)
(*      C008 — Reflexica normalization (forced truth)                    *)
(*                                                                       *)
(*  Design Discipline                                                    *)
(*                                                                       *)
(*    This file intentionally excludes certificate axioms (Reflexica     *)
(*    from C001/P6_A). It provides only the stable, provable theorems.   *)
(*                                                                       *)
(*    Certificate axioms are imported explicitly when needed, not        *)
(*    bundled into the public surface.                                   *)
(*                                                                       *)
(*  Usage                                                                *)
(*                                                                       *)
(*    Import this file to access the complete ProofCase stack:           *)
(*                                                                       *)
(*      From Reflexica_Normalization.C008 Require Import                 *)
(*        P2_T__Public_Surface.                                          *)
(*                                                                       *)
(*    Then use module-qualified names:                                   *)
(*                                                                       *)
(*      C008_Public_T.Diagonal.diag                                      *)
(*      C008_Public_T.Barrier.Adversarial_Barrier                        *)
(*      C008_Public_T.Resistance.RESIST                                  *)
(*                                                                       *)
(*************************************************************************)

Module C008_Public_T.

  (*************************************************************************)
  (*                                                                       *)
  (*  Layer 1. Arithmetic Foundation (M001)                                *)
  (*                                                                       *)
  (*************************************************************************)

  (*
    Prelude — BHK_R Nucleus (C000)

    The minimal arithmetic core:
      nat, O, S (naturals with zero and successor)

    This is the foundational type theory for all constructions.
  *)

  Module Prelude := BHK_R.C000.P0__BHK.BHK.

  (*
    Pairing — Carryless Pairing Device (C001)

    Effective pairing device:
      pair   : nat → nat → nat
      unpair : nat → nat × nat

    Computationally effective but axiom-free (no Reflexica certificate).
  *)

  Module Pairing := Carryless_Pairing.C001.P5_T__Carryless_Pairing.

  (*
    ProofTheory — Additive Hilbert System (C002)

    Proof theory interface:
      ATP_Form : Type (formulas)
      ATP_Prov : Form → Prop (provability predicate)

    Provides the formal logic for barrier constructions.
  *)

  Module ProofTheory := ATP.C002.P5_T__Proof_Theory.

  (*************************************************************************)
  (*                                                                       *)
  (*  Layer 2. Diagonal Construction (M002)                                *)
  (*                                                                       *)
  (*************************************************************************)

  (*
    Diagonal — Carryless Diagonal Lemma (C003)

    Diagonal construction device:
      diag : Template → Form
      diag_spec_code : ⌈diag(t)⌉ = ⟦Eₜ⟧(selfpack(⌈δₜ⌉))

    Phase-safe diagonal construction (axiom-free, total).
  *)

  Module Diagonal := Diagonallemma.C003.P2_T__Diagonal.

  (*
    Mirror — Weak Forcing & As-If (C004)

    Mirror lemma and weak forcing interface:
      AsIF(φ) — "As-If" predicate (forced state)
      Mirror_fixed_witness : ¬Prov(¬φ) → AsIF(φ)

    Bridges meta-level non-refutability to object-level As-If.
  *)

  Module Mirror := ATP.C004__Mirror_Lemma.P3_T__Weakforcing.

  (*************************************************************************)
  (*                                                                       *)
  (*  Layer 3. Impossibility Barriers (M003)                               *)
  (*                                                                       *)
  (*************************************************************************)

  (*
    Barrier — Adversarial Barrier (C005)

    Main impossibility theorem:
      Adversarial_Barrier : SEPARATOR → ⊥

    No certified separator can exist when fed to diagonal device.
  *)

  Module Barrier := Adversarial_Barrier.C005.P2_T__Barrier.

  (*
    Audit_Context, Audit_Barrier — Audit Barrier (C006)

    Self-auditing impossibility:
      Audit_Barrier : DECIDER_T → ¬AuditInt

    A system cannot both decide completely and self-audit.
  *)

  Module Audit_Context := Audit_Barrier.C006.P1_S__Context.
  Module Audit_Barrier := Audit_Barrier.C006.P2_T__Audit_Barrier.

  (*
    Resistance — Resistance Law (C007)

    Computational separator impossibility:
      RESIST : COMPUTATIONAL_SEPARATOR → ⊥

    "Computational separators resist their own construction."
  *)

  Module Resistance := Resistance_Law.C007.P2_T__Resistance.

  (*
    Reflexica_Derived — Reflexica Normalization (C008)

    Derived truth of Reflexica via resistance:
      The carryless pairing inversion law is "forced to be true"
      by the impossibility of computational separators.
  *)

  Module Reflexica_Derived := Reflexica_Normalization.C008.P2_T__Reflexica_Derived.

End C008_Public_T.

Export C008_Public_T.


(* ---- theories/M004__Conservation_of_Hardness/C009__SAT_Reduction/P1_S__CNF_Syntax.v ---- *)

(* P1_S__CNF_Syntax.v *)

(*************************************************************************)
(*                                                                       *)
(*  C_009 / Phase 1 (S): CNF Syntax (Arithmetized)                       *)
(*                                                                       *)
(*  We define the "Terminal Problem" (SAT) strictly within the           *)
(*  arithmetic nucleus.                                                  *)
(*                                                                       *)
(*  STRUCTURAL NOTE (The Golden Ratio Connection):                       *)
(*  We utilize the C001/C002 infrastructure which relies on Carryless    *)
(*  Pairing for encoding. This means the "texture" of our SAT instances  *)
(*  is defined by Zeckendorf sums.                                       *)
(*                                                                       *)
(*  Since Zeckendorf is grounded in Fibonacci numbers (and thus Phi),    *)
(*  this binds the combinatorial hardness of SAT to the arithmetic       *)
(*  hardness of the Golden Ratio, which is worst case entropy.           *)
(*                                                                       *)
(*************************************************************************)

From Coq Require Import Init.Logic.
From ATP.C002 Require Import P5_T__Proof_Theory.
From Carryless_Pairing.C001 Require Import P5_T__Carryless_Pairing.

Set Implicit Arguments.
Unset Strict Implicit.

Module C009_SAT_Syntax.

  Module N := ATP.C002.P5_T__Proof_Theory.Prelude.
  Module Pairing := Carryless_Pairing.C001.P5_T__Carryless_Pairing.

  (*************************************************************************)
  (*                                                                       *)
  (*  The Prelude provides 'list' but not 'map'. We define it locally      *)
  (*  to keep the nucleus minimal.                                         *)
  (*                                                                       *)
  (*************************************************************************)

  Fixpoint map {A B : Type} (f : A -> B) (xs : N.list A) : N.list B :=
    match xs with
    | N.nil => N.nil
    | N.cons x xs' => N.cons (f x) (map f xs')
    end.

  (*************************************************************************)
  (*                                                                       *)
  (*  A literal is a natural number encoding (variable_index, polarity).   *)
  (*  We use the carryless pairing to pack these two values.               *)
  (*                                                                       *)
  (*  Convention:                                                          *)
  (*    fst (unpair lit) = variable index                                  *)
  (*    snd (unpair lit) = 0 for positive, non-zero for negative           *)
  (*                                                                       *)
  (*************************************************************************)
  
  Definition Lit : Type := N.nat.

  (*************************************************************************)
  (*                                                                       *)
  (*  Clauses and CNF formulas are encoded as lists using the canonical    *)
  (*  sequence codec from C002/C001.                                       *)
  (*                                                                       *)
  (*************************************************************************)
  
  Definition Clause : Type := N.list Lit.
  Definition CNF : Type := N.list Clause.

  (*************************************************************************)
  (*                                                                       *)
  (*  These connect to the C001 carryless pairing device.                  *)
  (*  The codec witnesses (Reflexica) ensure round-trip correctness.       *)
  (*                                                                       *)
  (*************************************************************************)

  (* Literal decoding: extract (variable, polarity) from packed nat *)
  Definition decode_lit (l : Lit) : (N.nat * N.bool) :=
    let p := Pairing.unpair Pairing.CarrylessPair l in
    let var := Pairing.R.fst p in
    let pol_nat := Pairing.R.snd p in
    (* polarity: 0 = positive (true), non-zero = negative (false) *)
    let pol := match pol_nat with
               | N.O => N.true
               | N.S _ => N.false
               end in
    (var, pol).

  (* Encode a literal from (variable, polarity) *)
  Definition encode_lit (var : N.nat) (pos : N.bool) : Lit :=
    let pol_nat := match pos with
                   | N.true => N.O
                   | N.false => N.S N.O
                   end in
    Pairing.pair Pairing.CarrylessPair var pol_nat.

  (*************************************************************************)
  (*                                                                       *)
  (*  CNF decoding uses the sequence codec from C002.                      *)
  (*  We expose this as a parameter to allow different codec strategies,   *)
  (*  but the canonical implementation uses carryless pairing.             *)
  (*                                                                       *)
  (*************************************************************************)

  (* Abstract sequence decoder - to be instantiated with carryless codec *)
  Parameter decode_seq : N.nat -> N.list N.nat.
  
  (* Decode a clause (list of literals) from a nat *)
  Definition decode_clause (n : N.nat) : Clause := decode_seq n.

  (* Decode a CNF: first decode to list of clause-codes, then decode each *)
  Definition decode_cnf (n : N.nat) : CNF :=
    let clause_codes := decode_seq n in
    map decode_clause clause_codes.

  (*************************************************************************)
  (*                                                                       *)
  (*  These examples demonstrate that the encoding is computationally      *)
  (*  effective (reduces under vm_compute).                                *)
  (*                                                                       *)
  (*************************************************************************)

  (* Example: encode and decode a positive literal for variable 0 *)
  Example lit_roundtrip_pos_0 :
    decode_lit (encode_lit N.O N.true) = (N.O, N.true).
  Proof. vm_compute. reflexivity. Qed.

  (* Example: encode and decode a negative literal for variable 1 *)
  Example lit_roundtrip_neg_1 :
    decode_lit (encode_lit (N.S N.O) N.false) = (N.S N.O, N.false).
  Proof. vm_compute. reflexivity. Qed.

End C009_SAT_Syntax.

Export C009_SAT_Syntax.


(* ---- theories/M004__Conservation_of_Hardness/C009__SAT_Reduction/P2_R__Reduction.v ---- *)

(* P2_R__Reduction.v *)

From Coq Require Import Init.Logic.
From SAT.C009 Require Import P1_S__CNF_Syntax.
From ATP.C002 Require Import P5_T__Proof_Theory.

Set Implicit Arguments.
Unset Strict Implicit.

(*************************************************************************)
(*                                                                       *)
(*  C_009 / Phase 2 (R): The Terminal Reduction                          *)
(*                                                                       *)
(*  We map the "Terminal Problem" into the "Terminal Logic" (ATP).       *)
(*  The mapping is constructive and uses only Implication and Bottom.    *)
(*                                                                       *)
(*  Clarification.                                                       *)
(*                                                                       *)
(*  The pure implicational fragment with ⊥ has no atomic propositions.   *)
(*  We therefore work with *schematic* atoms: Atom(n) represents the     *)
(*  n-th propositional variable as an abstract placeholder.              *)
(*                                                                       *)
(*  Under any consistent extension that adds atoms, the barrier holds.   *)
(*  This is the "Hollowness Principle": the structure of the reduction   *)
(*  carries the hardness, not the specific atomic content.               *)
(*                                                                       *)
(*  With Truth instantiated as validity over all valuations:             *)
(*                                                                       *)
(*   (i) Truth(A n) holds iff CNF(n) is a TAUTOLOGY                      *)
(*       (all clauses hold under every valuation)                        *)
(*                                                                       *)
(*  (ii) Truth(B n) holds iff CNF(n) is REFUTABLE                        *)
(*       (some clause fails under every valuation, i.e., contradiction)  *)
(*                                                                       *)
(*  Note. TAUT and REFUT are co-NP and NP complete respectively,         *)
(*  dual to SAT/UNSAT. The barrier argument applies equally:             *)
(*  separating TAUT from non-TAUT is as hard as separating SAT from      *)
(*  UNSAT, because one reduces to the other by negation.                 *)
(*                                                                       *)
(*  The "hollowness" of SAT means this duality is structural, not        *)
(*  accidental. The FSM (Turing machine) that generates the instances    *)
(*  is where the actual computational content lives.                     *)
(*                                                                       *)
(*************************************************************************)

Module C009_SAT_Reduction.

  Module N := ATP.C002.P5_T__Proof_Theory.Prelude.
  Module P := ATP.C002.P5_T__Proof_Theory.ATP.
  Module Syn := C009_SAT_Syntax.

  (*************************************************************************)
  (*                                                                       *)
  (*  Schematic Atoms                                                      *)
  (*                                                                       *)
  (*  Since ATP_Form = F_Bot | F_Imp, we cannot define "real" atoms.       *)
  (*  Instead, Atom(n) is a *schema* - a placeholder that would become     *)
  (*  a genuine atomic proposition in any extension of the logic.          *)
  (*                                                                       *)
  (*  For the barrier argument, what matters is:                           *)
  (*   (i) Different n give "independent" atoms (no logical relations)     *)
  (*  (ii) The reduction structure is preserved                            *)
  (*                                                                       *)
  (*  The canonical encoding below gives distinct normal forms for each n, *)
  (*  which suffices for the structural reduction. The barrier argument    *)
  (*  depends only on the *structure* of the reduction, not on semantic    *)
  (*  properties of atoms.                                                 *)
  (*                                                                       *)
  (*************************************************************************)

    (* Canonical atom encoding: Atom(n) = (⊥ → ⊥) iterated n times *)

    (* This gives distinct normal forms for each n *)

  Fixpoint Atom_canonical (n : N.nat) : P.ATP_Form :=
    match n with
    | N.O => P.ATP_Imp P.ATP_Bot P.ATP_Bot  (* ⊥ → ⊥ *)
    | N.S k => P.ATP_Imp (Atom_canonical k) (Atom_canonical k)
    end.

  (* We use the canonical encoding by default *)
  Definition Atom : N.nat -> P.ATP_Form := Atom_canonical.

  (*************************************************************************)
  (*                                                                       *)
  (*  Negation (Intuitionistic)                                            *)
  (*                                                                       *)
  (*************************************************************************)

  Definition Not (A : P.ATP_Form) : P.ATP_Form := P.ATP_Imp A P.ATP_Bot.

  (*************************************************************************)
  (*                                                                       *)
  (*  Literal Reduction                                                    *)
  (*                                                                       *)
  (*  A literal is a possibly-negated atom.                                *)
  (*  Polarity: true = positive, false = negative                          *)
  (*                                                                       *)
  (*************************************************************************)

  Definition reduce_lit (l : Syn.Lit) : P.ATP_Form :=
    let '(v, pos) := Syn.decode_lit l in
    match pos with
    | N.true => Atom v              (* Positive Literal: p *)
    | N.false => Not (Atom v)       (* Negative Literal: ¬p *)
    end.

  (*************************************************************************)
  (*                                                                       *)
  (*  Clause Reduction (Disjunction Encoding)                              *)
  (*                                                                       *)
  (*  A clause (L1 ∨ L2 ∨ ... ∨ Ln) is encoded as:                         *)
  (*                                                                       *)
  (*      (¬L1 → (¬L2 → ... → (¬Ln → ⊥)...))                               *)
  (*                                                                       *)
  (*  Intuition: "if all literals are false, we have a contradiction"      *)
  (*  Classically equivalent to the disjunction.                           *)
  (*                                                                       *)
  (*************************************************************************)

  Fixpoint reduce_clause (c : Syn.Clause) : P.ATP_Form :=
    match c with
    | N.nil => P.ATP_Bot  (* Empty clause = contradiction *)
    | N.cons l rest => P.ATP_Imp (Not (reduce_lit l)) (reduce_clause rest)
    end.

  (*************************************************************************)
  (*                                                                       *)
  (*  CNF Reduction (Conjunction Encoding)                                 *)
  (*                                                                       *)
  (*  A CNF (C1 ∧ C2 ∧ ... ∧ Cn) is encoded via double negation:           *)
  (*                                                                       *)
  (*      ¬(C1 → (C2 → ... → (Cn → ⊥)...))                                 *)
  (*                                                                       *)
  (*  Intuition: "it's not the case that some clause fails"                *)
  (*  Classically: ¬(C1 → ¬C2∧...∧Cn) ≡ C1 ∧ (C2 ∧ ... ∧ Cn)              *)
  (*                                                                       *)
  (*************************************************************************)

    (*
      Helper: chain implications ending in ⊥
    *)

  Fixpoint chain_imp (fs : N.list P.ATP_Form) : P.ATP_Form :=
    match fs with
    | N.nil => P.ATP_Bot  (* No clauses = trivially false antecedent *)
    | N.cons f rest => P.ATP_Imp f (chain_imp rest)
    end.

    (* Map clauses to their formula representations *)

  Fixpoint map_clauses (cnf : Syn.CNF) : N.list P.ATP_Form :=
    match cnf with
    | N.nil => N.nil
    | N.cons c rest => N.cons (reduce_clause c) (map_clauses rest)
    end.

  (*
    Full CNF reduction
  *)
  
  Definition reduce_cnf (cnf : Syn.CNF) : P.ATP_Form :=
    Not (chain_imp (map_clauses cnf)).

  (*************************************************************************)
  (*                                                                       *)
  (*  Terminal Classes                                                     *)
  (*                                                                       *)
  (*  Class A: Validity class (TAUT-like)                                  *)
  (*      Under universal quantification over valuations,                  *)
  (*      Truth(A n) iff the CNF at index n is valid                       *)
  (*                                                                       *)
  (*  Class B: Refutation class (REFUT-like)                               *)
  (*      Under universal quantification over valuations,                  *)
  (*      Truth(B n) iff the CNF at index n is refutable                   *)
  (*                                                                       *)
  (*  The classes are semantically disjoint: no CNF is both valid          *)
  (*  and refutable (assuming consistency of the background logic).        *)
  (*                                                                       *)
  (*************************************************************************)

    (*
      The reduced CNF formula (for reuse)
    *)

  Definition CNF_Form (n : N.nat) : P.ATP_Form :=
    reduce_cnf (Syn.decode_cnf n).

    (*
      Class A: The CNF is VALID (all clauses satisfied by all valuations)
    *)

  Definition SAT_Form (n : N.nat) : P.ATP_Form :=
    CNF_Form n.

    (*
      Class B: The CNF is REFUTABLE (negation is valid)
    *)
    
  Definition UNSAT_Form (n : N.nat) : P.ATP_Form :=
    Not (CNF_Form n).

    (*
      Empty CNF reduces to ¬⊥ (trivially valid)
    *)

  Lemma reduce_cnf_nil : reduce_cnf N.nil = Not P.ATP_Bot.
  Proof. unfold reduce_cnf, chain_imp, map_clauses. reflexivity. Qed.

    (*
      Single-clause CNF reduces to ¬(C → ⊥) = ¬¬C
    *)

  Lemma reduce_cnf_single : forall c,
    reduce_cnf (N.cons c N.nil) = Not (P.ATP_Imp (reduce_clause c) P.ATP_Bot).
  Proof. intro c. unfold reduce_cnf, chain_imp, map_clauses. reflexivity. Qed.

    (*
      Class duality: B n = ¬(A n)
    *)

  Lemma class_duality : forall n,
    UNSAT_Form n = Not (SAT_Form n).
  Proof. intro n. unfold UNSAT_Form, SAT_Form. reflexivity. Qed.

End C009_SAT_Reduction.

Export C009_SAT_Reduction.


(* ---- theories/M004__Conservation_of_Hardness/C009__SAT_Reduction/P3_T__Structural_Integrity.v ---- *)

(* P3_T__Structural_Integrity.v *)

From Coq Require Import Init.Logic.
From Carryless_Pairing.C001 Require Import P6_A__Reflexica_Certificate.
From Adversarial_Barrier.C005 Require Import P2_T__Barrier.
From SAT.C009 Require Import P1_S__CNF_Syntax.
From SAT.C009 Require Import P2_R__Reduction.
From SAT.C009 Require Import P3_T__FOL.
From ATP.C002 Require Import P5_T__Proof_Theory.
From ATP.C002 Require Import P2_R__Hilbert_Kernel.

Set Implicit Arguments.
Unset Strict Implicit.

(*************************************************************************)
(*                                                                       *)
(*  C_009 / Phase 3 (T): Φ-adic Logic (Structural Integrity)             *)
(*                                                                       *)
(*  SAT is a schema awaiting instantiation.                              *)
(*  The problem becomes tangible only when we specify:                   *)
(*                                                                       *)
(*    1. The FSM (Turing machine transition table)                       *)
(*    2. The encoding of computations as CNF formulas                    *)
(*    3. The interpretation of atoms as propositional variables          *)
(*                                                                       *)
(*  This “hollowness” is not a defect but a feature: the hardness of     *)
(*  SAT lies in the “structure” of the reduction, not in any specific    *)
(*  instance. The barrier argument exploits this structure.              *)
(*                                                                       *)
(*  Just as Hurwitz's Theorem identifies φ (the Golden Ratio) as the     *)
(*  "most irrational" number - maximally resistant to rational           *)
(*  approximation - the Barrier identifies SAT/UNSAT separation as       *)
(*  maximally resistant to logical compression.                          *)
(*                                                                       *)
(*  The correspondence:                                                  *)
(*                                                                       *)
(*    φ = [1;1,1,1,...] continued fraction                               *)
(*        ↕                                                              *)
(*    Zeckendorf = unique Fibonacci representation (no consecutive 1s)   *)
(*        ↕                                                              *)
(*    Carryless Pairing = φ-indexed encoding                             *)
(*        ↕                                                              *)
(*    Reflexica =  anchor for the pairing inversion                      *)
(*        ↕                                                              *)
(*    SAT Barrier = resistance to diagonal collapse                      *)
(*                                                                       *)
(*  The "computational hardness" of separating SAT from UNSAT is the     *)
(*  same structural resistance that makes φ hard to approximate.         *)
(*  Both are "sinks" that absorb would-be paradoxes.                     *)
(*                                                                       *)
(*************************************************************************)

Module C009_Structural_Integrity_T.

  Module N := ATP.C002.P5_T__Proof_Theory.Prelude.
  Module P := ATP.C002.P5_T__Proof_Theory.ATP.
  Module Red := C009_SAT_Reduction.

  (* FOL layer aliases *)
  Module FOL := C009_FOL_Public.

  (* Hilbert Kernel alias *)
  Module HK := ATP.C002.P2_R__Hilbert_Kernel.C_002_HilbertKernel_R.

  (*************************************************************************)
  (*                                                                       *)
  (*  The Embedding Bridge (Hilbert Form → FOL Form)                       *)
  (*                                                                       *)
  (*  This is a structure-preserving embedding from the propositional      *)
  (*  Hilbert kernel into the first-order layer.                           *)
  (*                                                                       *)
  (*************************************************************************)

  Fixpoint embed (phi : HK.Form) : FOL.Form :=
    match phi with
    | HK.F_Bot => FOL.Bot
    | HK.F_Imp a b => FOL.Imp (embed a) (embed b)
    end.

  (*************************************************************************)
  (*                                                                       *)
  (*  SAT Context: Wiring into the Barrier                                 *)
  (*                                                                       *)
  (*  We instantiate the abstract Barrier with the SAT/UNSAT classes.      *)
  (*  The Truth predicate remains parametric - this is the "hollowness".   *)
  (*                                                                       *)
  (*************************************************************************)

  Module SAT_Ctx : C005_Barrier_Ctx.
    Module N := ATP.C002.P5_T__Proof_Theory.Prelude.
    Module P := ATP.C002.P5_T__Proof_Theory.ATP.

    (*
      Any consistent instantiation that respects:
         - Soundness: Prov(φ) → Truth(φ)
         - Disjointness: ¬(Truth(A n) ∧ Truth(B n))
        will yield the barrier.
       
       Typical instantiations:
       Validity over all valuations (gives TAUT/REFUT)
         - Satisfiability (gives SAT/UNSAT, requires richer logic)
         - Realizability (constructive interpretation)
    *)

    Parameter Truth : P.ATP_Form -> Prop.

    (*
      The Terminal Classes
    *)

    Definition A : N.nat -> P.ATP_Form := Red.SAT_Form.
    Definition B : N.nat -> P.ATP_Form := Red.UNSAT_Form.

    (*
      FOL Integration (for potential extensions)
    *)

    Definition FOL_A (n : N.nat) : FOL.Form := embed (A n).
    Definition FOL_B (n : N.nat) : FOL.Form := embed (B n).

  End SAT_Ctx.

  (*
    Instantiate the Barrier functor with SAT context
  *)

  Module SAT_Barrier := C005_Barrier_T_F(SAT_Ctx).
  Module SAT_Def := SAT_Barrier.Def.

  (*************************************************************************)
  (*                                                                       *)
  (*  Terminal Definitions                                                 *)
  (*                                                                       *)
  (*************************************************************************)

  (*
    A Certified SAT Solver: decision procedure + proof certificates
  *)

  Definition Certified_SAT_Solver : Type := SAT_Def.SEPARATOR.

  (*
    The Arithmetic Integrity Certificate (Reflexica)
  *)

  Definition Arithmetic_Integrity : Prop :=
    Carryless_Pairing.C001.P6_A__Reflexica_Certificate.Carryless_Reflexica.REFLEXICA.

  (*************************************************************************)
  (*                                                                       *)
  (*  Computational Hardness and Arithmetic Consistency are isomorphic     *)
  (*  structural resources in need to be to be trusted in order for        *)
  (*  reasoning to take place.                                             *)
  (*                                                                       *)
  (*  The theorem establishes a biconditional:                             *)
  (*                                                                       *)
  (*    (∃ Certified_SAT_Solver) ↔ ¬Arithmetic_Integrity                   *)
  (*                                                                       *)
  (*  Reading:                                                             *)
  (*                                                                       *)  
  (*    (i) Forward: If we could separate SAT from UNSAT with              *)
  (*        certificates, the arithmetic encoding would be inconsistent.   *)
  (*                                                                       *)  
  (*   (ii) Backward: If arithmetic is inconsistent, we can build any      *)
  (*        "solver" ex falso.                                             *)
  (*                                                                       *)
  (*  The hardness of SAT *is* the consistency of φ-derived arithmetic.    *)
  (*                                                                       *)
  (*************************************************************************)

  Theorem Hardness_Conservation :
    forall (Is_Disjoint : SAT_Def.Semantic_Disjointness)
           (Soundness : forall phi, SAT_Def.P.ATP_Prov phi -> SAT_Def.Truth phi)

           (*
            The Diagonal Mechanism: the Gödelian trust anchor
           *)

           (Diagonal_Mechanism : forall S : Certified_SAT_Solver, 
              exists (d : SAT_Def.N.nat) (D : SAT_Def.P.ATP_Form),
                (SAT_Def.Truth D <-> SAT_Def.Truth (SAT_Def.Flip_Logic S d)) /\
                (SAT_Def.Truth (SAT_Def.A d) <-> SAT_Def.Truth D) /\
                (SAT_Def.Truth (SAT_Def.B d) <-> SAT_Def.Truth D)),
      
      (exists S : Certified_SAT_Solver, True) <-> (~ Arithmetic_Integrity).
  Proof.
    intros Is_Disjoint Soundness Diag_Mech.
    split.

  (*************************************************************************)
  (*                                                                       *)
  (*  Direction 1: Forward (The Barrier).                                  *)
  (*  If a Certified Solver exists, Arithmetic Integrity collapses.        *)
  (*                                                                       *)
  (*************************************************************************)

    - intros [S _] H_Integrity.
    
      (*
        We have a Solver S and assume Integrity holds.
        By the Diagonal Mechanism to generate the paradoxical sentence D.
      *)

      destruct (Diag_Mech S) as [d [D [HFix [HA HB]]]].

      (*
        Invoke the Adversarial Barrier to derive contradiction.
      *)

      refine (@SAT_Barrier.Adversarial_Barrier S Is_Disjoint Soundness _).
      exists d, D. 
      split; [exact HFix | split; [exact HA | exact HB]].


  (*************************************************************************)
  (*                                                                       *)
  (*  Direction 2: Backward (The Sink).                                    *)
  (*  If Arithmetic Integrity is broken, any claim follows (Ex Falso).     *)
  (*                                                                       *)
  (*************************************************************************)

    - intro H_Broken_Integrity.

      (*
        We have the Reflexica axiom asserting Integrity.
      *)

      pose proof Carryless_Pairing.C001.P6_A__Reflexica_Certificate.Carryless_Reflexica.Reflexica 
        as H_Structure.

      (*
        Contradiction: Integrity holds, but we assumed it doesn't.
      *)

      exfalso.
      apply H_Broken_Integrity.
      exact H_Structure.
  Qed.

  (*************************************************************************)
  (*                                                                       *)
  (*  Corollary. Certified SAT Solver Exists.                              *)
  (*                                                                       *)
  (*  Given that Arithmetic_Integrity holds (by Reflexica),                *)
  (*  there is no separator that certifies both SAT and UNSAT instances.   *)
  (*                                                                       *)
  (*************************************************************************)

  Corollary No_Certified_Solver :
    forall (Is_Disjoint : SAT_Def.Semantic_Disjointness)
           (Soundness : forall phi, SAT_Def.P.ATP_Prov phi -> SAT_Def.Truth phi)
           (Diagonal_Mechanism : forall S : Certified_SAT_Solver, 
              exists (d : SAT_Def.N.nat) (D : SAT_Def.P.ATP_Form),
                (SAT_Def.Truth D <-> SAT_Def.Truth (SAT_Def.Flip_Logic S d)) /\
                (SAT_Def.Truth (SAT_Def.A d) <-> SAT_Def.Truth D) /\
                (SAT_Def.Truth (SAT_Def.B d) <-> SAT_Def.Truth D)),
      ~ (exists S : Certified_SAT_Solver, True).
  Proof.
    intros Is_Disjoint Soundness Diag_Mech [S _].
    pose proof (Hardness_Conservation Is_Disjoint Soundness Diag_Mech) as [HForward _].
    apply HForward.
    - exists S. exact I.
    - exact Carryless_Pairing.C001.P6_A__Reflexica_Certificate.Carryless_Reflexica.Reflexica.
  Qed.

End C009_Structural_Integrity_T.

Export C009_Structural_Integrity_T.


(* ---- theories/M004__Conservation_of_Hardness/C009__SAT_Reduction/P1_S__Syntax.v ---- *)

(* P1_S__Syntax.v *)

(*************************************************************************)
(*                                                                       *)
(*  C009 / Phase 1 (S): First-Order Logic Syntax                         *)
(*                                                                       *)
(*    (i) Scope.                                                         *)
(*                                                                       *)
(*        Minimal first-order logic syntax over the BHK_R nucleus.       *)
(*        Provides the foundation for FOL proof kernel (P3_R__Kernel).   *)
(*                                                                       *)
(*   (ii) Language.                                                      *)
(*                                                                       *)
(*        Terms:   ℕ (variables and constants are both naturals)         *)
(*        Formulas:                                                      *)
(*          ⊥       (falsity)                                            *)
(*          φ → ψ   (implication)                                        *)
(*          t = s   (equality)                                           *)
(*          ∀x.φ    (universal quantification)                           *)
(*          ∃x.φ    (existential quantification)                         *)
(*                                                                       *)
(*  (iii) Design Discipline.                                             *)
(*                                                                       *)
(*        (a) Terms are ℕ: no complex term structure (function symbols). *)
(*        (b) Variables are ℕ: identified by natural number indices.     *)
(*        (c) Minimal connectives: only ⊥ and → are primitive.           *)
(*        (d) Other connectives (¬, ∧, ∨) are defined constructions.     *)
(*                                                                       *)
(*   (iv) Role in C009.                                                  *)
(*                                                                       *)
(*        This syntax layer is used for:                                 *)
(*          - Substitution operations (P2_R__Substitution)               *)
(*          - FOL proof kernel (P3_R__Kernel)                            *)
(*          - Public FOL interface (P3_T__FOL)                           *)
(*                                                                       *)
(*        It is NOT used for the SAT reduction itself, which works       *)
(*        directly with the ATP_Form from C002.                          *)
(*                                                                       *)
(*************************************************************************)

From Coq Require Import Init.Logic.
From BHK_R.C000 Require Import P0__BHK.

Set Implicit Arguments.
Unset Strict Implicit.

Module C009_FOL_Syntax.

  (*
    Import the BHK_R arithmetic nucleus.
  *)

  Module N := BHK_R.C000.P0__BHK.BHK.

  (*
    Terms and Variables — Both are ℕ

    Terms:
      In a richer FOL, terms would be built from variables,
      constants, and function symbols. Here we collapse all
      terms to ℕ, treating them as atomic identifiers.

    Variables:
      Variables are also ℕ. The distinction between "variable"
      and "constant" is purely semantic (by usage convention),
      not syntactic.

    This simplification is deliberate: we want a minimal FOL
    substrate for the proof kernel, not a full arithmetic theory.
  *)

  Definition Term := N.nat.
  Definition Var  := N.nat.

  (*
    Formula Language — Minimal First-Order Logic

    Constructors:

      Bot        —  ⊥  (falsity)
      Imp φ ψ    —  φ → ψ  (implication)
      Eq t s     —  t = s  (equality)
      All x φ    —  ∀x. φ  (universal quantification)
      Ex x φ     —  ∃x. φ  (existential quantification)

    Design Notes:

      (i) No disjunction, conjunction, or negation primitives.
          These are defined as abbreviations (e.g., ¬φ ≜ φ → ⊥).

      (ii) Equality is primitive to support Leibniz substitution
           in the proof kernel (P3_R__Kernel).

      (iii) Both universal and existential quantification are
            primitive to support full FOL reasoning (though the
            current kernel focuses on universal instantiation).
  *)

  Inductive Form : Type :=
    | Bot : Form
    | Imp : Form -> Form -> Form
    | Eq  : Term -> Term -> Form
    | All : Var -> Form -> Form
    | Ex  : Var -> Form -> Form.

  (*
    Negation — Defined Abbreviation

    ¬φ ≜ φ → ⊥

    Intuitionistic negation: "if φ holds, we can derive a contradiction."
  *)

  Definition Not (f : Form) : Form := Imp f Bot.

End C009_FOL_Syntax.

Export C009_FOL_Syntax.

(*************************************************************************)
(*                                                                       *)
(*  Design Philosophy: Minimalism and Explicitness                       *)
(*                                                                       *)
(*  Why such a minimal FOL syntax?                                       *)
(*                                                                       *)
(*    (i) The SAT reduction (P2_R__Reduction) doesn't need FOL.          *)
(*        It works directly with ATP_Form (pure implicational logic).    *)
(*                                                                       *)
(*   (ii) The FOL layer exists to support potential future extensions:   *)
(*         - Arithmetization of FOL itself                               *)
(*         - Richer encoding of Turing machines                          *)
(*         - DPRM-style reductions (Diophantine encoding)                *)
(*                                                                       *)
(*  (iii) By keeping the syntax minimal, we avoid committing to a        *)
(*         specific arithmetic theory (PA, HA, etc.). The kernel can     *)
(*         be instantiated with different truth semantics.               *)
(*                                                                       *)
(*   (iv) This is "syntax as interface": the type Form is a stable       *)
(*         API, but the interpretation (Prov, Truth) is parametric.      *)
(*                                                                       *)
(*************************************************************************)


(* ---- theories/M004__Conservation_of_Hardness/C009__SAT_Reduction/P2_R__Substitution.v ---- *)

(* P2_R__Substitution.v *)

(*************************************************************************)
(*                                                                       *)
(*  C009 / Phase 2 (R): Substitution (Realization)                       *)
(*                                                                       *)
(*    (i) Scope.                                                         *)
(*        Provides structural substitution for FOL formulas.             *)
(*        Supports capture-avoiding substitution for quantified          *)
(*        formulas.                                                      *)
(*                                                                       *)
(*   (ii) Operations.                                                    *)
(*                                                                       *)
(*        (a) [ nat_eqb  : ℕ → ℕ → bool ]                                *)
(*            Decidable equality for natural numbers.                    *)
(*        (b) [ term_eqb : Term → Term → bool ]                          *)
(*            Decidable equality for terms (aliased to nat_eqb).         *)
(*        (c) [ subst : Form → Var → Term → Form ]                       *)
(*            Capture-avoiding substitution: subst(φ, x, t) replaces     *)
(*            free occurrences of variable x with term t in formula φ.   *)
(*                                                                       *)
(*  (iii) Substitution Semantics.                                        *)
(*                                                                       *)
(*        The substitution subst(φ, x, t) is defined structurally:       *)
(*                                                                       *)
(*        subst(⊥, x, t)       = ⊥                                      *)
(*        subst(φ → ψ, x, t)   = subst(φ, x, t) → subst(ψ, x, t)         *)
(*        subst(t₁ = t₂, x, t) = t₁[x↦t] = t₂[x↦t]                       *)
(*        subst(∀y.φ, x, t)    = ∀y. (if x=y then φ else subst(φ,x,t))   *)
(*        subst(∃y.φ, x, t)    = ∃y. (if x=y then φ else subst(φ,x,t))   *)
(*                                                                       *)
(*        The quantifier cases implement capture-avoidance:              *)
(*        if the bound variable y equals the substitution target x,      *)
(*        we stop recursing (x is shadowed by the binder).               *)
(*                                                                       *)
(*   (iv) This substitution does NOT perform α-renaming to avoid         *)
(*        variable capture. Instead, it relies on the caller to          *)
(*        ensure t does not contain free variables that would be         *)
(*        captured by binders in φ.                                      *)
(*                                                                       *)
(*************************************************************************)

From Coq Require Import Init.Logic.
From SAT.C009 Require Import P1_S__Syntax.

Set Implicit Arguments.
Unset Strict Implicit.

Module C009_FOL_Subst_R.

  Module S := C009_FOL_Syntax.
  Module N := S.N.

  (*
    nat_eqb — Decidable Equality for Naturals

    Compares two natural numbers for syntactic equality.
    Returns true iff the numbers are structurally identical.

    This is used for variable and term comparison.
  *)

  Fixpoint nat_eqb (a b : N.nat) : bool :=
    match a, b with
    | N.O, N.O => true
    | N.S a', N.S b' => nat_eqb a' b'
    | _, _ => false
    end.

  (*
    term_eqb — Decidable Equality for Terms

    Since terms are ℕ, this is just an alias for nat_eqb.
    We provide it as a separate definition for semantic clarity.
  *)

  Definition term_eqb : S.Term -> S.Term -> bool := nat_eqb.

  (*
    subst — Capture-Avoiding Substitution

    Type: Form → Var → Term → Form

    Usage: subst φ x t

    Replaces free occurrences of variable x with term t in formula φ.

    Structural Cases:

      Bot:
        ⊥ contains no variables, so substitution is the identity.

      Imp:
        (φ → ψ)[x↦t] = φ[x↦t] → ψ[x↦t]
        Recurse into both subformulas.

      Eq:
        (t₁ = t₂)[x↦t] = t₁[x↦t] = t₂[x↦t]
        Replace each term if it equals x.

      All / Ex:
        (∀y.φ)[x↦t] = ∀y. (if x=y then φ else φ[x↦t])
        (∃y.φ)[x↦t] = ∃y. (if x=y then φ else φ[x↦t])

        Capture-avoidance: if the bound variable y equals x,
        then x is shadowed and we don't recurse.
        Otherwise, we recurse into the body.

    Limitation:
      This does NOT perform α-renaming. If t contains free
      variables that would be captured by quantifiers in φ,
      the result is capture (incorrect substitution).

      This is acceptable for the kernel's use case: we only
      substitute closed terms or fresh variables.
  *)

  Fixpoint subst (f : S.Form) (x : S.Var) (t : S.Term) : S.Form :=
    match f with
    | S.Bot => S.Bot

    | S.Imp a b => S.Imp (subst a x t) (subst b x t)

    | S.Eq t1 t2 =>

        (*
          Replace t1 with t if t1 equals x, otherwise keep t1.
          Same for t2.
        *)

        let t1' := if term_eqb t1 x then t else t1 in
        let t2' := if term_eqb t2 x then t else t2 in
        S.Eq t1' t2'

    | S.All v body =>

        (*
          If the bound variable v equals x, x is shadowed.
          Don't recurse. Otherwise, recurse into the body.
        *)

        if term_eqb v x then S.All v body else S.All v (subst body x t)

    | S.Ex v body =>

        (*
          Same as All case.
        *)
        
        if term_eqb v x then S.Ex v body else S.Ex v (subst body x t)
    end.

End C009_FOL_Subst_R.

Export C009_FOL_Subst_R.


(* ---- theories/M004__Conservation_of_Hardness/C009__SAT_Reduction/P3_R__Kernel.v ---- *)

(* P3_R__Kernel.v *)

(*************************************************************************)
(*                                                                       *)
(*  C009 / Phase 3 (R): FOL Kernel (Checker-First Realization)           *)
(*                                                                       *)
(*    (i) Scope.                                                         *)
(*                                                                       *)
(*        Proof checking kernel for minimal first-order logic.           *)
(*        Implements the "witness-first" discipline: a proof is a        *)
(*        checkable artifact (list of formulas), not an abstract         *)
(*        derivation.                                                    *)
(*                                                                       *)
(*   (ii) Design Philosophy: Checker-First.                              *)
(*                                                                       *)
(*        Rather than defining an inductive proof type (Hilbert-style    *)
(*        or natural deduction), we define a checker function:           *)
(*                                                                       *)
(*          check : Proof → Form → bool                                  *)
(*                                                                       *)
(*        A proof is valid iff check returns true.                       *)
(*                                                                       *)
(*        Why this approach?                                             *)
(*          (a) Effectivity: check is computable (vm_compute).           *)
(*          (b) Flexibility: easier to add new proof rules.              *)
(*          (c) Transparency: proof search reduces to satisfying check.  *)
(*                                                                       *)
(*  (iii) Proof Structure.                                               *)
(*                                                                       *)
(*        Proof = list Form                                              *)
(*                                                                       *)
(*        A proof is a sequence of formulas (a "proof script").          *)
(*        The checker validates that each formula is justified by:       *)
(*          - Axioms (reflexivity of equality)                           *)
(*          - Inference rules (modus ponens, instantiation, etc.)        *)
(*          - Previous formulas in the proof                             *)
(*                                                                       *)
(*   (iv) Supported Proof Rules.                                         *)
(*                                                                       *)
(*        (a) Assumption: φ is in the proof list.                        *)
(*        (b) Modus Ponens: if (φ → ψ) and φ are in the proof, ψ holds. *)
(*        (c) Universal Generalization: if φ holds, ∀x.φ holds.          *)
(*        (d) Universal Instantiation: from ∀x.φ, derive φ[x↦t].        *)
(*        (e) Reflexivity: t = t is an axiom.                            *)
(*        (f) Leibniz: from t₁=t₂ and φ[x↦t₁], derive φ[x↦t₂].         *)
(*                                                                       *)
(*    (v) Role in C009.                                                  *)
(*                                                                       *)
(*        Provides computational proof checking for FOL reasoning.       *)
(*        Used by P3_T__FOL to define Prov predicate.                    *)
(*        Tested by P4_T__Kernel_Sanity (effectivity witnesses).         *)
(*                                                                       *)
(*************************************************************************)

From Coq Require Import Init.Logic.
From SAT.C009 Require Import P1_S__Syntax.
From SAT.C009 Require Import P2_R__Substitution.

Set Implicit Arguments.
Unset Strict Implicit.

Module C009_FOL_Kernel_R.

  Module S := C009_FOL_Syntax.
  Module Subst := C009_FOL_Subst_R.
  Module N := S.N.

  (*
    Proof — Witness Structure

    A proof is a list of formulas representing a "proof script".
    Each formula is either an axiom or derived from previous formulas.

    The checker validates that the target formula can be justified
    by this proof context.
  *)

  Definition Proof := list S.Form.

  (*
    form_eqb — Decidable Equality for Formulas

    Structural equality check for formulas.
    Returns true iff two formulas are syntactically identical.

    Used by the checker to match formulas in the proof list.
  *)

  Fixpoint form_eqb (a b : S.Form) : bool :=
    match a, b with
    | S.Bot, S.Bot => true
    | S.Imp a1 a2, S.Imp b1 b2 =>
        andb (form_eqb a1 b1) (form_eqb a2 b2)
    | S.Eq t1 t2, S.Eq u1 u2 =>
        andb (Subst.term_eqb t1 u1) (Subst.term_eqb t2 u2)
    | S.All x f, S.All y g =>
        andb (Subst.term_eqb x y) (form_eqb f g)
    | S.Ex x f, S.Ex y g =>
        andb (Subst.term_eqb x y) (form_eqb f g)
    | _, _ => false
    end.

  Lemma term_eqb_refl : forall t : S.Term, Subst.term_eqb t t = true.
  Proof.
    induction t; simpl; try exact (eq_refl _).
    exact IHt.
  Qed.

  Lemma andb_true_intro : forall a b, a = true -> b = true -> andb a b = true.
  Proof.
    intros a b Ha Hb.
    destruct a, b; simpl in *; try exact Ha; try exact Hb; try exact (eq_refl _).
  Qed.

  Lemma form_eqb_refl : forall f : S.Form, form_eqb f f = true.
  Proof.
    induction f; simpl; try exact (eq_refl _).
    - apply andb_true_intro; assumption.
    - apply andb_true_intro; apply term_eqb_refl.
    - apply andb_true_intro; try apply term_eqb_refl; assumption.
    - apply andb_true_intro; try apply term_eqb_refl; assumption.
  Qed.

  (*
    in_list — Membership Check

    Returns true iff formula phi appears in the proof list pf.

    This implements the "assumption" rule: a formula is justified
    if it has already appeared in the proof.
  *)

  Fixpoint in_list (phi : S.Form) (pf : Proof) : bool :=
    match pf with
    | nil => false
    | cons h t => if form_eqb phi h then true else in_list phi t
    end.

  Lemma in_list_refl : forall f : S.Form, in_list f (cons f nil) = true.
  Proof.
    intro f. simpl. rewrite form_eqb_refl. exact (eq_refl _).
  Qed.

  (*
    terms_of_form — Term Extraction

    Extracts all terms appearing in a formula.
    Used to build the term universe for instantiation checking.

    The checker uses this to find potential instantiation witnesses
    when checking universal instantiation and Leibniz substitution.
  *)

  Fixpoint terms_of_form (f : S.Form) : list S.Term :=
    match f with
    | S.Bot => nil
    | S.Imp a b => terms_of_form a ++ terms_of_form b
    | S.Eq t1 t2 => t1 :: t2 :: nil
    | S.All x body => x :: terms_of_form body
    | S.Ex x body => x :: terms_of_form body
    end.

  (*
    terms_of_proof — Term Universe Construction

    Extracts all terms from all formulas in the proof.
    This builds the "term universe" available for instantiation.
  *)

  Fixpoint terms_of_proof (pf : Proof) : list S.Term :=
    match pf with
    | nil => nil
    | cons h t => terms_of_form h ++ terms_of_proof t
    end.

  (*
    exists_imp — Modus Ponens Checker

    Checks if phi can be derived by modus ponens:
      if (φ → ψ) and φ are both in pf, then ψ is justified.

    Scans the proof for an implication (φ → phi), then checks
    if the antecedent φ is also in the proof.
  *)

  Fixpoint exists_imp (pf : Proof) (phi : S.Form) : bool :=
    match pf with
    | nil => false
    | cons h t =>
        match h with
        | S.Imp a b =>
            if form_eqb b phi
            then in_list a pf
            else exists_imp t phi
        | _ => exists_imp t phi
        end
    end.

  (*
    exists_all — Universal Generalization Checker

    Checks if phi (which must be ∀x.ψ) can be derived by generalization:
      if ψ is in pf, then ∀x.ψ is justified.

    This implements the generalization rule: from ψ, infer ∀x.ψ.
  *)

  Fixpoint exists_all (pf : Proof) (phi : S.Form) : bool :=
    match pf with
    | nil => false
    | cons h t =>
        match phi with
        | S.All x body =>
            if form_eqb body h then true else exists_all t phi
        | _ => false
        end
    end.

  (*
    exists_inst_terms — Universal Instantiation Helper

    Tries to instantiate ∀x.body with each term in ts to match phi.
    Returns true if any instantiation body[x↦t] equals phi.

    This is a helper for exists_inst (the full instantiation checker).
  *)

  Fixpoint exists_inst_terms (body : S.Form) (x : S.Var) (ts : list S.Term) (phi : S.Form) : bool :=
    match ts with
    | nil => false
    | cons t ts' =>
        if form_eqb (Subst.subst body x t) phi then true else exists_inst_terms body x ts' phi
    end.

  (*
    exists_inst — Universal Instantiation Checker

    Checks if phi can be derived by universal instantiation:
      if ∀x.ψ is in pf, and ψ[x↦t] = phi for some term t,
      then phi is justified.

    Scans the proof for universally quantified formulas,
    then tries instantiation with all available terms (ts).
  *)

  Fixpoint exists_inst (pf : Proof) (phi : S.Form) (ts : list S.Term) : bool :=
    match pf with
    | nil => false
    | cons h t =>
        match h with
        | S.All x body =>
            if exists_inst_terms body x ts phi then true else exists_inst t phi ts
        | _ => exists_inst t phi ts
        end
    end.

  (*
    refl_check — Reflexivity Axiom Checker

    Returns true if phi is a reflexivity axiom: t = t.

    This implements the axiom schema for equality reflexivity.
  *)

  Definition refl_check (phi : S.Form) : bool :=
    match phi with
    | S.Eq t1 t2 => Subst.term_eqb t1 t2
    | _ => false
    end.

  (*
    leibniz_body — Leibniz Substitution Body Check

    Checks if phi can be derived from body via Leibniz substitution:
      if t₁ = t₂ is in pf, and body[x↦t₁] is in pf,
      and body[x↦t₂] = phi, then phi is justified.

    This is the core logic for equality substitution.
  *)

  Definition leibniz_body (body : S.Form) (x : S.Var) (t1 t2 : S.Term) (pf : Proof) (phi : S.Form) : bool :=
    if form_eqb (Subst.subst body x t2) phi
    then in_list (Subst.subst body x t1) pf
    else false.

  (*
    exists_leibniz_terms — Leibniz Term Pair Search

    Tries all pairs of terms (t₁, t₂) from ts to find a Leibniz
    substitution that derives phi from body.

    For each pair, checks if t₁ = t₂ is in the proof and if
    the leibniz_body check succeeds.
  *)

  Fixpoint exists_leibniz_terms (body : S.Form) (x : S.Var) (ts : list S.Term) (pf : Proof) (phi : S.Form) : bool :=
    match ts with
    | nil => false
    | cons t1 ts1 =>
        let fix loop_t2 (ts2 : list S.Term) : bool :=
            match ts2 with
            | nil => false
            | cons t2 ts2' =>
                if in_list (S.Eq t1 t2) pf
                then if leibniz_body body x t1 t2 pf phi then true else loop_t2 ts2'
                else loop_t2 ts2'
            end
        in
        if loop_t2 ts
        then true
        else exists_leibniz_terms body x ts1 pf phi
    end.

  (*
    exists_leibniz — Leibniz Substitution Checker

    Checks if phi can be derived by Leibniz substitution:
      if ∀x.ψ is in pf, and t₁=t₂ is in pf, and ψ[x↦t₁] is in pf,
      and ψ[x↦t₂] = phi, then phi is justified.

    Scans the proof for universally quantified formulas (the Leibniz
    schemas), then tries all term pairs for substitution.
  *)

  Fixpoint exists_leibniz (pf : Proof) (phi : S.Form) (ts : list S.Term) : bool :=
    match pf with
    | nil => false
    | cons h t =>
        match h with
        | S.All x body =>
            if exists_leibniz_terms body x ts pf phi then true else exists_leibniz t phi ts
        | _ => exists_leibniz t phi ts
        end
    end.

  (*
    check — The Main Proof Checker

    Type: Proof → Form → bool

    Returns true iff formula phi is justified by proof pf.

    Checking Strategy (tried in order):

      1. Assumption: phi is directly in pf.
      2. Modus Ponens: phi follows from (φ → phi) and φ in pf.
      3. Universal Generalization: phi = ∀x.ψ and ψ is in pf.
      4. Universal Instantiation: ∀x.ψ is in pf and phi = ψ[x↦t].
      5. Reflexivity: phi is t = t for some term t.
      6. Leibniz: phi follows from equality substitution.

    If none of these rules apply, the check fails (returns false).

    Key Property:
      check is computable (reduces under vm_compute).
      This enables computational proof validation.
  *)

  Definition check (pf : Proof) (phi : S.Form) : bool :=
    if in_list phi pf then true
    else if exists_imp pf phi then true
    else if exists_all pf phi then true
    else if exists_inst pf phi (terms_of_proof pf) then true
    else if refl_check phi then true
    else if exists_leibniz pf phi (terms_of_proof pf) then true
    else false.

  (*
    check_refl — Effectivity Witness

    Shows that check is effective: a trivial proof (just phi itself)
    validates phi via the assumption rule.

    This can be verified computationally (vm_compute).
  *)

  Lemma check_refl : forall f : S.Form, check (cons f nil) f = true.
  Proof.
    intro f. unfold check. cbn.
    rewrite form_eqb_refl.
    exact (eq_refl _).
  Qed.

End C009_FOL_Kernel_R.

Export C009_FOL_Kernel_R.

(* ---- theories/M004__Conservation_of_Hardness/C009__SAT_Reduction/P3_T__FOL.v ---- *)

(* P3_T__FOL.v *)

(*************************************************************************)
(*                                                                       *)
(*  C009 / Phase 3 (T): First-Order Logic (Public Surface)               *)
(*                                                                       *)
(*    (i) Scope.                                                         *)
(*                                                                       *)
(*        Stable public API for the First-Order Logic layer.             *)
(*        Aggregates syntax (P1_S__Syntax), substitution                 *)
(*        (P2_R__Substitution), and kernel (P3_R__Kernel) into a         *)
(*        unified interface.                                             *)
(*                                                                       *)
(*   (ii) Design Discipline: Witness-First Provability.                  *)
(*                                                                       *)
(*        The Prov predicate is defined via witnesses:                   *)
(*                                                                       *)
(*          Prov(φ) ≜ ∃pf : Proof. check pf φ = true                     *)
(*                                                                       *)
(*        This aligns with the BHK_R methodology: to prove φ is to       *)
(*        construct a checkable proof script pf.                         *)
(*                                                                       *)
(*  (iii) Public Exports.                                                *)
(*                                                                       *)
(*        (a) Syntax: Form, Term, Var, constructors (Bot, Imp, Eq, ...). *)
(*        (b) Provability: Prov predicate, Prov_from_check bridge.       *)
(*        (c) Kernel: Exposed for effectivity testing (vm_compute).      *)
(*                                                                       *)
(*   (iv) Role in C009.                                                  *)
(*                                                                       *)
(*        (a) Kernel sanity tests (P4_T__Kernel_Sanity)                  *)
(*        (b) Potential future extensions (arithmetic, DPRM)             *)
(*                                                                       *)
(*        NOT used for the SAT reduction itself (which uses ATP_Form).   *)
(*                                                                       *)
(*************************************************************************)

From Coq Require Import Init.Logic.
From SAT.C009 Require Export P1_S__Syntax.
From SAT.C009 Require Export P2_R__Substitution.
From SAT.C009 Require Export P3_R__Kernel.

Set Implicit Arguments.
Unset Strict Implicit.

Module C009_FOL_Public.

  (*
    Re-export the Arithmetic Nucleus

    Provides access to the BHK_R foundation (nat, O, S, etc.).
  *)

  Module Prelude := BHK_R.C000.P0__BHK.BHK.

  (*
    Syntax — Stable Names for FOL Constructs

    Exposes the syntax module and provides convenient aliases.
  *)

  Module Syntax := C009_FOL_Syntax.

  Definition Form := Syntax.Form.
  Definition Term := Syntax.Term.
  Definition Var  := Syntax.Var.

  (*
    Formula Constructors

    These are the primitive building blocks of FOL formulas.
  *)

  Definition Bot := Syntax.Bot.
  Definition Imp := Syntax.Imp.
  Definition Eq  := Syntax.Eq.
  Definition All := Syntax.All.
  Definition Ex  := Syntax.Ex.
  Definition Not := Syntax.Not.

  (*
    The Provability Predicate

    Type. Form → Prop

    Definition.

      Prov(φ) ≜ ∃pf : Proof. check pf φ = true

    Meaning.

      φ is provable iff there exists a proof script pf that
      validates φ under the kernel checker.

    Design Note:

      This is the witness-first discipline from C002:

         (i) Provability is inhabited by explicit proof artifacts.

        (ii) No abstract derivation trees or axiom schemes.

       (iii) Proof validity is computational (check : Proof → Form → bool).

    Contrast with Abstract Provability:

      In a typical Hilbert-style system, Prov would be an
      inductive type with constructors for axioms and rules.
      Here, we collapse that to a checker function, making
      provability a computational property.
  *)

  Definition Prov (phi : Form) : Prop :=
    exists (pf : C009_FOL_Kernel_R.Proof), C009_FOL_Kernel_R.check pf phi = true.

  (*
    Prov_from_check — Soundness Bridge

    Type: ∀pf φ. check pf φ = true → Prov φ

    Allows users to construct Prov witnesses by computation:
         (i) Build a proof script pf.
        (ii) Run vm_compute to verify check pf φ = true.
       (iii) Apply Prov_from_check to get Prov φ.

    This makes proof construction effective: write the proof,
    validate it computationally, then lift to Prop.
  *)

  Theorem Prov_from_check : forall (pf : C009_FOL_Kernel_R.Proof) (phi : Form),
    C009_FOL_Kernel_R.check pf phi = true -> Prov phi.
  Proof.
    intros pf phi H. exists pf. exact H.
  Qed.

  (*
    Exposes the kernel module directly for regression testing
    and effectivity witnesses (see P4_T__Kernel_Sanity).

    Users can access:
         (i) Kernel.Proof (the proof type)
        (ii) Kernel.check (the checker function)
       (iii) Kernel-specific lemmas (form_eqb_refl, etc.)
  *)

  Module Kernel := C009_FOL_Kernel_R.

End C009_FOL_Public.

Export C009_FOL_Public.

(*
  We export the kernel so effectivity tests can access check directly.
  This is intentional: the kernel is part of the public API for
  computational proof validation.
*)

Export C009_FOL_Kernel_R.

(*************************************************************************)
(*                                                                       *)
(*  Architectural Note: Three-Layer FOL Structure                        *)
(*                                                                       *)
(*    “P1_S__Syntax”                                                     *)
(*    Defines Form, Term, Var (syntax types).                            *)
(*                                                                       *)
(*    “P2_R__Substitution”                                               *)
(*    Defines subst (capture-avoiding substitution).                     *)
(*                                                                       *)
(*    “P3_R__Kernel”                                                     *)
(*    Defines Proof and check (proof validation).                        *)
(*                                                                       *)
(*    “P3_T__FOL” (this file):                                           *)
(*    Aggregates all three layers into a stable public API.              *)
(*    Defines Prov predicate via witness-first discipline.               *)
(*                                                                       *)
(*    Each layer is minimal and focused. The T-layer (public surface)    *)
(*    packages them into a coherent interface without adding new         *)
(*    computational content.                                             *)
(*                                                                       *)
(*************************************************************************)


(* ---- theories/M004__Conservation_of_Hardness/C009__SAT_Reduction/P4_T__Kernel_Sanity.v ---- *)

(* P4_T__Kernel_Sanity.v *)

From Coq Require Import Init.Logic.
From SAT.C009 Require Import P3_T__FOL.
From SAT.C009 Require Import P3_R__Kernel.

Set Implicit Arguments.
Unset Strict Implicit.

Module Test_FOL_Kernel.

(*************************************************************************)
(*                                                                       *)
(*  C009 / Phase 4 (T): Kernel Sanity Tests (Effectivity Witnesses)      *)
(*                                                                       *)
(*    (i) Scope.                                                         *)
(*                                                                       *)
(*        Regression tests and effectivity witnesses for the FOL kernel. *)
(*        Validates that check correctly recognizes basic proofs.        *)
(*                                                                       *)
(*   (ii) Testing Discipline: Computational Validation.                  *)
(*                                                                       *)
(*        Each test is a vm_compute example showing:                     *)
(*          (i) A proof script pf                                        *)
(*          - A target formula phi                                       *)
(*          - check pf phi = true  (validated by vm_compute)             *)
(*                                                                       *)
(*        This is "proof by computation": the kernel's correctness is    *)
(*        witnessed by successful execution, not by meta-theoretic       *)
(*        soundness proofs.                                              *)
(*                                                                       *)
(*  (iii) Test Coverage.                                                 *)
(*                                                                       *)
(*        The tests cover all major proof rules:                         *)
(*          (a) Reflexivity: t = t                                       *)
(*          (b) Generalization: φ → ∀x.φ                                 *)
(*          (c) Instantiation: ∀x.φ → φ[x↦t]                             *)
(*          (d) Symmetry: x=y → y=x  (via Leibniz)                       *)
(*          (e) Double instantiation: ∀x.x=x → (1=1 ∧ 2=2)               *)
(*          (f) Leibniz with implication bodies                          *)
(*                                                                       *)
(*   (iv) Role in C009.                                                  *)
(*                                                                       *)
(*        Provides computational confidence in the kernel.               *)
(*        These are NOT formal soundness proofs, but effectivity         *)
(*        witnesses: the kernel computes correctly on concrete inputs.   *)
(*                                                                       *)
(*************************************************************************)

  (*
    Minimal parsing-safe sanity stub.
    Ensures the file loads correctly in all build environments.
  *)

  Example sanity_parses : True.
  Proof.
    exact I.
  Qed.

  Import C009_FOL_Public.

  Module K := C009_FOL_Public.Kernel.

  Definition x0 : Var := Prelude.O.
  Definition t0 : Term := Prelude.O.

  (*
    Test. Reflexivity (0 = 0)
  *)

  Definition claim_refl : Form := Eq t0 t0.
  Definition pf_refl : K.Proof := nil.

  Example test_refl : K.check pf_refl claim_refl = true.
  Proof. vm_compute. reflexivity. Qed.

  (*
    Test. Generalization (forall x, x = x)
  *)

  Definition var_x : Var := Prelude.S Prelude.O.
  Definition term_x : Term := Prelude.S Prelude.O.
  Definition claim_gen : Form := All var_x (Eq term_x term_x).

  Definition pf_gen : K.Proof :=
    cons (Eq term_x term_x) nil.

  Example test_gen : K.check pf_gen claim_gen = true.
  Proof. vm_compute. reflexivity. Qed.

  (*
    Test. Instantiation (from forall x, x = x to 0 = 0)
  *)

  Definition claim_inst : Form := Eq t0 t0.

  Definition pf_inst : K.Proof :=
    cons (Eq t0 t0)
    (cons claim_gen nil).

  Example test_inst : K.check pf_inst claim_inst = true.
  Proof. vm_compute. reflexivity. Qed.

  Import C009_FOL_Public.

  Definition O := Prelude.O.
  Definition S := Prelude.S.

  (*
    Variables and Terms are just Nats in this syntax
  *)

  Definition x : Var := O.
  Definition y : Var := S O.
  
  Definition tx : Term := O.
  Definition ty : Term := S O.
  Definition t1 : Term := S (S O).
  Definition t2 : Term := S (S (S O)).


  (*
    Test. Instantiation (from forall x, x = x to 0 = 0)
    Test. Symmetry of Equality: Prove (x = y) -> (y = x)
  *)

  Definition claim_sym : Form := Eq ty tx.

  (*
    The bound variable 'z' used for Leibniz substitution
  *)

  Definition z : Var := S (S O).

  (*
    Leibniz body: z = x
  *)

  Definition body_leibniz : Form := Eq z tx.

  (*
  The raw proof script: Leibniz substitution from x=y and x=x
  *)

  Definition pf_sym : C009_FOL_Kernel_R.Proof :=
    cons (All z body_leibniz)
    (cons (Eq tx ty)
    (cons (Eq tx tx) nil)).

  Example test_symmetry_holds : 
    C009_FOL_Kernel_R.check pf_sym claim_sym = true.
  Proof. vm_compute. reflexivity. Qed.

  (*
    Test. Double Instantiation 
    Goal: (Forall x. x = x) -> (1 = 1) /\ (2 = 2)
  *)

  (*
    Forall x, x=x
  *)

  Definition univ_identity : Form := All x (Eq x x).
  
  (*
    Targets
  *)

  Definition eq_1_1 : Form := Eq t1 t1.
  Definition eq_2_2 : Form := Eq t2 t2.

  Definition pf_axiom_only : C009_FOL_Kernel_R.Proof :=
    (* Dummy equality to register t1 and t2 in the kernel's term scanner *)
    cons (Eq t1 t2) 
    (cons univ_identity nil).

  (*
    Test. Can we derive 1=1?
  *)

  Example test_inst_1 : 
    C009_FOL_Kernel_R.check pf_axiom_only eq_1_1 = true.
  Proof. vm_compute. reflexivity. Qed.

  (*
    Test. Can we derive 2=2 from the SAME script?
  *)

  Example test_inst_2 : 
    C009_FOL_Kernel_R.check pf_axiom_only eq_2_2 = true.
  Proof. vm_compute. reflexivity. Qed.

  (*
    Test. Leibniz with a nontrivial body (implication)
    Goal: from x=y and a Leibniz body, derive (y=x)->(y=x)
  *)

  Definition body_leibniz_imp : Form := Imp (Eq z tx) (Eq z tx).
  Definition claim_leibniz_imp : Form := Imp (Eq ty tx) (Eq ty tx).

  Definition pf_leibniz_imp : C009_FOL_Kernel_R.Proof :=
    cons (All z body_leibniz_imp)
    (cons (Eq tx ty)
    (cons (Imp (Eq tx tx) (Eq tx tx)) nil)).

  Example test_leibniz_imp :
    C009_FOL_Kernel_R.check pf_leibniz_imp claim_leibniz_imp = true.
  Proof. vm_compute. reflexivity. Qed.

End Test_FOL_Kernel.


(* ---- theories/M004__Conservation_of_Hardness/C009__SAT_Reduction/P4_T__Mechanism.v ---- *)

(* P4_T__Mechanism.v *)

From Coq Require Import Init.Logic.

From Diagonallemma.C003 Require Import P2_T__Diagonal.
From Diagonallemma.C003 Require Import P2_R__Backend.
From Carryless_Pairing.C001 Require Import P5_T__Carryless_Pairing.
From SAT.C009 Require Import P3_T__Structural_Integrity.

Set Implicit Arguments.
Unset Strict Implicit.

(*************************************************************************)
(*                                                                       *)
(*  C009 / Phase 4 (T): The Diagonal Mechanism (Linker Implementation)   *)
(*                                                                       *)
(*    (i) Scope.                                                         *)
(*                                                                       *)
(*        Connects the abstract Diagonal Lemma (C003) with the concrete  *)
(*        arithmetic of Carryless Pairing (C001) to provide the          *)
(*        diagonal witness required by the SAT barrier.                  *)
(*                                                                       *)
(*   (ii) Key Insight.                                                   *)
(*                                                                       *)
(*        The diagonal construction is PARAMETRIC over the backend.      *)
(*        C003 provides the abstract self-reference mechanism, C001      *)
(*        provides the concrete encoding. This file instantiates the     *)
(*        abstract with the concrete to get the SAT diagonal witness.    *)
(*                                                                       *)
(*  (iii) Downstream Use.                                                *)
(*                                                                       *)
(*        The Construct_SAT_Diagonal theorem is used by:                 *)
(*          - P3_T__Structural_Integrity (Hardness_Conservation theorem) *)
(*          - As the Diagonal_Mechanism hypothesis                       *)
(*                                                                       *)
(*************************************************************************)

(*************************************************************************)
(*                                                                       *)
(*  This adapter allows the abstract diagonal construction (C003) to     *)
(*  use the concrete carryless pairing device (C001) for encoding.       *)
(*                                                                       *)
(*************************************************************************)

Module CarrylessBackend <: Diagonallemma.C003.P1_S__Syntax.C003_P1.BACKEND.
  
  (* Short aliases for C001 modules *)
  Module N := Carryless_Pairing.C001.P5_T__Carryless_Pairing.Prelude.
  Module P := Carryless_Pairing.C001.P5_T__Carryless_Pairing.Pairing.

  Definition nat : Type := N.nat.

  (* C001 uses a specific pairing strategy (CarrylessPair) *)
  Definition pair (x y : nat) : nat := 
    P.pair P.CarrylessPair x y.

  Definition unpair (z : nat) : nat * nat :=
    let p := P.unpair P.CarrylessPair z in 
    (P.fst p, P.snd p).

  (* Tag Definitions: specific natural numbers for AST encoding *)
  (* We use standard lambda definable construction. *)
  
  Definition tag_bot     : nat := N.O.
  Definition tag_imp     : nat := N.S N.O.
  Definition tag_hole    : nat := N.S (N.S N.O).
  Definition tag_quote   : nat := N.S (N.S (N.S N.O)).
  Definition tag_var     : nat := N.S (N.S (N.S (N.S N.O))).
  Definition tag_const   : nat := N.S (N.S (N.S (N.S (N.S N.O)))).
  Definition tag_pair    : nat := N.S (N.S (N.S (N.S (N.S (N.S N.O))))).
  Definition tag_unpairL : nat := N.S (N.S (N.S (N.S (N.S (N.S (N.S N.O)))))).
  Definition tag_unpairR : nat := N.S (N.S (N.S (N.S (N.S (N.S (N.S (N.S N.O))))))).

End CarrylessBackend.

(*
  The Functor Instantiation.
  We create the concrete Diagonal theory (Diag) using our Backend
*)

Module Diag := Diagonallemma.C003.P2_T__Diagonal.Diagonal_Functor(CarrylessBackend).

(*
  The Implementation
*)

Module C009_Diagonal_Mechanism_T.

  Module SI := SAT.C009.P3_T__Structural_Integrity.C009_Structural_Integrity_T.
  Module Def := SI.SAT_Def.

  (*
    Representable — Separator Representability Hypothesis

    Type: Certified_SAT_Solver → Prop

    Definition:
      A separator S is representable iff it can be encoded as a
      diagonal template T_flip such that:
        - The diagonal construction diag(T_flip) produces a formula D
        - D satisfies the flip condition and tracking properties

    This is the bridge hypothesis: it assumes the separator can be
    "internalized" into the diagonal mechanism.

    Why a Hypothesis?
      Constructing the template from an arbitrary separator S
      requires meta-theoretic encoding (the separator's decision
      function must be representable as a formula). We postulate
      this as Representable rather than constructing it directly.

    Role:
      Representable is assumed by Construct_SAT_Diagonal.
      When satisfied, it provides the diagonal witness needed
      for Hardness_Conservation (P3_T__Structural_Integrity).
  *)

  Definition Representable (S : SI.Certified_SAT_Solver) : Prop :=
    exists (T_flip : Diag.Template)
           (Compiled : Diag.COMPILED T_flip)
           (Form_of_Template : Diag.Template -> Def.P.ATP_Form),
      let D_t := Diag.diag (t := T_flip) Compiled in
      let d := Diag.encU D_t in
      (Form_of_Template D_t = Def.Flip_Logic S d) /\
      (Def.Truth (Def.A d) <-> Def.Truth (Form_of_Template D_t)) /\
      (Def.Truth (Def.B d) <-> Def.Truth (Form_of_Template D_t)).

  (*
    Theorem: Construct_SAT_Diagonal — The Diagonal Witness Discharger

    Type:
      ∀S : Certified_SAT_Solver.
        Representable S →
        ∃(d, D). (flip and tracking conditions)

    Statement:
      Given a representable separator S, construct the diagonal witness
      (d, D) required by the Hardness_Conservation theorem.

    Proof Strategy:
      1. Destructure Representable S to get:
           - T_flip: the template representing Flip(S, □)
           - Comp: the compilation of T_flip
           - Form_of_Template: interpretation function
      2. Execute the diagonal construction:
           D_t = diag(T_flip)  (the diagonal template)
           d   = encU(D_t)      (the code of D_t)
           D   = Form_of_Template(D_t)  (the formula interpretation)
      3. Verify the witness conditions:
           - Flip condition: D = Flip(S, d)
           - Tracking conditions: A(d) ↔ D and B(d) ↔ D

    Role:
      This theorem is THE linker between:
        - C003 (diagonal construction)
        - C001 (carryless encoding)
        - C009 (SAT hardness)

      It discharges the Diagonal_Mechanism hypothesis in
      Hardness_Conservation (P3_T__Structural_Integrity).
  *)

  Theorem Construct_SAT_Diagonal
    (S : SI.Certified_SAT_Solver)
    (H_Rep : Representable S) :
    exists (d : Def.N.nat) (D : Def.P.ATP_Form),
      (Def.Truth D <-> Def.Truth (Def.Flip_Logic S d)) /\
      (Def.Truth (Def.A d) <-> Def.Truth D) /\
      (Def.Truth (Def.B d) <-> Def.Truth D).
  Proof.

    (*
      Step 1: Destructure the Representable hypothesis
    *)

    destruct H_Rep as [T_flip [Comp [Form_of_Template HRep]]].

    (*
      Step 2: Execute the Diagonal Operator

      The diagonal construction from C003 gives us:
        D_t = diag(T_flip, Comp)

      This is the self-referential template: D_t "talks about"
      its own code via the Quinean knot (selfpack).
    *)

    pose (D_t := Diag.diag (t := T_flip) Comp).

    (*
      Step 3: Compute the code of D_t

      d = encU(D_t) is the Gödel number of the diagonal template.
    *)

    pose (d    := Diag.encU D_t).

    (*
      Step 4: Interpret D_t as a formula

      D = Form_of_Template(D_t) converts the template to an ATP_Form.
      This is the actual formula that will appear in the barrier proof.
    *)

    pose (D    := Form_of_Template D_t).

    (*
      Step 5: Return the witness (d, D)
    *)

    exists d, D.

    (*
      Step 6: Verify the witness conditions
    *)

    destruct HRep as [HFlip [HTrackA HTrackB]].

    split.

    (*
      Condition 1: Flip Property

      Goal: Truth(D) ↔ Truth(Flip(S, d))

      By HFlip (from Representable), we have D = Flip(S, d),
      so this is trivial.
    *)

    - unfold D, d, D_t in *.
      split; intro HT.
      + rewrite HFlip in HT. exact HT.
      + rewrite <- HFlip in HT. exact HT.

    (*
      Condition 2: Tracking Properties

      Goal: Truth(A(d)) ↔ Truth(D) ∧ Truth(B(d)) ↔ Truth(D)

      These are exactly HTrackA and HTrackB from Representable.
    *)

    - split.
      + unfold D, d, D_t in *. exact HTrackA.
      + unfold D, d, D_t in *. exact HTrackB.

    (*
      QED.

      We have constructed (d, D) satisfying all witness conditions.
      This diagonal witness can now be fed to the Adversarial Barrier
      (C005) to derive False from separator existence.
    *)

  Qed.

End C009_Diagonal_Mechanism_T.

(*************************************************************************)
(*                                                                       *)
(*  The Diagonal Mechanism as Linker                                     *)
(*                                                                       *)
(*  Three-Module Integration:                                            *)
(*                                                                       *)
(*    C003 (Diagonal Lemma):                                             *)
(*      Provides abstract self-reference construction.                   *)
(*      Parametric over BACKEND interface.                               *)
(*                                                                       *)
(*    C001 (Carryless Pairing):                                          *)
(*      Provides concrete encoding (pair, unpair, tags).                 *)
(*      Implements BACKEND interface via CarrylessBackend.               *)
(*                                                                       *)
(*    C009 (SAT Reduction):                                              *)
(*      Requires diagonal witness for Hardness_Conservation.             *)
(*      Construct_SAT_Diagonal discharges this requirement.              *)
(*                                                                       *)
(*  The Linker Pattern:                                                  *)
(*                                                                       *)
(*    1. Define abstract interface (C003 BACKEND).                       *)
(*    2. Implement concrete adapter (CarrylessBackend).                  *)
(*    3. Instantiate abstract theory (Diag functor).                     *)
(*    4. Bridge to downstream user (Construct_SAT_Diagonal).             *)
(*                                                                       *)
(*  This is modular impossibility: each layer is minimal, focused, and   *)
(*  compositional. The hardness result emerges from their interaction.   *)
(*                                                                       *)
(*************************************************************************)


(* ---- theories/M004__Conservation_of_Hardness/C010__Solvability_Thesis/P1_S__Thesis_Definition.v ---- *)

(* P1_S__Thesis_Definition.v *)

From Coq Require Import Init.Logic.
From ATP.C002 Require Import P5_T__Proof_Theory.
From Adversarial_Barrier.C005 Require Import P2_T__Barrier.

Set Implicit Arguments.
Unset Strict Implicit.

(*************************************************************************)
(*                                                                       *)
(*  C010 / Phase 1 (S): The Solvability Thesis (Specification)           *)
(*                                                                       *)
(*    (i) Scope.                                                         *)
(*                                                                       *)
(*        Formal definition of the Solvability Thesis: the claim that    *)
(*        every computational problem admits a certified separator.      *)
(*                                                                       *)
(*   (ii) The Thesis Statement.                                          *)
(*                                                                       *)
(*        For every problem (two disjoint semantic classes A and B),     *)
(*        there exists a mechanical separator S that:                    *)
(*          (a) Decides membership: σ : ℕ → bool                         *)
(*          (b) Provides certificates: Prov(A(n)) or Prov(B(n))          *)
(*                                                                       *)
(*  (iii) Philosophical Interpretation.                                  *)
(*                                                                       *)
(*        The Solvability Thesis is the "Universal Computability"        *)
(*        hypothesis: it asserts that computation can solve everything.  *)
(*                                                                       *)
(*        Comparison to Church-Turing Thesis:                            *)
(*          CT: "Every effectively computable function is recursive."    *)
(*          ST: "Every effectively solvable problem has a separator."    *)
(*                                                                       *)
(*        The Solvability Thesis is STRONGER than CT: it requires not    *)
(*        just decision procedures but CERTIFIED decision procedures     *)
(*        (with proof witnesses).                                        *)
(*                                                                       *)
(*   (iv) C010's Result.                                                 *)
(*                                                                       *)
(*        The Domino Effect (P2_T__Normalization):                       *)
(*                                                                       *)
(*          Solvability_Thesis → ∀Q. Q                                   *)
(*                                                                       *)
(*        If the thesis holds, every proposition becomes provable.       *)
(*        The logical universe collapses to triviality (absurdum).       *)
(*                                                                       *)
(*    (v) Why This Matters.                                              *)
(*                                                                       *)
(*        The refutation shows: computational hardness is not an         *)
(*        empirical observation, “we haven't found efficient algorithms  *)
(*        yet” but a LOGICAL NECESSITY. Without hardness, logic itself   *)
(*        breaks down.                                                   *)
(*                                                                       *)
(*************************************************************************)

Module C010_Thesis_Def_S.
  Module N := ATP.C002.P5_T__Proof_Theory.Prelude.
  Module P := ATP.C002.P5_T__Proof_Theory.ATP.

  (*
    PROBLEM_CLASS — The General Form of a Computational Problem

    A problem is specified by:
      - Two formula classes A, B : ℕ → Form (indexed by naturals)
      - A semantic truth predicate Truth : Form → Prop
      - Semantic disjointness: ∀n. ¬(Truth(A(n)) ∧ Truth(B(n)))
      - Soundness bridge: Prov(φ) → Truth(φ)

    Informal Meaning:
      A problem asks to distinguish between two classes of instances.
      The classes are semantically disjoint (no instance is in both).
      Provability is sound with respect to the semantic model.

    Examples:
      - SAT/UNSAT: A(n) = "CNF(n) is satisfiable"
                   B(n) = "CNF(n) is unsatisfiable"
      - HALT/LOOP: A(n) = "TM(n) halts"
                   B(n) = "TM(n) loops forever"
      - PRIME/COMP: A(n) = "n is prime"
                    B(n) = "n is composite"

    The problem is to build a separator: a decision procedure
    with proof certificates.
  *)

  Record PROBLEM_CLASS : Type := {
    A : N.nat -> P.ATP_Form;
    B : N.nat -> P.ATP_Form;
    Truth : P.ATP_Form -> Prop;
    Disjoint : forall n : N.nat, Truth (A n) -> Truth (B n) -> False;
    Sound : forall phi, P.ATP_Prov phi -> Truth phi
  }.

  (*
    SEPARATOR — Certified Decision Procedure

    A separator for classes A and B is a pair (σ, cert) where:
      - σ : ℕ → bool is a total decision function
      - cert provides proof certificates:
          if σ(n) = true,  then Prov(A(n))
          if σ(n) = false, then Prov(B(n))

    Informal Meaning:
      The separator not only decides which class each instance belongs
      to, but also provides a formal proof (certificate) for its answer.

    Comparison to Standard Decision Procedures:
      - Standard: σ : ℕ → bool  (just decide)
      - Separator: σ : ℕ → bool + (Prov(A(n)) ∨ Prov(B(n)))
                   (decide + certify)
  *)

  Record SEPARATOR (A B : N.nat -> P.ATP_Form) : Type := {
    sigma : N.nat -> N.bool;
    cert : forall n : N.nat,
      if sigma n
      then P.ATP_Prov (A n)
      else P.ATP_Prov (B n)
  }.

  (*
    Solvability_Thesis — The Universal Computability Hypothesis

    Statement:
      ∀ Problem. ∃ Separator

    Informal Reading:
      "Every computational problem (with disjoint semantic classes)
       admits a certified separator."

    Equivalently:
      "Computation can solve everything (with proof certificates)."

    This is the "Universal Solver" hypothesis: it asserts that
    there is no such thing as an inherently hard problem.

    C010's Refutation:
      The Domino Effect (P2_T__Normalization) shows:

        Solvability_Thesis → ∀Q. Q

      If the thesis holds, every proposition becomes provable.
      This is the ultimate absurdity: logic collapses entirely.

    Conclusion:
      The thesis is false. There exist problems with no certified
      separator. Computational hardness is a logical necessity.
  *)

  Definition Solvability_Thesis : Prop :=
    forall (Pb : PROBLEM_CLASS),
      exists (S : SEPARATOR Pb.(A) Pb.(B)), True.

End C010_Thesis_Def_S.

Export C010_Thesis_Def_S.

(*************************************************************************)
(*                                                                       *)
(*  Philosophical Reflection: The Load-Bearing Role of Hardness          *)
(*                                                                       *)
(*  Why does the Solvability Thesis lead to triviality?                  *)
(*                                                                       *)
(*  The key is the interaction between:                                  *)
(*    (i)   Certified separators (the thesis)                            *)
(*    (ii)  Diagonal self-reference (C003)                               *)
(*    (iii) Resistance law (C007)                                        *)
(*                                                                       *)
(*  The proof flow:                                                      *)
(*                                                                       *)
(*    1. Assume Solvability_Thesis                                       *)
(*    2. Instantiate with SAT problem (A = SAT, B = UNSAT)               *)
(*    3. Get separator S from the thesis                                 *)
(*    4. Feed S to the diagonal construction (C003)                      *)
(*    5. Derive False via Hardness Conservation (C009)                   *)
(*    6. Conclude Solvability_Thesis → False                             *)
(*    7. Therefore Solvability_Thesis → ∀Q. Q (“ex falso“-like)          *)
(*                                                                       *)
(*  The Moral:                                                           *)
(*                                                                       *)
(*    Computational hardness is the load-bearing beam that prevents      *)
(*    the logical universe from collapsing. Remove it (by assuming       *)
(*    universal solvability) and everything becomes provable.            *)
(*                                                                       *)
(*    This is why P ≠ NP is not “just” a complexity question.            *)
(*    It's a foundational question about the structure of logic itself.  *)
(*                                                                       *)
(*************************************************************************)

(* ---- theories/M004__Conservation_of_Hardness/C010__Solvability_Thesis/P2_R__Triviality_Proof.v ---- *)

(* P2_R__Triviality_Proof.v *)


From Coq Require Import Init.Logic.
From SAT.C009 Require Import P3_T__Structural_Integrity.
From SAT.C009 Require Import P4_T__Mechanism.
From Solvability_Thesis.C010 Require Import P1_S__Thesis_Definition.
From Carryless_Pairing.C001 Require Import P6_A__Reflexica_Certificate.

Set Implicit Arguments.
Unset Strict Implicit.

(*************************************************************************)
(*                                                                       *)
(*  C010 / Phase 2 (R): Triviality Proof (Realization)                   *)
(*                                                                       *)
(*    (i) Scope.                                                         *)
(*                                                                       *)
(*        Core proof that the Solvability Thesis implies triviality.     *)
(*        Shows: if every problem has a separator, then arithmetic       *)
(*        integrity fails, leading to explosion (∀Q. Q).                 *)
(*                                                                       *)
(*   (ii) Proof Strategy: The Concrete Instantiation.                    *)
(*                                                                       *)
(*        (a) Assume Solvability_Thesis                                  *)
(*        (b) Instantiate with SAT_Problem (A = SAT, B = UNSAT)          *)
(*        (c) Get separator S from the thesis                            *)
(*        (d) Feed S to Hardness_Conservation (C009)                     *)
(*        (e) Derive ¬Arithmetic_Integrity                               *)
(*        (f) Clash with Reflexica axiom (Arithmetic_Integrity holds)    *)
(*        (g) Conclude False → ∀Q. Q (ex falso quodlibet)                *)
(*                                                                       *)
(*  (iii) Oracle Assumptions.                                            *)
(*                                                                       *)
(*        (a) SAT_Disjoint: SAT and UNSAT are semantically disjoint.     *)
(*        (b) SAT_Soundness: Provability implies truth for SAT formulas. *)
(*        (c) SAT_Representability: Any separator can be diagonalized.   *)
(*                                                                       *)
(*        These are standard assumptions for the SAT reduction.          *)
(*                                                                       *)
(*   (iv) The Central Contradiction.                                     *)
(*                                                                       *)
(*        Hardness_Conservation (C009) says:                             *)
(*          (∃ Separator) ↔ ¬Arithmetic_Integrity                        *)
(*                                                                       *)
(*        But Reflexica (C001/P6_A) asserts:                             *)
(*          Arithmetic_Integrity                                         *)
(*                                                                       *)
(*        The thesis gives us a separator, forcing ¬Integrity.           *)
(*        Reflexica gives us Integrity. Contradiction.                   *)
(*                                                                       *)
(*    (v) Role in C010.                                                  *)
(*                                                                       *)
(*        This is the R-layer (realization): the computational proof.    *)
(*        P2_T__Normalization (T-layer) wraps it for public export.      *)
(*                                                                       *)
(*************************************************************************)

Module C010_Triviality_R.

  Module SI := SAT.C009.P3_T__Structural_Integrity.C009_Structural_Integrity_T.
  Module Thesis := C010_Thesis_Def_S.
  Module Mech := C009_Diagonal_Mechanism_T.

  (*
    Oracle Assumptions — SAT Problem Context

    These parameters establish the semantic context for the SAT problem.
    They are standard assumptions for the SAT reduction and barrier.
  *)

  (*
    SAT_Disjoint — Semantic Disjointness of SAT and UNSAT

    No CNF formula is both satisfiable and unsatisfiable.
    This is a semantic consistency assumption about the SAT model.
  *)

  Parameter SAT_Disjoint : SI.SAT_Def.Semantic_Disjointness.

  (*
    SAT_Soundness — Provability Implies Truth

    If we can prove a SAT/UNSAT formula, it's true in the semantic model.
    This bridges proof theory to model theory.
  *)

  Parameter SAT_Soundness : forall phi, SI.SAT_Def.P.ATP_Prov phi -> SI.SAT_Def.Truth phi.

  (*
    SAT_Representability — Separators are Diagonalizable

    Any separator for SAT/UNSAT can be represented as a diagonal template.
    This allows us to feed the separator to the diagonal construction (C003).

    Why a Parameter?
      Representability requires encoding the separator's decision function
      as a formula template. This is a meta-theoretic construction,
      postulated rather than explicitly built.
  *)

  Parameter SAT_Representability :
    forall S : SI.Certified_SAT_Solver, Mech.Representable S.

  (*
    Theorem: Thesis_Implies_Triviality — The Domino Effect

    Statement:
      Solvability_Thesis → ∀Q. Q

    Informal Reading:
      "If every problem has a separator, then every proposition
       is provable (the logical universe collapses)."

    Proof Structure:
      1. Assume the thesis
      2. Instantiate with SAT problem
      3. Get separator from thesis
      4. Apply Hardness Conservation → ¬Arithmetic_Integrity
      5. Clash with Reflexica axiom → False
      6. Ex falso → ∀Q. Q
  *)

  Theorem Thesis_Implies_Triviality :
    Thesis.Solvability_Thesis -> forall (Q : Prop), Q.
  Proof.
    intros HThesis Q.

    (*
      Step 1: Instantiate the Thesis for SAT

      We construct the SAT_Problem as a PROBLEM_CLASS:
        A = SAT formulas (satisfiable CNFs)
        B = UNSAT formulas (unsatisfiable CNFs)
        Truth = semantic truth (validity under all valuations)
        Disjoint = SAT_Disjoint (no CNF is both SAT and UNSAT)
        Sound = SAT_Soundness (provability implies truth)

      This is the concrete problem we'll use to refute the thesis.
    *)

    pose (SAT_Problem := {|
       Thesis.A := SI.SAT_Ctx.A;
       Thesis.B := SI.SAT_Ctx.B;
       Thesis.Truth := SI.SAT_Ctx.Truth;
       Thesis.Disjoint := SAT_Disjoint;
       Thesis.Sound := SAT_Soundness
    |}).

    (*
      Step 2: Obtain the Separator from the Thesis

      The Solvability Thesis claims: ∀ Problem. ∃ Separator.
      We apply it to SAT_Problem to get a separator S_Thesis.

      This separator claims to solve SAT: it decides every CNF
      formula and provides proof certificates.
    *)

    destruct (HThesis SAT_Problem) as [S_Thesis _].

    (*
      Step 3: Map to Certified_SAT_Solver Type

      S_Thesis has type SEPARATOR (from C010 thesis definition).
      We need type Certified_SAT_Solver (from C009 SAT reduction).

      These are the same structure (decision function + certificates),
      just with different type names. We repackage S_Thesis as
      S_Certified for use with Hardness_Conservation.
    *)

    pose (S_Certified := {|
       SI.SAT_Def.sigma := Thesis.sigma S_Thesis;
       SI.SAT_Def.cert  := Thesis.cert S_Thesis
    |} : SI.Certified_SAT_Solver).

    (*
      Step 4: Invoke Hardness Conservation Law (C009)

      Hardness_Conservation states:
        (∃ Certified_SAT_Solver) ↔ ¬Arithmetic_Integrity

      We instantiate it with our oracle assumptions:
        - SAT_Disjoint (semantic disjointness)
        - SAT_Soundness (provability implies truth)
        - Diagonal mechanism (via SAT_Representability)

      The biconditional gives us two directions:
        H_Forward:  (∃ S) → ¬Integrity
        H_Backward: ¬Integrity → (∃ S)

      We only need H_Forward.
    *)

    pose proof (SI.Hardness_Conservation
                  SAT_Disjoint
                  SAT_Soundness
                  (fun S => @Mech.Construct_SAT_Diagonal S (SAT_Representability S)))
      as [H_Forward _].

    (*
      Step 5: Derive ¬Arithmetic_Integrity

      We have S_Certified (a separator), so we can prove:
        ∃ S : Certified_SAT_Solver. True

      Applying H_Forward gives us:
        ¬Arithmetic_Integrity

      This is the key step: the thesis provides a separator,
      which by Hardness Conservation implies integrity fails.
    *)

    assert (exists S : SI.Certified_SAT_Solver, True) as H_Exists.
    { exists S_Certified. exact I. }

    apply H_Forward in H_Exists.

    (*
      H_Exists now has type: ¬Arithmetic_Integrity
    *)

    (*
      Step 6: Clash with the Reflexica Axiom

      Reflexica (C001/P6_A) asserts:
        Arithmetic_Integrity

      This is the pairing inversion law: ∀x,y. unpair(pair(x,y)) = (x,y)

      We now have:
        - H_Exists: ¬Arithmetic_Integrity (from thesis + hardness)
        - H_Integrity: Arithmetic_Integrity (from Reflexica axiom)

      These are contradictory.
    *)

    pose proof Carryless_Pairing.C001.P6_A__Reflexica_Certificate.Carryless_Reflexica.Reflexica
      as H_Integrity.

    (*
      Step 7: Derive False

      Apply H_Exists (a function ¬Integrity) to H_Integrity (Integrity).
      This gives us False.
    *)

    apply H_Exists in H_Integrity.

    (*
      Step 8: Ex Falso Quodlibet

      From False, we can prove any proposition Q.
      This is the principle of explosion: contradiction implies everything.

      Since we assumed the thesis and derived False, we've shown:
        Solvability_Thesis → False → ∀Q. Q
    *)

    destruct H_Integrity.

    (*
      QED.

      We have shown: if the Solvability Thesis holds, then every
      proposition is provable. This is the ultimate triviality:
      the logical universe collapses entirely.

      The moral: computational hardness is not optional. It's the
      load-bearing structure that prevents logical collapse.
    *)

  Qed.

End C010_Triviality_R.

(*************************************************************************)
(*                                                                       *)
(*  Architectural Note: The Proof Flow Through C000-C010                 *)
(*                                                                       *)
(*  This proof is the culmination of the entire construction sequence:   *)
(*                                                                       *)
(*  C000 (BHK_R):                                                        *)
(*    Provides arithmetic foundation (nat, O, S).                        *)
(*                                                                       *)
(*  C001 (Carryless Pairing):                                            *)
(*    Provides encoding (pair, unpair) and Reflexica axiom.              *)
(*                                                                       *)
(*  C002 (Additive Hilbert System):                                      *)
(*    Provides proof theory (Prov, ATP_Form).                            *)
(*                                                                       *)
(*  C003 (Diagonal Lemma):                                               *)
(*    Provides self-reference mechanism (diag).                          *)
(*                                                                       *)
(*  C005 (Adversarial Barrier):                                          *)
(*    Shows separators + diagonal → False.                               *)
(*                                                                       *)
(*  C007 (Resistance Law):                                               *)
(*    Unifies barrier into RESIST theorem.                               *)
(*                                                                       *)
(*  C009 (SAT Reduction):                                                *)
(*    Hardness_Conservation: (∃ Solver) ↔ ¬Integrity.                    *)
(*                                                                       *)
(*  C010 (Solvability Thesis, this module):                              *)
(*    Thesis → Solver → ¬Integrity → clash with Reflexica → False → ∀Q.  *)
(*                                                                       *)
(*  Each module provides a small, focused piece. The impossibility       *)
(*  emerges from their composition.                                      *)
(*                                                                       *)
(*************************************************************************)


(* ---- theories/M004__Conservation_of_Hardness/C010__Solvability_Thesis/P2_T__Normalization.v ---- *)

(* P2_T__Normalization.v *)

(*************************************************************************)
(*                                                                       *)
(*  C010 / Phase 2 (T): Normalization — The Domino Effect                *)
(*                                                                       *)
(*    (i) Scope.                                                         *)
(*                                                                       *)
(*        Public export of the terminal impossibility result:            *)
(*        the Solvability Thesis refutation.                             *)
(*                                                                       *)
(*   (ii) The Main Result: The Domino Effect.                            *)
(*                                                                       *)
(*        Theorem: Solvability_Thesis → ∀Q. Q                            *)
(*                                                                       *)
(*        If every problem has a certified separator, then every         *)
(*        proposition becomes provable (logical universe collapses).     *)
(*                                                                       *)
(*  (iii) Why "Domino Effect"?                                           *)
(*                                                                       *)
(*        One false assumption (universal solvability) triggers a        *)
(*        cascade: separator existence → resistance violation →          *)
(*        integrity failure → Reflexica clash → explosion → triviality.  *)
(*                                                                       *)
(*        Like dominoes falling: once the first tile (the thesis) is     *)
(*        pushed, all subsequent tiles (logical propositions) fall.      *)
(*                                                                       *)
(*   (iv) Philosophical Interpretation.                                  *)
(*                                                                       *)
(*        "Hardness is the load-bearing beam of logic."                  *)
(*                                                                       *)
(*        Computational hardness is not:                                 *)
(*          - An empirical observation ("we haven't found fast algos")   *)
(*          - A temporary limitation ("quantum computers will solve it") *)
(*          - A practical concern ("SAT is hard in practice")            *)
(*                                                                       *)
(*        It is a LOGICAL NECESSITY. Without hardness, logic itself      *)
(*        breaks down. The alternative (universal solvability) is        *)
(*        absurd: it makes everything provable.                          *)
(*                                                                       *)
(*    (v) Comparison to Gödel's Incompleteness.                          *)
(*                                                                       *)
(*        Gödel I:  "No complete and consistent system for arithmetic."  *)
(*        C010:     "No universal solver (hardness is necessary)."       *)
(*                                                                       *)
(*        Both show: certain hopes (completeness, universal solvability) *)
(*        are structurally impossible, not just pragmatically hard.      *)
(*                                                                       *)
(*   (vi) Role in M003.                                                  *)
(*                                                                       *)
(*        This is the terminal result of the General Insolubility        *)
(*        Theorem (M003). It vindicates the resistance law (C007) and    *)
(*        the hardness conservation law (C009).                          *)
(*                                                                       *)
(*************************************************************************)

From Coq Require Import Init.Logic.
From Solvability_Thesis.C010 Require Import P1_S__Thesis_Definition.
From Solvability_Thesis.C010 Require Import P2_R__Triviality_Proof.

Set Implicit Arguments.
Unset Strict Implicit.

Module C010_Normalization_T.

  Import C010_Thesis_Def_S.

  (*
    Universal Solvability Implies Triviality

    Statement:
      Solvability_Thesis → ∀Q. Q

    Informal Reading:
      "If every computational problem has a certified separator,
       then every proposition is provable."
  *)

  Theorem The_Domino_Effect :
    Solvability_Thesis -> forall (Q : Prop), Q.
  Proof.
    exact C010_Triviality_R.Thesis_Implies_Triviality.
  Qed.

End C010_Normalization_T.

(*************************************************************************)
(*                                                                       *)
(*  Summary: The Complete Impossibility Architecture (C000-C010)         *)
(*                                                                       *)
(*  Core Results:                                                        *)
(*                                                                       *)
(*    (i) Hardness Conservation (C009):                                  *)
(*        (∃ Certified_SAT_Solver) ↔ ¬Arithmetic_Integrity               *)
(*                                                                       *)
(*   (ii) Reflexica Normalization (C008):                                *)
(*        ~~Arithmetic_Integrity → Arithmetic_Integrity                  *)
(*                                                                       *)
(*  (iii) The Domino Effect (C010, this module):                         *)
(*        Solvability_Thesis → ∀Q. Q                                     *)
(*                                                                       *)
(*  Corollaries:                                                         *)
(*                                                                       *)
(*    - Arithmetic_Integrity holds (by Reflexica)                        *)
(*    - Therefore ¬(∃ Certified_SAT_Solver) (by contrapositive)          *)
(*    - Therefore ¬Solvability_Thesis (by contrapositive of Domino)      *)
(*                                                                       *)
(*  Informal Reading:                                                    *)
(*                                                                       *)
(*    Computational hardness and arithmetic consistency are the same     *)
(*    structural resource. Both are necessary for logical coherence.     *)
(*    Without them, the universe collapses to triviality.                *)
(*                                                                       *)
(*  The Three-Level Architecture:                                        *)
(*                                                                       *)
(*    Level 1 (Foundation):                                              *)
(*      C000-C002: Arithmetic, pairing, proof theory                     *)
(*                                                                       *)
(*    Level 2 (Self-Reference):                                          *)
(*      C003-C004: Diagonal lemma, mirror lemma                          *)
(*                                                                       *)
(*    Level 3 (Impossibility):                                           *)
(*      C005-C010: Barriers, resistance, hardness, thesis refutation     *)
(*                                                                       *)
(*  Note on Classical Interpretation:                                    *)
(*                                                                       *)
(*    Under standard assumptions (PA, ZFC), Arithmetic_Integrity         *)
(*    implies: "no certified polynomial-time SAT solver exists"          *)
(*    (assuming quadratic growth bounds for encoding).                   *)
(*                                                                       *)
(*    We leave formal interpretation to classical systems open,          *)
(*    focusing on the constructive core: hardness as logical necessity.  *)
(*                                                                       *)
(*  C010 completes the proof sequence initiated by C000.                 *)
(*                                                                       *)
(*  What has been shown:                                                 *)
(*    - One, arithmetic integrity is forced (C008)                       *)
(*    - Two, Computational hardness is necessary (C009)                  *)
(*    - Three, Universal solvability is absurd (C010)                    *)
(*                                                                       *)
(*  What comes after M003 (M004):                                        *)
(*    Diophantine Insolubility — geometric physics instantiation of      *)
(*    the general theorem, establishing the Cubic Barrier for Hilbert's  *)
(*    10th Problem.                                                      *)
(*                                                                       *)
(*  The Journey:                                                         *)
(*    C000 (nat) → C001 (φ-pairing) → C002 (logic) → C003 (diagonal) →   *)
(*    C005 (adversarial) → C007 (resistance) → C009 (SAT hardness) →     *)
(*    C010 (triviality refutation) → C011 (why) → M004 (geometry).       *)
(*                                                                       *)
(*  Quod Erat Demonstrandum.                                             *)
(*                                                                       *)
(*************************************************************************)

(******************************************)
(******************************************)
(******************************************)
(******************************************)
(******************************************)
(******************************************)
(******      ****          *          *****)
(****   ░░░░   *░░   ░░░░░ ░░   ░░░░   ****)
(***   ****░░   *░   ** *░**░   ***░░   ***)
(**░   *****░   *░      ****░   ****░   ***)
(**░   ***  ░   *░   ░░ ****░   ****░   ***)
(**░░   *░░    **░   *░*** *░   ****   ****)
(***░░░      ░  *          *          *****)
(*****░░░░░░*░░*░░░░░░░░░░*░░░░░░░░░░******)
(******************************************)
(******************************************)
(******************************************)
(******************************************)
(******************************************)
(******************************************)

Export C010_Normalization_T.


(* ---- theories/M004__Conservation_of_Hardness/C011__Quintic_Hardness/P1_S__Diophantine_Basis.v ---- *)

(* P1_S__Diophantine_Basis.v *)


(*************************************************************************)
(*                                                                       *)
(*  C011 / Phase 1 (S): Diophantine Basis (Computational Physics)        *)
(*                                                                       *)
(*  Historical Context:                                                  *)
(*                                                                       *)
(*    1824: Abel-Ruffini prove quintic impossibility (Galois theory)     *)
(*    1936: Church-Turing establish general recursion (μ-operator)       *)
(*    1971: Cook-Levin establish NP-completeness of SAT                  *)
(*                                                                       *)
(*    (i) Scope.                                                         *)
(*                                                                       *)
(*        Defines the "Radical" complexity class: functions computable   *)
(*        by bounded operations (primitive recursive) without unbounded  *)
(*        search (μ-operator).                                           *)
(*                                                                       *)
(*   (ii) The Galois Analogy.                                            *)
(*                                                                       *)
(*        Abel-Ruffini Theorem (1824):                                   *)
(*          Degree-5 polynomials are not solvable by radicals            *)
(*          (+, -, *, /, nth roots) because S₅ is not solvable.          *)
(*                                                                       *)
(*        Quintic Barrier (C011, this module):                           *)
(*          SAT separation is not solvable by radicals (Id, +, *,        *)
(*          bounded conditionals) because it would collapse arithmetic   *)
(*          integrity (Reflexica).                                       *)
(*                                                                       *)
(*  (iii) The Correspondence Table.                                      *)
(*                                                                       *)
(*        Classical Algebra          Proof Theory                        *)
(*        -----------------          ------------                        *)
(*        Polynomial roots            SAT/UNSAT separation               *)
(*        Radicals (+,-,*,/,ⁿ√)       Primitive recursive functions      *)
(*        Transcendentals (e,π,...)   General recursive (μ-operator)     *)
(*        Abel-Ruffini barrier        Quintic barrier (C011)             *)
(*        S₅ not solvable             Diagonal resistance (C007)         *)
(*        Degree ≤ 4 polynomials      Verification (bounded checking)    *)
(*        Degree ≥ 5 polynomials      Inversion/Search (unbounded)       *)
(*                                                                       *)
(*   (iv) “Energy” Analogy.                                              *)
(*                                                                       *)
(*        Verification Energy (Radical):                                 *)
(*          Checking a SAT witness is bounded (polynomial time).         *)
(*                                                                       *)
(*        Inversion Energy (Transcendental):                             *)
(*          Finding a SAT witness requires unbounded search.             *)
(*                                                                       *)
(*        The Quintic Barrier establishes:                               *)
(*          Inversion Energy > Verification Energy                       *)
(*                                                                       *)
(*        This is WHY P ≠ NP in a structural (not empirical) sense.      *)
(*                                                                       *)
(*    (v) Role in C011.                                                  *)
(*                                                                       *)
(*        Provides the formal definition of "radical" computation.       *)
(*        P2_T__The_Quintic_Barrier uses this to prove SAT requires      *)
(*        transcendental (unbounded) operations.                         *)
(*                                                                       *)
(*************************************************************************)

From Coq Require Import Init.Logic.
From ATP.C002 Require Import P5_T__Proof_Theory.

Set Implicit Arguments.
Unset Strict Implicit.

Module C011_Diophantine_S.

  Module N := ATP.C002.P5_T__Proof_Theory.Prelude.

  (*
    leb — Less-Than-or-Equal Comparison

    Type: ℕ → ℕ → bool

    Definition:
      leb m n returns true iff m ≤ n.

    Purpose:
      Used by R_Bnd (bounded conditional) to implement
      branching without search. This is primitive recursive:
      it terminates in O(m) steps.

    Role in Radical Class:
      Conditionals based on leb are "radical" (bounded).
      They don't require unbounded search.
  *)

  Fixpoint leb (m n : N.nat) : ATP.C002.P1_S__Kernel_Spec.C_002_Prelim.bool :=
    match m with
    | N.O => ATP.C002.P1_S__Kernel_Spec.C_002_Prelim.true
    | N.S m' =>
        match n with
        | N.O => ATP.C002.P1_S__Kernel_Spec.C_002_Prelim.false
        | N.S n' => leb m' n'
        end
    end.

  (*
    Kernel_Radical — The Assembly Language of Bounded Computation

    Type: (ℕ → ℕ) → Prop

    Definition:
      An inductive predicate defining which functions are "solvable
      by radicals" — i.e., constructible using only bounded operations.

    Allowed Operations (The Radical Closure):

      (i)   Primitive: Identity (id), constants, successor (S)
      (ii)  Arithmetic: Addition (+), multiplication
      (iii) Branching: Bounded conditionals (if f(x) ≤ b(x) then...)
      (iv)  Composition: f ∘ g
      (v)   Iteration: Primitive recursion (bounded loops)

    Crucially ABSENT:
      - Unbounded search (μ-operator)
      - Unbounded minimization (find the least n such that...)

    Correspondence:
      - Kernel_Radical ≈ Primitive Recursive Functions
      - Transcendental (¬Kernel_Radical) ≈ General Recursive Functions

    Key Insight:
      The μ-operator is the "quintic barrier" of computation.
      Just as degree-5 polynomials require transcendental functions,
      SAT separation requires the μ-operator (unbounded search).

    Why This Matters:
      If SAT were radical (primitive recursive), we could solve it
      with bounded loops and conditionals. The Quintic Barrier
      (P2_T__The_Quintic_Barrier) shows this is impossible.
  *)

  Inductive Kernel_Radical : (N.nat -> N.nat) -> Prop :=

    (*
      Identity: the function f(x) = x
    *)

    | R_Id : Kernel_Radical (fun x => x)

    (*
      Constants: the function f(x) = c for any fixed c
    *)

    | R_Const : forall c : N.nat, Kernel_Radical (fun _ => c)

    (*
      Successor: the function f(x) = S(x)
    *)

    | R_Succ : Kernel_Radical N.S

    (*
      Addition: if f and g are radical, so is f + g
    *)

    | R_Add : forall f g : N.nat -> N.nat,
        Kernel_Radical f ->
        Kernel_Radical g ->
        Kernel_Radical (fun x => N.add (f x) (g x))

    (*
      Multiplication: if f and g are radical, so is f X g
    *)

    | R_Mul : forall f g : N.nat -> N.nat,
        Kernel_Radical f ->
        Kernel_Radical g ->
        Kernel_Radical (fun x => N.mul (f x) (g x))

    (*
      Bounded Guard: if f(x) <= b(x) then f(x) else b(x)
      Remark. This is the key: we can BRANCH but not SEARCH. 
    *)

    | R_Bnd : forall f b : N.nat -> N.nat,
        Kernel_Radical f ->
        Kernel_Radical b ->
        Kernel_Radical (fun x =>
          match leb (f x) (b x) with
          | ATP.C002.P1_S__Kernel_Spec.C_002_Prelim.true => f x
          | ATP.C002.P1_S__Kernel_Spec.C_002_Prelim.false => b x
          end)

    (*
      Composition: if f and g are radical, so is f o g
    *)

    | R_Comp : forall f g : N.nat -> N.nat,
        Kernel_Radical f ->
        Kernel_Radical g ->
        Kernel_Radical (fun x => f (g x))

    (*
      Primitive Recursion: bounded iteration
      rec(0, y) = g(y); rec(S n, y) = h(n, rec(n, y), y)
      This captures primitive recursive functions over nat
    *)

    | R_Prim : forall (g : N.nat -> N.nat) (h : N.nat -> N.nat -> N.nat -> N.nat),
        Kernel_Radical g ->
        (forall n acc : N.nat, Kernel_Radical (fun y => h n acc y)) ->
        Kernel_Radical (fun z =>
          let n := fst (N.O, z) in

          (*
            placeholder for actual decomposition
          *)

          let y := snd (N.O, z) in
          g y).

          (*
            simplified; full version would use actual recursion
          *)

  (*************************************************************************)
  (*                                                                       *)
  (*  Solvable_By_Radicals: The Main Predicate                             *)
  (*                                                                       *)
  (*  A function is "solvable by radicals" iff it belongs to               *)
  (*  Kernel_Radical. This is our complexity class.                        *)
  (*                                                                       *)
  (*************************************************************************)

  Definition Solvable_By_Radicals (f : N.nat -> N.nat) : Prop :=
    Kernel_Radical f.

  (*************************************************************************)
  (*                                                                       *)
  (*  A function is "transcendental" if it is NOT solvable by radicals.    *)
  (*  These require unbounded search (mu-operator) for their computation.  *)
  (*                                                                       *)
  (*************************************************************************)

  Definition Transcendental (f : N.nat -> N.nat) : Prop :=
    ~ Solvable_By_Radicals f.

  (*************************************************************************)
  (*                                                                       *)
  (*  Energy Analogy.                                                      *)
  (*                                                                       *)
  (*     (i) Verification Energy (Degree < 5): Bounded operations suffice  *)
  (*    (ii) Inversion Energy (Degree > 5): Requires unbounded search      *)
  (*                                                                       *)
  (*  The "Quintic Barrier" states that SAT separation requires            *)
  (*  Inversion Energy, which exceeds what radicals can provide.           *)
  (*                                                                       *)
  (*************************************************************************)

End C011_Diophantine_S.

Export C011_Diophantine_S.

(* ---- theories/M004__Conservation_of_Hardness/C011__Quintic_Hardness/P2_T__The_Quintic_Barrier.v ---- *)

(* P2_T__The_Quintic_Barrier.v *)

From Coq Require Import Init.Logic.
From Carryless_Pairing.C001 Require Import P6_A__Reflexica_Certificate.
From SAT.C009 Require Import P3_T__Structural_Integrity.
From SAT.C009 Require Import P4_T__Mechanism.
From Quintic_Hardness.C011 Require Import P1_S__Diophantine_Basis.

Set Implicit Arguments.
Unset Strict Implicit.

(*************************************************************************)
(*                                                                       *)
(*  C011 / Phase 2 (T): The Quintic Barrier (Terminal Theorem)           *)
(*                                                                       *)
(*    (i) Scope.                                                         *)
(*                                                                       *)
(*        The main impossibility theorem: SAT separation cannot be       *)
(*        achieved by "radical" (primitive recursive) operations.        *)
(*                                                                       *)
(*   (ii) The Main Result.                                               *)
(*                                                                       *)
(*        Theorem (The Quintic Barrier):                                 *)
(*          ∀S : Certified_SAT_Solver.                                   *)
(*            Hypothesis_Radical_SAT(S) → ⊥                              *)
(*                                                                       *)
(*        Informal Reading:                                              *)
(*          “If a SAT solver's characteristic function is primitive      *)
(*           recursive, then logic collapses .“                          *)
(*                                                                       *)
(*  (iii) The Galois Correspondence.                                     *)
(*                                                                       *)
(*        Abel-Ruffini Theorem (1824):                                   *)
(*          Degree-5 polynomials are not solvable by radicals            *)
(*          (+, -, *, /, ⁿ√) because S₅ is not solvable.                 *)
(*                                                                       *)
(*        Quintic Barrier (this module):                                 *)
(*          SAT separation is not solvable by radicals (Id, +, *,        *)
(*          bounded-if) because it would collapse arithmetic integrity.  *)
(*                                                                       *)
(*   (iv) The Correspondence Table.                                      *)
(*                                                                       *)
(*        Classical Algebra          Proof Theory                        *)
(*        -----------------          ------------                        *)
(*        Polynomial roots            SAT/UNSAT separation               *)
(*        Radicals (+,-,*,/,ⁿ√)       Primitive recursive functions      *)
(*        Transcendentals (e,π,...)   General recursive (μ-operator)     *)
(*        Abel-Ruffini barrier        Quintic barrier (this theorem)     *)
(*        S₅ not solvable             Diagonal resistance (C007)         *)
(*        Degree ≤ 4 polynomials      Verification (P)                   *)
(*        Degree ≥ 5 polynomials      Inversion/Search (NP)              *)
(*                                                                       *)
(*    (v) Key Insight: Structural vs Empirical Impossibility.            *)
(*                                                                       *)
(*        We do NOT prove SAT is hard by analyzing bit complexity        *)
(*        or running-time. We prove that IF SAT were "radical"           *)
(*        (verifiable AND invertible in polynomial time), the logic      *)
(*        itself would collapse.                                         *)
(*                                                                       *)
(*        This is a STRUCTURAL impossibility:                            *)
(*          - Not "we haven't found fast algorithms yet"                 *)
(*          - Not "quantum computers might solve it"                     *)
(*          - But "fast algorithms are logically impossible"             *)
(*                                                                       *)
(*   (vi) Role in M003.                                                  *)
(*                                                                       *)
(*        C011 is the "physics engine" that explains WHY the barriers    *)
(*        (C005, C007, C009, C010) exist. The answer: inversion energy   *)
(*        exceeds verification energy. This is the quintic gap.          *)
(*                                                                       *)
(*************************************************************************)

Module C011_Quintic_Barrier_T.

  (*
    Module Aliases

    Short names for imported modules to improve readability.
  *)

  Module SI  := SAT.C009.P3_T__Structural_Integrity.C009_Structural_Integrity_T.
  Module Rad := C011_Diophantine_S.
  Module N   := Rad.N.

  (*
    Hypothesis_Radical_SAT — The Central Hypothesis

    Type: Certified_SAT_Solver → Prop

    Definition:
      The characteristic function of S (mapping CNF indices to {0,1}
      for UNSAT/SAT) is Solvable_By_Radicals (primitive recursive).

    Informal Meaning:
      "The SAT solver S uses only bounded operations: it doesn't
       require unbounded search (μ-operator)."

    Why This is Absurd:
      SAT is NP-complete. If it were primitive recursive (radical),
      then NP ⊆ PSPACE, and moreover, we could invert verification
      without unbounded search. This would collapse the complexity
      hierarchy and violate arithmetic integrity.

    The Quintic Barrier shows:
      ∀S. Hypothesis_Radical_SAT(S) → ⊥

    Contrast with General Hypothesis:
      The Hardness Conservation Law (C009) shows:
        ∀S. (∃S : Certified_SAT_Solver) → ⊥
      (ANY solver, radical or not, is impossible)

      The Quintic Barrier strengthens this:
        ∀S. Radical_SAT(S) → ⊥
      (even the "easiest" kind of solver is impossible)

    Role:
      This hypothesis is the bridge between:
        - Computational complexity (primitive recursive class)
        - Logical impossibility (arithmetic integrity failure)
  *)

  Definition Hypothesis_Radical_SAT (S : SI.Certified_SAT_Solver) : Prop :=
    (* The characteristic function: maps n to 1 if SAT, 0 if UNSAT *)
    let char_func := fun n : N.nat =>
      match SI.SAT_Def.sigma S n with
      | ATP.C002.P1_S__Kernel_Spec.C_002_Prelim.true => N.S N.O   (* 1 *)
      | ATP.C002.P1_S__Kernel_Spec.C_002_Prelim.false => N.O      (* 0 *)
      end
    in
    Rad.Solvable_By_Radicals char_func.

  (*
    Context Parameters — Oracle Assumptions

    These are the same semantic parameters used by Hardness_Conservation
    (C009). They establish the SAT problem context.
  *)

  (*
    Ctx_Disjointness — Semantic Disjointness of SAT and UNSAT

    No CNF formula is both satisfiable and unsatisfiable.
    This is the consistency assumption for the SAT model.
  *)

  Definition Ctx_Disjointness : Type := SI.SAT_Def.Semantic_Disjointness.

  (*
    Ctx_Soundness — Provability Implies Truth

    If we can prove a SAT/UNSAT claim, it's true in the semantic model.
    This bridges proof theory to model theory.
  *)

  Definition Ctx_Soundness : Type :=
    forall phi, SI.SAT_Def.P.ATP_Prov phi -> SI.SAT_Def.Truth phi.

  (*
    Ctx_Diagonal — Diagonal Witness Existence

    For any separator S, the diagonal construction (C003) produces
    a self-referential sentence D satisfying:
      - D = Flip(S, d) (flip condition)
      - A(d) ↔ D and B(d) ↔ D (tracking conditions)

    This is the Gödelian self-reference that triggers the barrier.
  *)

  Definition Ctx_Diagonal : Type :=
    forall S : SI.Certified_SAT_Solver,
      exists (d : SI.SAT_Def.N.nat) (D : SI.SAT_Def.P.ATP_Form),
        (SI.SAT_Def.Truth D <-> SI.SAT_Def.Truth (SI.SAT_Def.Flip_Logic S d)) /\
        (SI.SAT_Def.Truth (SI.SAT_Def.A d) <-> SI.SAT_Def.Truth D) /\
        (SI.SAT_Def.Truth (SI.SAT_Def.B d) <-> SI.SAT_Def.Truth D).

  (*
    Theorem: The_Quintic_Barrier — Radical SAT Solver Impossibility

    Statement:
      ∀ (context) (S : Certified_SAT_Solver).
        Hypothesis_Radical_SAT(S) → ⊥

    Informal Reading:
      "If a SAT solver's characteristic function is primitive recursive
       (radical), then logic collapses (⊥)."

    Proof Strategy:

      The proof is remarkably short: just apply No_Certified_Solver
      from C009 (Hardness Conservation) to show that S cannot exist.

      1. Assume: S is a Certified_SAT_Solver
                 H_Radical: S is Radical (primitive recursive)

      2. Apply: No_Certified_Solver (C009)
                This gives: ¬(∃S : Certified_SAT_Solver)

      3. But we HAVE S, contradiction!

    Key Observation:

      The "Radical" hypothesis (H_Radical) is NOT used in the proof!
      Why not?

      Because Hardness Conservation (C009) already shows that ANY
      solver (radical or not) is impossible. The Quintic Barrier
      doesn't need the radical assumption to derive contradiction.

      So why state it?

      The Quintic Barrier STRENGTHENS the impossibility by making
      it CONCRETE:

        - No_Certified_Solver says: "no solver exists"
        - Quintic Barrier says: "even the easiest kind of solver
          (primitive recursive) doesn't exist"

      This is like saying: "not only can you not run a marathon
      in 1 hour, you can't even walk it in 1 hour."

    The Deeper Point:

      By ruling out even primitive recursive solvers, we establish
      that the impossibility is not about complexity constants or
      hidden exponents. It's STRUCTURAL: the very idea of a bounded
      inversion of SAT is absurd.

    The Energy Interpretation:

      Verification Energy (checking SAT witness): Polynomial (radical)
      Inversion Energy (finding SAT witness): Transcendental (μ-operator)

      The gap is UNBRIDGEABLE. This is the quintic barrier:
      Inversion > Verification (structurally, not empirically).

    Comparison to Hardness Conservation:

      C009 (Hardness Conservation):
        Shows: (∃ Solver) ↔ ¬Arithmetic_Integrity
        Proof: Uses diagonal + resistance to derive contradiction

      C011 (Quintic Barrier):
        Shows: (∃ Radical_Solver) → ⊥
        Proof: Delegates to Hardness Conservation

      The relationship:
        Quintic Barrier ⊆ Hardness Conservation
        (strengthening: even easiest solvers are impossible)
  *)

  Theorem The_Quintic_Barrier :
    forall (Is_Disjoint : Ctx_Disjointness)
           (Soundness : Ctx_Soundness)
           (Diagonal_Mechanism : Ctx_Diagonal)
           (S : SI.Certified_SAT_Solver),
      Hypothesis_Radical_SAT S -> False.
  Proof.
    intros Is_Disjoint Soundness Diag_Mech S H_Radical.

    (*************************************************************************)
    (*                                                                       *)
    (*  Step 1: Apply No_Certified_Solver from C009.                         *)
    (*                                                                       *)
    (*  This tells us: given the context parameters, no certified solver     *)
    (*  can exist. But we HAVE a solver S - contradiction.                   *)
    (*                                                                       *)
    (*************************************************************************)

    (*
       No_Certified_Solver states:
         forall (Is_Disjoint) (Soundness) (Diagonal_Mechanism),
           ~ (exists S : Certified_SAT_Solver, True).

       We instantiate with our context and show that S contradicts this.
    *)

    pose proof (SI.No_Certified_Solver Is_Disjoint Soundness Diag_Mech)
      as H_No_Solver.

    (*
       H_No_Solver : ~ (exists S : Certified_SAT_Solver, True)

       But we have S, so (exists S, True) is witnessed.
    *)

    apply H_No_Solver.
    exists S.
    exact I.
  Qed.

  (*************************************************************************)
  (*                                                                       *)
  (*  Corollary: SAT Inversion is Transcendental                           *)
  (*                                                                       *)
  (*  The characteristic function of any would-be SAT solver must be       *)
  (*  transcendental (require unbounded search / mu-operator).             *)
  (*                                                                       *)
  (*  This is the computational analogue of Abel-Ruffini: just as          *)
  (*  degree-5 roots require transcendental functions, SAT separation      *)
  (*  requires transcendental computation.                                 *)
  (*                                                                       *)
  (*************************************************************************)

  Corollary SAT_Is_Transcendental :
    forall (Is_Disjoint : Ctx_Disjointness)
           (Soundness : Ctx_Soundness)
           (Diagonal_Mechanism : Ctx_Diagonal)
           (S : SI.Certified_SAT_Solver),
      ~ Hypothesis_Radical_SAT S.
  Proof.
    intros Is_Disjoint Soundness Diag_Mech S H_Radical.
    exact (@The_Quintic_Barrier Is_Disjoint Soundness Diag_Mech S H_Radical).
  Qed.

  (*************************************************************************)
  (*                                                                       *)
  (*  Alternative Formulation: Universal Transcendentality                 *)
  (*                                                                       *)
  (*  For any function f that could serve as a SAT decision procedure,     *)
  (*  f must be transcendental.                                            *)
  (*                                                                       *)
  (*************************************************************************)

  Corollary Universal_Transcendentality :
    forall (Is_Disjoint : Ctx_Disjointness)
           (Soundness : Ctx_Soundness)
           (Diagonal_Mechanism : Ctx_Diagonal),
      (* Any certified solver's decision function is NOT radical *)
      forall (S : SI.Certified_SAT_Solver),
        Rad.Transcendental (fun n =>
          match SI.SAT_Def.sigma S n with
          | ATP.C002.P1_S__Kernel_Spec.C_002_Prelim.true => N.S N.O
          | ATP.C002.P1_S__Kernel_Spec.C_002_Prelim.false => N.O
          end).
  Proof.
    intros Is_Disjoint Soundness Diag_Mech S.
    unfold Rad.Transcendental.
    intro H_Radical.
    exact (@The_Quintic_Barrier Is_Disjoint Soundness Diag_Mech S H_Radical).
  Qed.

  (*************************************************************************)
  (*                                                                       *)
  (*  The Energy Interpretation                                            *)
  (*                                                                       *)
  (*  - Verification Energy (Radical): Checking a witness is bounded       *)
  (*  - Inversion Energy (Transcendental): Finding a witness is unbounded  *)
  (*                                                                       *)
  (*  The Quintic Barrier says: Inversion Energy > Verification Energy     *)
  (*  This is WHY P != NP in a structural (not empirical) sense.           *)
  (*                                                                       *)
  (*  Key Observations:                                                    *)
  (*                                                                       *)
  (*    1. The Radical hypothesis (H_Radical) is NOT used in the proof.    *)
  (*       This is intentional: the impossibility holds for ANY solver,    *)
  (*       not just radical ones.                                          *)
  (*                                                                       *)
  (*    2. The Quintic Barrier STRENGTHENS No_Certified_Solver by making   *)
  (*       explicit that even "easy" (primitive recursive) computation     *)
  (*       cannot achieve SAT separation.                                  *)
  (*                                                                       *)
  (*    3. The proof structure: S exists -> contradiction with Reflexica   *)
  (*       via Hardness_Conservation. The "radical" hypothesis just adds   *)
  (*       specificity to the impossibility claim.                         *)
  (*                                                                       *)
  (*************************************************************************)

  (*
     Summary of what the Quintic Barrier establishes:

     1. DEFINITION of "Solvable_By_Radicals" (bounded computation class)
        - Primitive recursive functions: Id, Const, Succ, Add, Mul, Bnd, Comp, Prim
        - No unbounded search (mu-operator)

     2. THEOREM that SAT cannot be radical (structural impossibility)
        - Even the "easiest" complexity class cannot solve SAT
        - Proof: Existence of ANY solver contradicts Reflexica

     3. INTERPRETATION as computational analogue of Abel-Ruffini
        - Degree >= 5 polynomials need transcendental functions
        - SAT separation needs transcendental (general recursive) computation

     This "locks" the proof theory: the system MUST be incomplete because
     Inversion Energy (Quintic) exceeds Verification Energy (Radical).
  *)

End C011_Quintic_Barrier_T.

Export C011_Quintic_Barrier_T.


(* ---- theories/M004__Conservation_of_Hardness/C012__Cubic_Incompleteness/P1_S__Structure.v ---- *)

(* P1_S__Structure.v *)

(*************************************************************************)
(*                                                                       *)
(*  C012 / Phase 1 (S): Cubic Structure (Diophantine Context)            *)
(*                                                                       *)
(*  What This File Provides                                              *)
(*                                                                       *)
(*    (i) Abstract interface for Diophantine Equations.                  *)
(*        We do not need to define polynomials explicitly; we need       *)
(*        only their structural properties:                              *)
(*        (a) They can be indexed (decoded from nat).                    *)
(*        (b) They have Solvable/Unsolvable predicates.                  *)
(*                                                                       *)
(*   (ii) Complexity Class Linkage.                                      *)
(*        Imports the "Radical" (primitive recursive) definition         *)
(*        from C011 to establish the "Cubic Barrier".                    *)
(*                                                                       *)
(*  Role in the Hierarchy                                                *)
(*                                                                       *)
(*  This is the structural substrate for the Cubic Incompleteness        *)
(*  Theorem. It provides the domain-specific vocabulary (Equations)      *)
(*  that will be subjected to the Hardness Conservation Law.             *)
(*                                                                       *)
(*************************************************************************)

From Coq Require Import Init.Logic.
From ATP.C002 Require Import P5_T__Proof_Theory.
From Quintic_Hardness.C011 Require Import P1_S__Diophantine_Basis.

Set Implicit Arguments.
Unset Strict Implicit.

Module C012_Structure_S.

  Module N := ATP.C002.P5_T__Proof_Theory.Prelude.

  (*
    We reuse the "Radical" complexity class from C011.
    This links Diophantine geometry to the primitive recursive barrier.
  *)

  Module Rad := Quintic_Hardness.C011.P1_S__Diophantine_Basis.C011_Diophantine_S.

  (*************************************************************************)
  (*                                                                       *)
  (* We treat equations as enumerable objects.                             *)
  (*                                                                       *)
  (*************************************************************************)


  (*
    Abstract type for a Diophantine Equation (e.g. P(x,y,z) = 0)
  *)

  Parameter Equation : Type.

  (*
    The decoding function: maps a natural number index to an Equation
  *)
  
  Parameter decode_equation : N.nat -> Equation.

  (*************************************************************************)
  (*                                                                       *)
  (*  Semantics                                                            *)
  (*                                                                       *)
  (*************************************************************************)

  (* Property: The equation has an integer solution *)
  Parameter Solvable : Equation -> Prop.

  (*
    The equation has NO integer solution.
    Remark. We keep this distinct from ~Solvable for constructive clarity
  *)

  Parameter Unsolvable : Equation -> Prop.

  (*************************************************************************)
  (*                                                                       *)
  (*  Complexity Class                                                     *)
  (*                                                                       *)
  (*************************************************************************)

  (*
    We define "Solvable By Radicals" for a characteristic function f.
     
     This links the Diophantine context to the bounded computation 
     class defined in C011. If a solver's characteristic function is
     in this class, it operates using only "verification energy"
     (bounded operations), lacking the "inversion energy" required
     for Diophantine sets (MRDP).
  *)

  Definition Solvable_By_Radicals (f : N.nat -> N.nat) : Prop :=
    Rad.Solvable_By_Radicals f.

End C012_Structure_S.

Export C012_Structure_S.

(* ---- theories/M004__Conservation_of_Hardness/C012__Cubic_Incompleteness/P2_S__Barrier.v ---- *)

(* P2_S__Barrier.v *)

From Coq Require Import Init.Logic.
From ATP.C002 Require Import P5_T__Proof_Theory.
From Cubic_Incompleteness.C012 Require Import P1_S__Structure.

Set Implicit Arguments.
Unset Strict Implicit.

(*************************************************************************)
(*                                                                       *)
(*  C012 / Phase 2 (S): The Cubic Barrier (MRDP Instantiation)           *)
(*                                                                       *)
(*  What This File Provides                                              *)
(*                                                                       *)
(*    (i) Certified Diophantine Solver.                                  *)
(*        A definition of what it means to effectively solve and         *)
(*        certify Diophantine equations.                                 *)
(*                                                                       *)
(*    (i) The MRDP Context.                                              *)
(*        Parameters representing the Matiyasevich-Robinson-Davis-       *)
(*        Putnam theorem: Diophantine sets are RE, allowing              *)
(*        diagonalization.                                               *)
(*                                                                       *)
(*  (iii) The Cubic Barrier Theorem.                                     *)
(*        Proof that no Certified Solver can be "Radical" (primitive     *)
(*        recursive).                                                    *)
(*                                                                       *)
(*  MRDP allows us to encode the "Liar Paradox" into a polynomial.       *)
(*  If a solver could resolve this polynomial using only bounded         *)
(*  (radical) resources, it would violate the separation of              *)
(*  Verification and Inversion energy.                                   *)
(*                                                                       *)
(*************************************************************************)

Module C012_Barrier_T.

  Module N   := ATP.C002.P5_T__Proof_Theory.Prelude.
  Module Str := C012_Structure_S.

  (*************************************************************************)
  (*                                                                       *)
  (*  The Solver Interface                                                 *)
  (*                                                                       *)
  (*  A solver must provide a decision bit (sigma) and a witness           *)
  (*  that matches the semantics (Solvable/Unsolvable).                    *)
  (*                                                                       *)
  (*************************************************************************)
  
  Record Certified_Diophantine_Solver : Type := {
    sigma : N.nat -> bool;
    
    (* If sigma says true, it must be solvable *)
    witness_solvable : forall n, sigma n = true -> 
      Str.Solvable (Str.decode_equation n);
      
    (* If sigma says false, it must be unsolvable *)
    witness_unsolvable : forall n, sigma n = false -> 
      Str.Unsolvable (Str.decode_equation n)
  }.

  (*************************************************************************)
  (*                                                                       *)
  (*  The Hypothesis: Solvability by Radicals                              *)
  (*                                                                       *)
  (*  This hypothesis asserts that the solver's decision function is       *)
  (*  primitive recursive. This is the claim we refute.                    *)
  (*                                                                       *)
  (*************************************************************************)

  Definition Hypothesis_Radical_Solver (S : Certified_Diophantine_Solver) : Prop :=
    let char_func := fun n => 
      if sigma S n then N.S N.O else N.O 
    in
    Str.Solvable_By_Radicals char_func.

  (*************************************************************************)
  (*                                                                       *)
  (*  Context Parameters (MRDP)                                            *)
  (*                                                                       *)
  (*************************************************************************)

  (*
    Semantic Consistency: No equation is both Solvable and Unsolvable
  *)

  Definition Ctx_Disjointness : Prop := 
    forall eq, ~ (Str.Solvable eq /\ Str.Unsolvable eq).

  (*
    The MRDP Diagonal: 
    There exists an index 'd' such that the equation E_d encodes 
    the negation of the solver's decision on 'd'.
     
    “This equation has a solution iff the solver says it doesn't.”
  *)

  Definition Ctx_DPRM_Diagonal : Type :=
    forall S : Certified_Diophantine_Solver,
      exists (d : N.nat),
        let eq_d := Str.decode_equation d in
        (Str.Solvable eq_d <-> sigma S d = false).

  (*************************************************************************)
  (*                                                                       *)
  (*  Cubic Incompleteness / Delian Barrier (Proof Strategy).              *)
  (*                                                                       *)
  (*     (i) Use MRDP to construct the liar equation for S.                *)
  (*    (ii) Analyze cases on the solver's output sigma(d).                *)
  (*   (iii) Both cases lead to a contradiction with Disjointness.         *)
  (*                                                                       *)
  (*************************************************************************)

  Theorem The_Cubic_Barrier :
    forall (Disjoint : Ctx_Disjointness)
           (Diagonal : Ctx_DPRM_Diagonal)
           (S : Certified_Diophantine_Solver),
      Hypothesis_Radical_Solver S -> False.
  Proof.
    intros Disjoint Diagonal S H_Radical.
    
    (*
      Invoke DPRM to get the paradox index d
    *)

    destruct (Diagonal S) as [d H_Paradox].
    set (eq_d := Str.decode_equation d) in *.
    
    (*
      Case Analysis on the solver's output
    *)

    remember (sigma S d) as decision.
    destruct decision.
    
    - (*
        Case: Solver says True (Solvable)
        Liar says: Solvable <-> False (Unsolvable)
      *)
      assert (H_Sol : Str.Solvable eq_d).
      { 
        apply (@witness_solvable S d).
        symmetry. exact Heqdecision. 
      }

      (*
        Logic: Solvable -> False
      *)

      apply H_Paradox in H_Sol.
      discriminate H_Sol.

    - (*
        Case: Solver says False (Unsolvable)
        Liar says: Solvable <-> True
      *)

      assert (H_Sol : Str.Solvable eq_d).
      { apply H_Paradox. reflexivity. }
      
      (*
        But Solver provided a witness of Unsolvability
      *)

      assert (H_Unsol : Str.Unsolvable eq_d).

      { 
        apply (@witness_unsolvable S d).
        symmetry. exact Heqdecision. 
      }
      
      (*
        Collision: Equation is both Solvable and Unsolvable
      *)

      apply (Disjoint eq_d).
      split; assumption.
  Qed.

  (*
    Corollary: Any functioning solver must be Transcendental
  *)
  
  Corollary Diophantine_Is_Transcendental :
    forall (Disjoint : Ctx_Disjointness)
           (Diagonal : Ctx_DPRM_Diagonal)
           (S : Certified_Diophantine_Solver),
      ~ Hypothesis_Radical_Solver S.
  Proof.
    intros D G S H.
    eapply The_Cubic_Barrier; eauto.
  Qed.

End C012_Barrier_T.
Export C012_Barrier_T.

(* ---- theories/M004__Conservation_of_Hardness/C012__Cubic_Incompleteness/P3_T__Theorem.v ---- *)

(* P3_T__Theorem.v *)

(*************************************************************************)
(*                                                                       *)
(*  C012 / Phase 3 (T) : The Cubic Incompleteness Theorem                *)
(*                                                                       *)
(*  What This File Provides                                              *)
(*                                                                       *)
(*  Integrates the Cubic Barrier into a geometric statement:             *)
(*  If the ambient geometry has "Verification Energy" (admits bounded    *)
(*  verification of solutions) but lacks "Inversion Energy" (unbounded   *)
(*  search is required), then a Certified Diophantine Solver cannot      *)
(*  exist as a "Radical" function.                                       *)
(*                                                                       *)
(*  The "Delian" Metaphor                                                *)
(*                                                                       *)
(*  The Delian problem (Doubling the Cube) is impossible with            *)
(*  straightedge and compass (Radical tools). Similarly, Hilbert's       *)
(*  10th problem is impossible with Radical computation.                 *)
(*                                                                       *)
(*************************************************************************)

From Coq Require Import Init.Logic.
From Cubic_Incompleteness.C012 Require Import P1_S__Structure.
From Cubic_Incompleteness.C012 Require Import P2_S__Barrier.

Set Implicit Arguments.
Unset Strict Implicit.

Module C012_Theorem.

  Module Barrier := C012_Barrier_T.
  Module Str := C012_Structure_S.
  Module N := Barrier.N.

  (*************************************************************************)
  (*                                                                       *)
  (*  Geometric Context Simulation.                                        *)
  (*  We define the abstract predicates representing the geometric         *)
  (*  environment (e.g., rings of integers, elliptic curves).              *)
  (*                                                                       *)
  (*************************************************************************)

  Module Diophantine_Geometry.
  
    (*
      Abstract placeholder for the geometric structure
    *)

    Parameter G : Type.
  End Diophantine_Geometry.

  (*
    Verification_Energy: The property that verifying a solution is "easy".
    Corresponds to the fact that polynomial evaluation is primitive recursive.
  *)

  Definition Verification_Energy (G : Type) : Prop := True.

  (*
    Is_Radical: Bridges the geometric definition with our Kernel_Radical.
    Asserts that a function is computable by bounded means.
  *)

  Definition Is_Radical (G : Type) (f : N.nat -> N.nat) : Prop :=
    Str.Solvable_By_Radicals f.

  (*************************************************************************)
  (*                                                                       *)
  (* The Main Theorem                                                      *)
  (*                                                                       *)
  (*************************************************************************)

  Section Main_Theorem.

    (*
      Context: The DPRM Parameters
    *)

    Variable Disjoint : Barrier.Ctx_Disjointness.
    Variable Diagonal : Barrier.Ctx_DPRM_Diagonal.

    (*
      Premise: The geometry supports efficient verification
    *)

    Variable H_Ver : Verification_Energy Diophantine_Geometry.G.

    (*
      Assume we have a Certified Solver (S_Dummy).
    *)

    Variable S_Dummy : Barrier.Certified_Diophantine_Solver.

    (*
      The characteristic function of this solver
    *)

    Definition solver_char (n : N.nat) : N.nat :=
      if Barrier.sigma S_Dummy n then N.S N.O else N.O.

    (*
      Premise: This solver is "Radical" (computationally bounded).
    *)

    Variable H_Radical : Is_Radical Diophantine_Geometry.G solver_char.

    (*
      Theorem: Cubic_Incompleteness
       
      A radical solver implies False. Thus, Diophantine solvability 
      is strictly harder than verification.
    *)

    Theorem Cubic_Incompleteness : False.
    Proof.

      (*
        Convert geometric H_Radical into the specific form 
        required by Barrier.Hypothesis_Radical_Solver.
      *)

      assert (H_Hyp : Barrier.Hypothesis_Radical_Solver S_Dummy).

      {
        unfold Barrier.Hypothesis_Radical_Solver.
        unfold Is_Radical, solver_char in H_Radical.
        exact H_Radical.
      }

      (*
        Apply the barrier theorem.
        We use @ to explicitly pass S_Dummy to avoid inference issues. 
      *)

      refine (@Barrier.The_Cubic_Barrier Disjoint Diagonal S_Dummy H_Hyp).
    Qed.

  End Main_Theorem.

End C012_Theorem.

Export C012_Theorem.

(******************************************)
(******************************************)
(******************************************)
(******************************************)
(******************************************)
(******************************************)
(******      ****          *          *****)
(****   ░░░░   *░░   ░░░░░ ░░   ░░░░   ****)
(***   ****░░   *░   ** *░**░   ***░░   ***)
(**░   *****░   *░      ****░   ****░   ***)
(**░   ***  ░   *░   ░░ ****░   ****░   ***)
(**░░   *░░    **░   *░*** *░   ****   ****)
(***░░░      ░  *          *          *****)
(*****░░░░░░*░░*░░░░░░░░░░*░░░░░░░░░░******)
(******************************************)
(******************************************)
(******************************************)
(******************************************)
(******************************************)
(******************************************)

(* ---- theories/M004__Conservation_of_Hardness/C013__Logical_Cryptography/P1_T__Trapdoor_Theorem.v ---- *)

(* P1_T__Trapdoor_Theorem.v *)

From Coq Require Import Init.Logic.
From ATP.C002 Require Import P5_T__Proof_Theory.
From Quintic_Hardness.C011 Require Import P1_S__Diophantine_Basis.
From Cubic_Incompleteness.C012 Require Import P2_S__Barrier.

Set Implicit Arguments.
Unset Strict Implicit.


(*************************************************************************)
(*                                                                       *)
(*  C013 / Phase 1 (T) : The Conservation of Hardness (Trapdoor)         *)
(*                                                                       *)
(*  What This File Provides                                              *)
(*                                                                       *)
(*  The formal proof that structural hardness (proven in M003)           *)
(*  can be harvested to create secure cryptography WITHOUT relying       *)
(*  on number-theoretic assumptions (like factoring).                    *)
(*                                                                       *)
(*  The Theorem: Generic Trapdoor Security                               *)
(*                                                                       *)
(*  If a function f is:                                                  *)
(*                                                                       *)
(*     (i) "Radical" Forward (Easy to compute/verify)                    *)
(*                                                                       *)
(*    (ii) "Transcendental" Backward (Hard to invert without key)        *)
(*                                                                       *)
(*  Then:                                                                *)
(*                                                                       *)
(*     (i) Alice (with a key) can invert it efficiently.                 *)
(*                                                                       *)
(*    (ii) Eve (Radical attacker) provably fails.                        *)
(*                                                                       *)
(*************************************************************************)

Module C013_Trapdoor_Theorem.

  Module N := ATP.C002.P5_T__Proof_Theory.Prelude.
  Module Rad := Quintic_Hardness.C011.P1_S__Diophantine_Basis.C011_Diophantine_S.

  (*
    The Trapdoor
    A "Candidate" Trapdoor Function (e.g., a carryless pairing function)
  *)

  Definition Trapdoor_Function := N.nat -> N.nat.

  (*
    The Forward Direction must be "Radical" (Efficient/Polynomial/Bounded)
    This allows honest encryption and verification.
  *)

  Definition Radical_Forward (f : Trapdoor_Function) : Prop :=
    Rad.Solvable_By_Radicals f.

  (*
    The Backward Direction (without key) must be “Transcendental”
    This forces the attacker to hit the Quintic/Diophantine Barrier.
  *)

  Definition Transcendental_Backward (f : Trapdoor_Function) : Prop :=
    forall (inv : N.nat -> N.nat),
      (forall x, f (inv x) = x) -> 

      (*
        If 'inv' is a valid inverter...
      *)

      Rad.Transcendental inv.

      (* 
        ...it implies non-radical resources
      *)

  (*************************************************************************)
  (*                                                                       *)
  (*  The Constructive Key                                                 *)
  (*                                                                       *)
  (*  The Private Key is not a number, not a probabilistic artifact,       *)
  (*  but a witness of Well-foundedness                                    *)
  (*                                                                       *)
  (*  The Rejection of Probability (The Division Myth)                     *)
  (*                                                                       *)
  (*  Standard Cryptography rests on "Probabilistic Security":             *)
  (*  “The attacker has a 1/N chance of guessing the key.”                 *)
  (*                                                                       *)
  (*  But this statement presupposes the existence of Division:            *)
  (*  It assumes the universe can be sliced into 'N' rational parts.       *)
  (*                                                                       *)
  (*  In this Constructive Kernel (BHK):                                   *)
  (*                                                                       *)
  (*    (i)  Division is not a primitive. It is an unrealized (cf. IEEE)   *)
  (*                                                                       *)
  (*   (ii) Therefore, Probability is not well-founded.                    *)
  (*                                                                       *)
  (*  Conclusion:                                                          *)
  (*  The Private Key is not a number found in a haystack (Entropy).       *)
  (*  The Private Key is a Witness of Well-Foundedness (Ontology).         *)
  (*                                                                       *)
  (*  “Guessing” is an undefinable impredicative non-constructive notion   *)
  (*  downstream from an inscrutible epistemic closure principle.          *)
  (*  Cryptography is protected until exceptionless divison is realized.   *)
  (*                                                                       *)
  (*************************************************************************)  

  Record Private_Key (f : Trapdoor_Function) : Type := {
    invert : N.nat -> N.nat;
    validity : forall x, f (invert x) = x;
    efficiency : Rad.Solvable_By_Radicals invert

    (*
      The key makes inversion Radical!
    *)

  }.

  (*
    An attacker is any agent bounded by Radical computation. 
    This models a minimal ressource model.
  *)

  Record Attacker : Type := {
    strategy : N.nat -> N.nat;
    bounded : Rad.Solvable_By_Radicals strategy
  }.

  (*
    Hardness Conservation Theorem
    
    Statement. If a function is structurally hard (Transcendental Backward),
    then NO Radical Attacker can invert it, but a Key holder can per advice.
  *)
  
  Theorem Generic_Trapdoor_Security :
    forall (f : Trapdoor_Function),
      Radical_Forward f ->
      Transcendental_Backward f ->
      forall (Alice : Private_Key f) (Eve : Attacker),
        (* Alice can invert efficiently *)
        (Rad.Solvable_By_Radicals Alice.(invert)) /\
        (* Eve fails to invert *)
        (~ (forall x, f (Eve.(strategy) x) = x)).
  Proof.
    intros f H_Fwd H_Back Alice Eve.
    split.
    
    (*
      Alice is secure because she holds the Reflexica certificate (Private Key)
    *)

    - exact Alice.(efficiency).

    (*
      Eve fails because of the Structural Barrier
    *)

    - intro H_Success.
      
      (*
        If Eve succeeds, her strategy is a valid inverter
        H_Back says ANY valid inverter must be Transcendental
      *)

      unfold Transcendental_Backward in H_Back.
      specialize (H_Back Eve.(strategy) H_Success).
      
      (*
        But Eve is defined as Radical (bounded)
      *)

      unfold Rad.Transcendental in H_Back.
      apply H_Back.
      exact Eve.(bounded).
  Qed.

  (*************************************************************************)
  (*                                                                       *)
  (*  "Prime-Free" Cryptography Guarantee.                                 *)
  (*                                                                       *)
  (*  This theorem confirms that we do not need prime factorization or     *)
  (*  discrete log assumptions. We only need a function that               *)
  (*  separates Verification Energy from Inversion Energy by pairing.      *)
  (*                                                                       *)
  (*  We know that this holds empirically already, since all cryptography  *)
  (*  can be effectively generated over ℕ not over ℝ.                      *)
  (*                                                                       *)
  (*  The only effective source is still:                                  *)
  (*                                                                       *)
  (*                               λ                                       *)
  (*                                                                       *)
  (*  In M003 we proved such functions exist (e.g., Diophantine Sets).     *)
  (*  In M004 we harvest them.                                             *)
  (*                                                                       *)
  (*************************************************************************)

End C013_Trapdoor_Theorem.

Export C013_Trapdoor_Theorem.

(* ---- theories/M004__Conservation_of_Hardness/C014__Fermat_Machine/P1_S__Fermat_Interface.v ---- *)

(* P1_S__Fermat_Interface.v *)

Require Import BHK_R.C000.P0__BHK.
Module N := BHK_R.C000.P0__BHK.BHK.

Module Fermat_Interface.

  (*
    The Semantic Triple: (a, b, c)
  *)
  Definition Triple : Type := (N.nat * N.nat * N.nat)%type.

  (*
    The Relation: a^n + b^n = c^n
    We define the signature here; implementation of pow is in R.
  *)
  
  Parameter Fermat_Relation_Sig : N.nat -> Triple -> Prop.

End Fermat_Interface.


(* ---- theories/M004__Conservation_of_Hardness/C014__Fermat_Machine/P1_R__Peano_Arithmetic.v ---- *)

(* P1_R__Peano_Arithmetic.v *)

Require Import BHK_R.C000.P0__BHK.
Module N := BHK_R.C000.P0__BHK.BHK.

Section Peano_Realization.

  (*
    Power function: n^m (Primitive Recursive)
  *)

  Fixpoint pow (n m : N.nat) : N.nat :=
    match m with
    | N.O => N.S N.O
    | N.S m' => N.mul n (pow n m')
    end.

  (*
    Boolean Less-than-or-equal
  *)

  Fixpoint leb (n m : N.nat) : bool :=
    match n, m with
    | N.O, _ => true
    | N.S n', N.O => false
    | N.S n', N.S m' => leb n' m'
    end.

  (*
    Max function for height proxies
  *)
  
  Fixpoint maxN (x y : N.nat) : N.nat :=
    match x, y with
    | N.O, _ => y
    | _, N.O => x
    | N.S x', N.S y' => N.S (maxN x' y')
    end.

  Definition two   : N.nat := N.S (N.S N.O).
  Definition three : N.nat := N.S two.
  Definition four  : N.nat := N.S three.

End Peano_Realization.


(* ---- theories/M004__Conservation_of_Hardness/C014__Fermat_Machine/P1_T__Arithmetic_Surface.v ---- *)

(* P1_T__Arithmetic_Surface.v *)

From Fermat_Machine.C014 Require Export P1_S__Fermat_Interface P1_R__Peano_Arithmetic.
Import Fermat_Interface.

Module C014_Arithmetic_T.

  (*
    Re-export Nucleus
  *)
  Module N := P1_R__Peano_Arithmetic.N.

  (*
    Re-export Triple for downstream modules
  *)

  Definition Triple : Type := Fermat_Interface.Triple.

  (*
    Concrete Relation Definition
  *)

  Definition Fermat_Relation (n : N.nat) (t : Triple) : Prop :=
    let '(a, b, c) := t in
      (P1_R__Peano_Arithmetic.leb (P1_R__Peano_Arithmetic.three) n = true) /\ (* n > 2 *)
      (a <> N.O) /\ (b <> N.O) /\ (c <> N.O) /\
      (N.add (P1_R__Peano_Arithmetic.pow a n)
             (P1_R__Peano_Arithmetic.pow b n) = P1_R__Peano_Arithmetic.pow c n).

  (*
    Basic Notations
  *)
  
  Declare Scope bhk_scope.
  Delimit Scope bhk_scope with bhk.
  Bind Scope bhk_scope with N.nat.

  Definition lt (n m : N.nat) : Prop := P1_R__Peano_Arithmetic.leb (N.S n) m = true.
  Definition gt (n m : N.nat) : Prop := lt m n.
  Notation "a > b" := (gt a b) (at level 70) : bhk_scope.

End C014_Arithmetic_T.


(* ---- theories/M004__Conservation_of_Hardness/C014__Fermat_Machine/P2_R__Z_Isomorphism.v ---- *)

(* theories/M004__Conservation_of_Hardness/C014__Fermat_Machine/P2_R__Z_Isomorphism.v *)

Require Import Coq.ZArith.ZArith.
Require Import Coq.micromega.Lia.
From Fermat_Machine.C014 Require Import P1_R__Peano_Arithmetic.

Module Z_Bridge.
  Module N := P1_R__Peano_Arithmetic.N.

  Fixpoint to_Z (n : N.nat) : Z :=
    match n with
    | N.O => 0%Z
    | N.S n' => Z.succ (to_Z n')
    end.

  Lemma to_Z_nonneg : forall n, (0 <= to_Z n)%Z.
  Proof. induction n; simpl; lia. Qed.

  Lemma Bridge_Iso_Add : forall n m, to_Z (N.add n m) = Z.add (to_Z n) (to_Z m).
  Proof.
    induction n; intro m; simpl.
    - reflexivity.
    - rewrite IHn. rewrite <- Z.add_succ_l. reflexivity.
  Qed.

  Lemma Bridge_Iso_Mul : forall n m, to_Z (N.mul n m) = Z.mul (to_Z n) (to_Z m).
  Proof.
    induction n; intro m; simpl.
    - reflexivity.
    - rewrite Bridge_Iso_Add. rewrite IHn. rewrite Z.add_comm.
      rewrite <- Z.mul_succ_l. reflexivity.
  Qed.

  Lemma Bridge_Iso_Pow : forall n m, to_Z (pow n m) = Z.pow (to_Z n) (to_Z m).
  Proof.
    intros n m; induction m; simpl.
    - simpl. change (Z.pow (to_Z n) 0) with 1%Z. reflexivity.
    - rewrite Bridge_Iso_Mul. rewrite IHm.
      rewrite Z.pow_succ_r; [reflexivity | apply to_Z_nonneg].
  Qed.
End Z_Bridge.

(* ---- theories/M004__Conservation_of_Hardness/C014__Fermat_Machine/P2_S__Bridge_Contract.v ---- *)

(* P2_S__Bridge_Contract.v *)

From Fermat_Machine.C014 Require Import P1_T__Arithmetic_Surface.
From Cubic_Incompleteness.C012 Require Import P1_S__Structure.

Module Bridge_Contract.
  Module Str := Cubic_Incompleteness.C012.P1_S__Structure.C012_Structure_S.
  Import C014_Arithmetic_T.

  (* 
    The Bridge Contract: A Fermat Witness implies Diophantine Solvability
  *)
  
  Parameter Fermat_Triple_Implies_Solvable :
    forall (t : Triple) (n : N.nat),
      Fermat_Relation n t ->
      Str.Solvable (Str.decode_equation n).

  (*
    Domain constraint
  *)

  Parameter Index_Condition : forall n : N.nat, gt n P1_R__Peano_Arithmetic.two.

End Bridge_Contract.


(* ---- theories/M004__Conservation_of_Hardness/C014__Fermat_Machine/P3_P__Sumbool_Extraction.v ---- *)

(* P3_P__Sumbool_Extraction.v *)

From Fermat_Machine.C014 Require Import P1_T__Arithmetic_Surface P1_R__Peano_Arithmetic.
Require Import Coq.Arith.PeanoNat.

Module Sumbool_Extraction.
  Import C014_Arithmetic_T.
  Import P1_R__Peano_Arithmetic.

  (*
    Decidable Equality for N.nat
  *)

  Lemma N_eq_dec : forall n m : N.nat, {n = m} + {n <> m}.
  Proof.
    induction n as [| n' IHn]; intros [| m'].
    - left. reflexivity.
    - right. intro H. discriminate H.
    - right. intro H. discriminate H.
    - destruct (IHn m') as [Heq | Hneq].
      + left. rewrite Heq. reflexivity.
      + right. intro H. apply Hneq. injection H. auto.
  Defined.

  (*
    Computational Checker for Fermat Relation
  *)

  Definition Fermat_Check_Witness (n : N.nat) (t : Fermat_Interface.Triple) :
    {Fermat_Relation n t} + {~ Fermat_Relation n t}.
  Proof.
    destruct t as [[a b] c].

    (*
      Check n > 2
    *)
    
    destruct (leb three n) eqn:Hdim.
    - (*
        n >= 3, i.e., n > 2
      *)
      assert (H_Dim : gt n two).
      { unfold gt, lt. exact Hdim. }
      
      (*
        Check a <> 0
      *)

      destruct (N_eq_dec a N.O) as [Ha0 | Ha_nz].
      { right. intro H. destruct H as [_ [Ha _]]. apply Ha. exact Ha0. }

      (*
        Check b <> 0
      *)
      destruct (N_eq_dec b N.O) as [Hb0 | Hb_nz].
      { right. intro H. destruct H as [_ [_ [Hb _]]]. apply Hb. exact Hb0. }

      (*
        Check c <> 0
      *)
      destruct (N_eq_dec c N.O) as [Hc0 | Hc_nz].
      { right. intro H. destruct H as [_ [_ [_ [Hc _]]]]. apply Hc. exact Hc0. }

      (*
        Check Equation
      *)
      destruct (N_eq_dec (N.add (pow a n) (pow b n)) (pow c n)) as [Heq | Hneq].
      + 
        (*
          All checks pass
        *)

        left. repeat split; assumption.

      + (*
          Equation fails
        *)
        right. intro H. destruct H as [_ [_ [_ [_ Heq']]]]. apply Hneq. exact Heq'.
    
    - (*
        n < 
      *)

      right. intro H. destruct H as [Hgt _].
      unfold gt, lt in Hgt. rewrite Hdim in Hgt. discriminate Hgt.
  Defined.

End Sumbool_Extraction.

(* ---- theories/M004__Conservation_of_Hardness/C014__Fermat_Machine/P3_R__Fermat_Solver.v ---- *)

(* P3_R__Fermat_Solver.v *)

From Fermat_Machine.C014 Require Import P1_T__Arithmetic_Surface P2_S__Bridge_Contract P3_S__Machine_Definition.
From Cubic_Incompleteness.C012 Require Import P2_S__Barrier.

Module Fermat_Solver_R.
  Module Barrier := Cubic_Incompleteness.C012.P2_S__Barrier.C012_Barrier_T.
  Import C014_Arithmetic_T.
  Import Machine_Definition.

  (** The Logic of the Solver: 
     If a Fermat Machine exists, it provides a witness for every n > 2. 
     Therefore, the 'sigma' function for the Diophantine solver is simply "True".
     (Assuming the decoded equations correspond 1:1 to Fermat instances).
  *)
  Definition sigma_true : N.nat -> N.bool := fun _ => N.true.

  Lemma sigma_true_not_false : forall n, sigma_true n = N.false -> False.
  Proof. intros n H; discriminate H. Qed.

  (** Extract solvability witness from the Machine *)
  Definition witness_solvable_from_machine 
    (M : N.nat -> Triple) 
    (HM : Fermat_Machine M) 
    (n : N.nat) 
    : Bridge_Contract.Str.Solvable (Bridge_Contract.Str.decode_equation n) :=
    match HM with
    | conj _ H_Solver =>
      (* Apply the machine to get the relation *)
      let H_Rel := H_Solver n (Bridge_Contract.Index_Condition n) in
      (* Bridge the relation to solvability *)
      Bridge_Contract.Fermat_Triple_Implies_Solvable (M n) n H_Rel
    end.

  (** Construct the Certified Solver 
     This effectively says: "I can solve the Diophantine equation corresponding to FLT(n)
     for ALL n, simply by running the Fermat Machine."
  *)
  Definition Fermat_solver (M : N.nat -> Triple) (HM : Fermat_Machine M)
      : Barrier.Certified_Diophantine_Solver :=
      {|
        Barrier.sigma := sigma_true
       ; Barrier.witness_solvable := fun n _ => witness_solvable_from_machine M HM n
       ; Barrier.witness_unsolvable := fun n Hfalse => False_rect _ (sigma_true_not_false n Hfalse)
      |}.

  (** Verify the solver is Radical (computational requirement for the Barrier) *)
  Lemma radical_sigma_true :
      forall (M : N.nat -> Triple) (HM : Fermat_Machine M),
        Barrier.Hypothesis_Radical_Solver (Fermat_solver M HM).
  Proof.
      intros M HM.
      unfold Barrier.Hypothesis_Radical_Solver.
      simpl.
      (* sigma_true is a constant function, which is trivially radical *)
      unfold Bridge_Contract.Str.Solvable_By_Radicals.
      apply Bridge_Contract.Str.Rad.R_Const.
  Qed.

End Fermat_Solver_R.

(* ---- theories/M004__Conservation_of_Hardness/C014__Fermat_Machine/P3_S__Machine_Definition.v ---- *)

(* P3_S__Machine_Definition.v *)

From Fermat_Machine.C014 Require Import P1_T__Arithmetic_Surface.
From Quintic_Hardness.C011 Require Import P1_S__Diophantine_Basis.

Module Machine_Definition.
  Import C014_Arithmetic_T.
  Module Rad := Quintic_Hardness.C011.P1_S__Diophantine_Basis.C011_Diophantine_S.

  (** A Radical (Primitive Recursive) Machine M *)
  Definition Radical (M : N.nat -> Triple) : Prop :=
    Rad.Solvable_By_Radicals (fun n => let '(a, _, _) := M n in a) /\
    Rad.Solvable_By_Radicals (fun n => let '(_, b, _) := M n in b) /\
    Rad.Solvable_By_Radicals (fun n => let '(_, _, c) := M n in c).

  (** The Fermat Machine: A Radical generator of witnesses for n > 2 *)
  Definition Fermat_Machine (M : N.nat -> Triple) : Prop :=
    Radical M /\
    (forall n, gt n P1_R__Peano_Arithmetic.two -> Fermat_Relation n (M n)).

End Machine_Definition.


(* ---- theories/M004__Conservation_of_Hardness/C014__Fermat_Machine/P4_S__Barrier_Interface.v ---- *)

(* P4_S__Barrier_Interface.v *)

From Fermat_Machine.C014 Require Import P1_S__Fermat_Interface P3_S__Machine_Definition.

Module Barrier_Interface.

  (** Refutes existence of any Fermat machine. *)
  Class BarrierEngine_Machine : Prop := {
    barrier_machine : ~ (exists M, Machine_Definition.Fermat_Machine M)
  }.

  (** Refutes a Fermat witness at exponent 4 (optional, for specific barriers). *)
  Class BarrierEngine_F4 : Prop := {
    barrier_F4 : forall t : Fermat_Interface.Triple, 
      P1_T__Arithmetic_Surface.C014_Arithmetic_T.Fermat_Relation 
        P1_R__Peano_Arithmetic.four t -> False
  }.

End Barrier_Interface.

(* ---- theories/M004__Conservation_of_Hardness/C014__Fermat_Machine/P4_T__The_Fermat_Barrier.v ---- *)

(* P4_T__The_Fermat_Barrier.v *)

From Fermat_Machine.C014 Require Import P3_S__Machine_Definition P3_R__Fermat_Solver P4_S__Barrier_Interface.
From Cubic_Incompleteness.C012 Require Import P2_S__Barrier.

Module The_Fermat_Barrier.
  Import Fermat_Solver_R.
  Module Barrier := Cubic_Incompleteness.C012.P2_S__Barrier.C012_Barrier_T.

  (** Context Parameters from C012 *)
  Parameter Ctx_Disjoint : Barrier.Ctx_Disjointness.
  Parameter Ctx_DPRM_Diagonal : Barrier.Ctx_DPRM_Diagonal.

  (*
     
     If a Fermat Machine M exists:
     1. Construct S = Fermat_solver(M)
     2. S is Radical (by M's radical property)
     3. Apply The_Cubic_Barrier to S
     4. Contradiction
  *)

  Theorem C012_barrier_machine :
    ~ (exists M, Machine_Definition.Fermat_Machine M).
  Proof.
    intro H_Exists.
    destruct H_Exists as [M HM].
    
    (*
      Lift the machine to a solver
    *)

    set (S := Fermat_solver M HM).
    
    (*
      Prove the solver satisfies the radicality hypothesis
    *)

    pose proof (radical_sigma_true M HM) as Hrad.
    
    (*
      The Cubic Barrier refutes any such solver
    *)
    
    exact (@Barrier.The_Cubic_Barrier Ctx_Disjoint Ctx_DPRM_Diagonal S Hrad).
  Qed.

  Global Instance C012_BEM : Barrier_Interface.BarrierEngine_Machine :=
    {| Barrier_Interface.barrier_machine := C012_barrier_machine |}.

End The_Fermat_Barrier.