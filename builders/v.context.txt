(* Note. This is a concatenation for establishing context. *)
(* Source: _TextslectFLT *)
(* Generated (UTC): 2026-02-07T10:30:49Z *)

(* ---- BEGIN _TextslectFLT ---- *)
(*  *)
(* # --- M001 --- *)
(* theories/M001__Mechanical_Semantics/C016__Kolmogorov_Equivalence/P1_T__Kolgmorov_Equivalence.v *)
(*  *)
(* # --- M002 --- *)
(* theories/M002__BHK_R_Arithmetic/C000__BHK_R/P0__BHK.v *)
(* theories/M002__BHK_R_Arithmetic/C000__BHK_R/P0__Reflexica.v *)
(*  *)
(* theories/M002__BHK_R_Arithmetic/C001__Carryless_Pairing/P5_T__Carryless_Pairing.v *)
(* theories/M002__BHK_R_Arithmetic/C001__Carryless_Pairing/P5_T__Effectivity.v *)
(* theories/M002__BHK_R_Arithmetic/C001__Carryless_Pairing/P6_A__Reflexica_Certificate.v *)
(*  *)
(* theories/M002__BHK_R_Arithmetic/C002__Additive_Hilbert_System/P5_T__Proof_Theory.v *)
(* theories/M002__BHK_R_Arithmetic/C002__Additive_Hilbert_System/P6_P__Effectivity.v *)
(*  *)
(* # --- M004 -- *)
(* # --- M006 --- *)
(* theories/M006__Logical_Cryptography/C013__Trapdoor_Lemma/P1_T__Trapdoor_Lemma.v *)
(* theories/M006__Logical_Cryptography/C013__Trapdoor_Lemma/P1_T__Trapdoor_Thesis.v *)
(* theories/M006__Logical_Cryptography/C013__Trapdoor_Lemma/P2_T__Trivial_Vault.v *)
(*  *)
(* theories/M006__Logical_Cryptography/C017__Carryless_Vault/P1_T__Carryless_Vault.v *)
(*  *)
(*  *)
(* theories/M003__Carryless_Proof_Theory/C004__Mirror_Lemma/P1_S__Context.v *)
(* theories/M003__Carryless_Proof_Theory/C004__Mirror_Lemma/P2_R__Mirror_Core.v *)
(* theories/M003__Carryless_Proof_Theory/C004__Mirror_Lemma/P2_S__Mirror_Lemma.v *)
(* theories/M003__Carryless_Proof_Theory/C004__Mirror_Lemma/P3_T__Weakforcing.v *)
(*  *)
(* theories/M003__Carryless_Proof_Theory/C018__Symbolic_Regulation/P1_R__Core.v *)
(* theories/M003__Carryless_Proof_Theory/C018__Symbolic_Regulation/P2_S__Interfaces.v *)
(* theories/M003__Carryless_Proof_Theory/C018__Symbolic_Regulation/P3_R__Provability_Inclusion.v *)
(* theories/M003__Carryless_Proof_Theory/C018__Symbolic_Regulation/P4_S__Mirror_Bridge.v *)
(* theories/M003__Carryless_Proof_Theory/C018__Symbolic_Regulation/P5_T__Symbolic_Regulation.v *)
(* theories/M003__Carryless_Proof_Theory/C018__Symbolic_Regulation/P6_A__Provability_Inclusion.v *)
(* theories/M003__Carryless_Proof_Theory/C018__Symbolic_Regulation/P7_T__Limitative_Combinatorics.v *)
(* ---- END _TextslectFLT ---- *)



(* ---- theories/M001__Mechanical_Semantics/C016__Kolmogorov_Equivalence/P1_T__Kolgmorov_Equivalence.v ---- *)

(* P1_T__Kolgmorov_Equivalence *)

(*************************************************************************)
(*                                                                       *)
(*  C015: The Kolmogorov Equivalence (Mechanical Blurring)               *)
(*                                                                       *)
(*  (A “Kolmogorov-style” limit.)                                        *)
(*                                                                       *)
(*  Consider a finite machine with a capacity (tape or RAM).             *)
(*  Any number n > Capacity cannot be represented distinctly.            *)
(*                                                                       *)
(*  We prove (by pigeonhole) that any pairing P(x,y) must collide for    *)
(*  inputs exceeding capacity, hence uniform “Reflexica” inversion is    *)
(*  not realizable effectively under Machine_Read collapse.              *)
(*                                                                       *)
(*************************************************************************)

Require Import Coq.Init.Nat.
Require Import Coq.Arith.Arith.
Require Import Coq.Arith.PeanoNat.
Require Import Coq.micromega.Lia.

Module Kolmogorov_Equivalence.

  (*
    Machine model: a fixed, a priori finite capacity.
  *)

  Parameter Capacity : nat.

  (*
    Machine_Read models finite resolution:
    if an input exceeds Capacity, the machine collapses it to a ghost value 0.
  *)

  Definition Machine_Read (n : nat) : nat :=
    if n <=? Capacity then n else 0.

  (*
    Pairing / unpairing interface.
  *)

  Parameter P : nat -> nat -> nat.
  Parameter U : nat -> (nat * nat).

  (*
    Radical_Unpair: the machine unpairs only what it can read.
  *)

  Definition Radical_Unpair (z : nat) : (nat * nat) :=
    U (Machine_Read z).

  (*
    Reflexica_Holds: uniform inversion for all inputs.
  *)

  Definition Reflexica_Holds : Prop :=
    forall (x y : nat), Radical_Unpair (P x y) = (x, y).

  (*
    Entropic crash: if P is at least as large as its first input, then
    uniform inversion cannot hold under Machine_Read collapse.
  *)

  Theorem The_Entropic_Crash :
    (forall x y, P x y >= x) -> ~ Reflexica_Holds.
  Proof.
    unfold Reflexica_Holds.
    intros H_growth H_Reflexica.

    (*
      Two distinct “high-entropy” inputs above Capacity.
    *)

    pose (x1 := S Capacity).
    pose (x2 := S (S Capacity)).
    pose (y  := 0).

    (*
      P x_i y is above Capacity by growth.
    *)

    assert (H_High1 : P x1 y > Capacity).
    { unfold x1. specialize (H_growth (S Capacity) y). lia. }

    assert (H_High2 : P x2 y > Capacity).
    { unfold x2. specialize (H_growth (S (S Capacity)) y). lia. }

    (*
      Therefore Machine_Read collapses both encodings to 0.
    *)

    assert (H_Read1 : Machine_Read (P x1 y) = 0).

    { unfold Machine_Read.
      assert (Hleb : (P x1 y <=? Capacity) = false).
      { apply (proj2 (Nat.leb_gt (P x1 y) Capacity)). exact H_High1. }
      rewrite Hleb. reflexivity. }

    assert (H_Read2 : Machine_Read (P x2 y) = 0).

    { unfold Machine_Read.
      assert (Hleb : (P x2 y <=? Capacity) = false).
      { apply (proj2 (Nat.leb_gt (P x2 y) Capacity)). exact H_High2. }
      rewrite Hleb. reflexivity. }

    (*
      Apply Reflexica to both inputs, then rewrite by the collapse.
    *)

    assert (H_Res1 : Radical_Unpair (P x1 y) = (x1, y)) by apply H_Reflexica.
    assert (H_Res2 : Radical_Unpair (P x2 y) = (x2, y)) by apply H_Reflexica.

    unfold Radical_Unpair in H_Res1, H_Res2.
    rewrite H_Read1 in H_Res1.
    rewrite H_Read2 in H_Res2.

    (*
      U 0 is forced to equal both (x1,y) and (x2,y), hence x1 = x2.
    *)

    rewrite H_Res1 in H_Res2.
    apply (f_equal fst) in H_Res2.
    simpl in H_Res2.
    rename H_Res2 into H_Conflict.

    (*
      But x1 and x2 are distinct: S Capacity = S (S Capacity) contradicts n_Sn.
    *)

    unfold x1, x2 in H_Conflict.
    apply n_Sn in H_Conflict.
    exact H_Conflict.
  Qed.

(*************************************************************************)
(*                                                                       *)
(*  This frames Reflexica as a limitative entry point of any common      *)
(*  sense notion of  “arithmetic truth.”                                 *)
(*                                                                       *)
(*************************************************************************)

End Kolmogorov_Equivalence.

(* ---- theories/M002__BHK_R_Arithmetic/C000__BHK_R/P0__BHK.v ---- *)

(* P0__BHK.v *)

(******************************************************************************)
(*                                                                            *)
(*                ██████╗ ██╗  ██╗██╗  ██╗        ██████╗                     *)
(*                ██╔══██╗██║  ██║██║ ██╔╝        ██╔══██╗                    *)
(*                ██████╔╝███████║█████╔╝         ██████╔╝                    *)
(*                ██╔══██╗██╔══██║██╔═██╗         ██╔══██╗                    *)
(*                ██████╔╝██║  ██║██║  ██╗███████╗██║  ██║                    *)
(*                ╚═════╝ ╚═╝  ╚═╝╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝                    *)
(*                                                                            *)
(*     This defines the “BHK meaning nucleus” shared by all later phase.      *)
(*     The methodology is repository-wide and project-agnostic.               *)
(*                                                                            *)
(*     (i)    A proposition is identified with the type of its proof.         *)
(*                                                                            *)
(*     (ii)   To prove a proposition is to construct an inhabitant            *)
(*            of that type.                                                   *)
(*                                                                            *)
(*     (iii)  Logical connectives and quantifiers are understood via          *)
(*            their introduction forms and corresponding proof objects;       *)
(*            functions, dependent pairs, tagged alternatives, etc.           *)
(*                                                                            *)
(*     In particular, equalities proved below are witnessed                   *)
(*     by computation (definitional equality), not by appeal to               *)
(*     extensional principles or additional axioms. The emphasis is on        *)
(*     explicit constructions whose meaning is stable under reduction.        *)
(*                                                                            *)
(*     BHK remains the informal proof-theoretic semantics, whereas            *)
(*     BHK_R denotes an additional discipline:                                *)
(*                                                                            *)
(*     (i)    A minimal inductive core,                                       *)
(*                                                                            *)
(*     (ii)   Explicit primitive recursion,                                   *)
(*                                                                            *)
(*     (iii)  A fixed phase structure.                                        *)
(*                                                                            *)
(*     The preferred notion of reasoning is kernel conversion:                *)
(*     definitional equality via β, ι, ζ, and transparent δ, together         *)
(*     with explicit recursion on inductive data. Many foundational           *)
(*     equations are therefore stated in conversion-friendly normal           *)
(*     forms and discharged by simplification to eq_refl.                     *)
(*                                                                            *)
(*     Phase structure.                                                       *)
(*                                                                            *)
(*     (i)    A construction is the first-class organizing principle          *)
(*            (hence folders start with 'C').                                 *)
(*                                                                            *)
(*     (ii)    For each phase,                                                *)
(*                                                                            *)
(*            (a) Realizations ('R') provide concrete constructions           *)
(*                (Fixpoint/Definition plus explicit proof terms);            *)
(*            (b) BHK proof semantics ('S') package realizations              *)
(*                behind minimal interfaces (typically small records)         *)
(*                and establish interoperability results (translations,       *)
(*                simulations, or extensional agreement on functions);        *)
(*            (c) Theorems ('T') serve as entry/exit points: lemmas and       *)
(*                theorems intended for downstream use.                       *)
(*            (d) Certificates ('A') form a recursive loop.                   *)
(*                                                                            *)
(*      Design Principles.                                                    *)
(*                                                                            *)
(*     (i)    No classical axioms (LEM, Compactness) at this level.           *)
(*                                                                            *)
(*     (ii)   Avoid large numeric towers and heavyweight libraries.           *)
(*                                                                            *)
(*     (iii)  Prefer small “façades” (records/modules) over large             *)
(*            signatures to reduce coupling between realizations and          *)
(*            keep computation explicit, sequential, and intensional.         *)
(*                                                                            *)
(*     In short. We establish meaning once (Phase 0); realize it explicitly   *)
(*     (by _R_ files); then relate realizations conservatively (_S_ files),   *)
(*     yielding either a new phase, an export, or both.                       *)
(*                                                                            *)
(******************************************************************************)

From Coq Require Import Init.Logic.

Set Implicit Arguments.
Unset Strict Implicit.

Module BHK.

  (*************************************************************************)
  (*                                                                       *)
  (*    We map “Rocq types“ to their Constructive Logic interpretation     *)
  (*    and their corresponding computational witnesses.                   *)
  (*                                                                       *)
  (*    Rocq Type              BHK Interpretation     Realizer Structure   *)
  (*    ------------------     ------------------     ------------------   *)
  (*    False                  ∸ (Absurd)             (none)               *)
  (*    and P Q                P ∧ Q                  ⟨p, q⟩               *)
  (*    or  P Q                P ∨ Q                  inl p  |  inr q      *)
  (*    P -> Q                 P → Q                  λx. body             *)
  (*    exists (fun x => P)    ∃x. P(x)               ⟨x, p⟩               *)
  (*    forall (x:A), P        ∀x. P(x)               λx. body             *)
  (*                                                                       *)
  (*    If we have...          we construct by...     to realize...        *)
  (*    ------------------     ------------------     ------------------   *)
  (*    p ⊨ P, q ⊨ Q           conj p q               P ∧ Q                *)
  (*    p ⊨ P                  or_introl p            P ∨ Q                *)
  (*    q ⊨ Q                  or_intror q            P ∨ Q                *)
  (*    x ↦ y where y ⊨ Q      fun x => y             P → Q                *)
  (*    x : A, p ⊨ P(x)        ex_intro x p           ∃x. P(x)             *)
  (*    x ↦ y where y ⊨ P x    fun x => y             ∀x. P(x)             *)
  (*                                                                       *)
  (*               cf. A. S. Troelstra and D. van Dalen:                   *)
  (*                  Constructivism in Mathematics                        *)
  (*                                                                       *)
  (*************************************************************************)


  (*
    A minimal Arithmetic Kernel (nat) with explicit primitive recursion
    This is intentionally not [ Coq.Init.Datatypes.nat ]. BHK reading:

    (i)    The inductive type [ nat ] is a canonical constructive object,

    (ii)   [ O ] and [ S ] are constructors giving the canonical proofs,

    (iii)  Induction / recursion corresponds to case analysis on proofs.

    The “goal” is to keep the computational behavior fully transparent
    and independent of any larger library abstractions.
  *)

  Inductive nat : Type :=
    | O : nat
    | S : nat -> nat.

  (*
    Primitive recursive definitions

    (i)    [ add ] and [ mul ] are not axiomatic relations but algorithms.

    (ii)   To know [ add m n ] is to be able to compute it by reducing [ m ].

    (iii)  These definitions serve as witnesses of existence claims about sums
           and products.
  *)

  Fixpoint add (m n : nat) : nat :=
    match m with
    | O => n
    | S m' => S (add m' n)
    end.

  Fixpoint mul (m n : nat) : nat :=
    match m with
    | O => O
    | S m' => add n (mul m' n)
    end.

  (*
    Each theorem below asserts an equality whose proof is computationally
    trivial. The proof object is eq_refl, witnessing that both sides reduce
    to the same normal form.
  *)

  Theorem add_O_l : forall n, add O n = n.
  Proof.
    intro n; simpl; exact (eq_refl _).
  Qed.

  (*
    [ add (S m) n ] computes by one step of successor introduction.
    Under BHK, this expresses how a proof of [ add (S m) n ] is constructed
    from a proof of [ add m n ].
  *)

  Theorem add_S_l : forall m n, add (S m) n = S (add m n).
  Proof.
    intro m; intro n; simpl; exact (eq_refl _).
  Qed.

  (*
    Multiplication with zero reduces immediately.
    This corresponds to the canonical computation witnessing that
    zero times any number is zero.
  *)

  Theorem mul_O_l : forall n, mul O n = O.
  Proof.
    intro n; simpl; exact (eq_refl _).
  Qed.

  (*
    Successor case for multiplication. The equation expresses the recursive
    construction of a product:

    [ (S m) * n ] is witnessed by [ n + (m * n) ].
  *)

  Theorem mul_S_l : forall m n, mul (S m) n = add n (mul m n).
  Proof.
    intro m; intro n; simpl; exact (eq_refl _).
  Qed.

End BHK.


(* ---- theories/M002__BHK_R_Arithmetic/C000__BHK_R/P0__Reflexica.v ---- *)

(* P0__Reflexica.v *)

(******************************************************************************)
(*                                                                            *)
(*    ██████╗ ███████╗███████╗██╗     ███████╗██╗  ██╗██╗ ██████╗ █████╗      *)
(*    ██╔══██╗██╔════╝██╔════╝██║     ██╔════╝╚██╗██╔╝██║██╔════╝██╔══██╗     *)
(*    ██████╔╝█████╗  █████╗  ██║     █████╗   ╚███╔╝ ██║██║     ███████║     *)
(*    ██╔══██╗██╔══╝  ██╔══╝  ██║     ██╔══╝   ██╔██╗ ██║██║     ██╔══██║     *)
(*    ██║  ██║███████╗██║     ███████╗███████╗██╔╝ ██╗██║╚██████╗██║  ██║     *)
(*    ╚═╝  ╚═╝╚══════╝╚═╝     ╚══════╝╚══════╝╚═╝  ╚═╝╚═╝ ╚═════╝╚═╝  ╚═╝     *)
(*                                                                            *)
(*                                                                            *)
(*     We define the repository-wide notion of an opt-in “global              *)
(*     inversion certificate” for an effective coding device.                 *)
(*                                                                            *)
(*     It must remain parametric and must not depend on any later             *)
(*     constructions. The guiding discipline is:                              *)
(*                                                                            *)
(*     (i)    Effective computation lives in R/S layers of                    *)
(*            later constructions (definitions compute).                      *)
(*                                                                            *)
(*     (ii)   Uniform correctness laws that are not derivable                 *)
(*            in pure core are isolated behind a single named                 *)
(*            inhabitant, never assumed implicitly.                           *)
(*                                                                            *)
(*     Axiom.                                                                 *)
(*                                                                            *)
(*     We assume, as our first realization, that our effective                *)
(*     “Carryless Pairing” operation (pi, pi^-1), that is                     *)
(*                                                                            *)
(*            forall x y, unpair (pair x y) = (x, y)                          *)
(*            --------------------------------------                          *)
(*                                                                            *)
(*     Holds.                                                                 *)
(*                                                                            *)
(*     We justify it by the “Geometric Iterant”, cf. arXiv:2510.08934,        *)
(*     but any non-trivial RE source of arithmetic pre-realizability would    *)
(*     suffice.                                                               *)
(*                                                                            *)
(******************************************************************************)

    
From Coq Require Import Init.Logic.
From C000 Require Export P0__BHK.

Set Implicit Arguments.
Unset Strict Implicit.

  Module Reflexica.

  (*
    Remark: we use the canonical product nat * nat, which has definitional
    projections [fst] and [snd], avoiding additional “pair type” bureaucracy
    in the base layer.
  *)

  Module Type PAIRING_SIG.
    Parameter nat : Type.

    (*
      The coding operations under certification.
    *)

    Parameter pair   : nat -> nat -> nat.
    Parameter unpair : nat -> nat * nat.

  End PAIRING_SIG.

  (*
    Remark. Many constructions can implement pair/unpair effectively (totalr
    recursion), but cannot prove the global inversion law inside the pure
    BHK_R core without additional structure.

    Reflexica packages exactly one missing inhabitant, so that later
    developments can depend on it explicitly and locally, rather than
    importing untracked arithmetic or classical principles.
  *)

  Module Make (P : PAIRING_SIG).

    (*************************************************************************)
    (*                                                                       *)
    (*  A construction that wants certified inversion provides an            *)
    (*  inhabitant of REFLEXICA. Typical usage in later constructions:       *)
    (*                                                                       *)
    (*     Module C := Reflexica.Make(MyPairing).                            *)
    (*     Parameter R : C.REFLEXICA.                                        *)
    (*                                                                       *)
    (*  The certificate can later be replaced by an explicit constructive    *)
    (*  proof without changing downstream APIs.                              *)
    (*                                                                       *)
    (*************************************************************************)

    Record REFLEXICA : Prop := {
      unpair_pair :
        forall x y : P.nat,
          P.unpair (P.pair x y) = (x, y)
    }.

    (*
      Exported form of the certificate field.
      This is merely a projection, but naming it makes downstream dependencies
      explicit: “this proof holds if Reflexica holds.”
    *)

    Definition unpair_pair_reflexica (r : REFLEXICA) :
      forall x y : P.nat, P.unpair (P.pair x y) = (x, y) :=
      unpair_pair r.

    (*
      Derived projections.

      From the certified round-trip we immediately obtain the ability to recover
      components of the original pair by applying [ fst/snd ].
      These lemmas are often the only facts downstream users need.
    *)
    
    Definition fst_unpair_pair_reflexica (r : REFLEXICA) :
      forall x y : P.nat, fst (P.unpair (P.pair x y)) = x :=
      fun x y =>
        eq_trans (f_equal fst (unpair_pair_reflexica r x y))
                 (eq_refl x).

    Definition snd_unpair_pair_reflexica (r : REFLEXICA) :
      forall x y : P.nat, snd (P.unpair (P.pair x y)) = y :=
      fun x y =>
        eq_trans (f_equal snd (unpair_pair_reflexica r x y))
                 (eq_refl y).

    (*************************************************************************)
    (*                                                                       *)
    (*  Injectivity on the image.                                            *)
    (*                                                                       *)
    (*  The certificate implies that pair is injective:                      *)
    (*                                                                       *)
    (*      pair x1 y1 = pair x2 y2  ->  x1 = x2  /\  y1 = y2                *)
    (*                                                                       *)
    (*  This is a “decode both sides” argument, our “Γ |- t:T”               *)
    (*                                                                       *)
    (*  We keep the proof term elementary (f_equal + rewriting)              *)
    (*                                                                       *)
    (*************************************************************************)

    Theorem pair_inj_reflexica (r : REFLEXICA) :
      forall x1 y1 x2 y2 : P.nat,
        P.pair x1 y1 = P.pair x2 y2 ->
        x1 = x2 /\ y1 = y2.

    Proof.
      intros x1 y1 x2 y2 H.
      split.
      - pose proof (f_equal P.unpair H) as Hu.
        pose proof (f_equal fst Hu) as Hf.
        rewrite (fst_unpair_pair_reflexica r x1 y1) in Hf.
        rewrite (fst_unpair_pair_reflexica r x2 y2) in Hf.
        exact Hf.
      - pose proof (f_equal P.unpair H) as Hu.
        pose proof (f_equal snd Hu) as Hs.
        rewrite (snd_unpair_pair_reflexica r x1 y1) in Hs.
        rewrite (snd_unpair_pair_reflexica r x2 y2) in Hs.
        exact Hs.

    Qed.

  End Make.

End Reflexica.

(*************************************************************************)
(*                                                                       *)
(*  Why must this remain an Axiom?                                       *)
(*                                                                       *)
(*  We intentionally do NOT “bind” this certificate to the Rocq kernel's *)
(*  definitional equality (e.g., via Rewrite Rules or reduced terms).    *)
(*  The "Gap" between the computational realization (R) and this         *)
(*  certificate (A) is structural.                                       *)
(*                                                                       *)
(*  If we were to "internalize" this law (make it definitionally true),  *)
(*  we would assert:                                                     *)
(*                                                                       *)
(*  Arithmetic_Integrity == True, leading to contradiction:              *)
(*                                                                       *)
(*         (Exists Certified_Solver) <-> ~Arithmetic_Integrity           *)
(*                                                                       *)
(*  If Arithmetic Integrity were unconditional, we could simply          *)
(*  "ask" our proof environment to solve the inversion. We cannot.       *)
(*                                                                       *)
(*  Our silicon chips, are merely a mechanized method of notation,       *)
(*  a “very fast“ abacus. The preferred notion of reasoning herein is    *)
(*   kernel conversion: definitional equality limited to                 *)
(*                                                                       *)
(*                  β, ι, ζ, and transparent δ.                          *)
(*                                                                       *)
(*  To confuse this mechanical “rewrite“ with semantic truth is          *)
(*  to assume the ambient universe is trivial.                           *)
(*                                                                       *)
(*  We will be aware of this distinction throughout.                     *)
(*                                                                       *)
(*************************************************************************)

(*
  “Simple” BHK_R public surface.
  Policy: re-export only the arithmetic nucleus and the Reflexica 
  interface, without assuming any certificate.
*)

Module Prelude := C000.P0__BHK.BHK.



(* ---- theories/M002__BHK_R_Arithmetic/C001__Carryless_Pairing/P5_T__Carryless_Pairing.v ---- *)

(* P5_T__Carryless_Pairing.v *)

From Coq Require Import Init.Logic.
From C001 Require Export
  P1_S__Substrate
  P2_S__Carryless
  P3_S__Injectivity
  P4_S__Pairing.

Set Implicit Arguments.
Unset Strict Implicit.

(*************************************************************************)
(*                                                                       *)
(*  C001 / Phase 5 (T): Carryless Pairing (Public Surface)               *)
(*                                                                       *)
(*  This is the phase-free entry point for C001. It exposes the stable   *)
(*  facades and canonical instances required by downstream developments  *)
(*  (C002+), hiding all internal realization details.                    *)
(*                                                                       *)
(*  Policy,                                                              *)
(*                                                                       *)
(*   (i)    Single Canonical Reality: We export exactly one effective    *)
(*          realization for Fibonacci (StandardFib) and one for          *)
(*          (StandardNatInj). No redundant "A/B" implementations exist.  *)
(*                                                                       *)
(*   (ii)   Device Access: The Pairing device is exposed via the         *)
(*          [ CL_PAIR ] interface, backed by the Zeckendorf realization. *)
(*                                                                       *)
(*   (iii)  No Axioms: All theorems here are proven by kernel            *)
(*          computation (eq_refl) or direct destructor elimination.      *)
(*          The Global Inversion Law is NOT present here;                *)
(*                                                                       *)
(*************************************************************************)

(*
  Stable Conceptual Namespaces
*)

Module Prelude := C001.P1_S__Substrate.Prelude.
Module Fib     := C001.P2_S__Carryless.Carryless_Semantics.
Module NatInj  := C001.P3_S__Injectivity.NatInj_Semantics.
Module Pairing := C001.P4_S__Pairing.Pairing_Semantics.

(*  
  Facade Types
*)

Definition FIB : Type := Fib.FIB.
Definition NAT_INJ : Prop := NatInj.NAT_INJ.
Definition CL_PAIR : Type := Pairing.CL_PAIR.

(*
  Single, effective realization for each concept
*)

(*
  The efficient accumulator-based Fibonacci
*)

Definition StandardFib : FIB := Fib.StandardFib.

(*
  The match-based constructor laws
*)

Definition StandardNatInj : NAT_INJ := NatInj.StandardNatInj.

(*
  The Zeckendorf carryless pairing device
*)

Definition CarrylessPair : CL_PAIR := Pairing.CarrylessPair.

(*
  Constructive destructors for the arithmetic nucleus
  Injectivity: S m = S n -> m = n
*)

Theorem S_inj_public :
  forall m n : Prelude.nat, Prelude.S m = Prelude.S n -> m = n.
Proof.
  exact NatInj.S_inj_interop.
Qed.

(*
  Discrimination: O <> S n
*)

Theorem O_not_S_public :
  forall n : Prelude.nat, Prelude.O <> Prelude.S n.
Proof.
  exact NatInj.O_S_discr_interop.
Qed.

(*
  Discrimination: S n <> O
*)

Theorem S_not_O_public :
  forall n : Prelude.nat, Prelude.S n <> Prelude.O.
Proof.
  exact NatInj.S_O_discr_interop.
Qed.


(* ---- theories/M002__BHK_R_Arithmetic/C001__Carryless_Pairing/P5_T__Effectivity.v ---- *)

(* P4_T__Effectivity.v *)

From C001 Require Import P5_T__Carryless_Pairing.
From Coq Require Import Init.Logic.

Set Implicit Arguments.
Unset Strict Implicit.

(*************************************************************************)
(*                                                                       *)
(*  This file is intentionally not part of the logical development       *)
(*  chain (C002+). It is an effectivity witness and executable           *)
(*  documentation, not a theory module.                                  *)
(*                                                                       *)
(*   C001.P5_T__Carryless_Pairing                                        *)
(*                                                                       *)
(*   It serves three roles:                                              *)
(*                                                                       *)
(*   (i)    Demonstrate that the carryless pairing and unpairing         *)
(*          functions are computationally effective (i.e., reduce by     *)
(*          kernel computation without axioms).                          *)
(*                                                                       *)
(*   (ii)   Provide concrete, executable witnesses of correctness        *)
(*          for small values, suitable for vm_compute evaluation.        *)
(*                                                                       *)
(*   (iii)  Act as a regression / documentation test that the façade-    *)
(*          level pairing interface (Prelude / Pairing) is wired         *)
(*          correctly to its realization.                                *)
(*                                                                       *)
(*   Methodology note (BHK_R discipline):                                *)
(*                                                                       *)
(*   All correctness statements here are witnessed by computation, that  *)
(*   is by [ vm_compute ], not by propositional reasoning or axioms.     *)
(*                                                                       *)
(*   In particular:                                                      *)
(*                                                                       *)
(*   (i)    [ unpair (pair x y) ] reduces definitionally to (x, y);      *)
(*                                                                       *)
(*   (ii)   Fibonacci ranks, bands, and Zeckendorf supports are          *)
(*          observed as concrete normal forms.                           *)
(*                                                                       *)
(*************************************************************************)

Module Test_Pairing_Small.

  Module N := Prelude.
  Module P := Pairing.
  Module R := P.R.

  (* This allows us to write readable constants (e.g., "5") in tests. *)

  Fixpoint of_nat (n : Coq.Init.Datatypes.nat) : N.nat :=
    match n with
    | Coq.Init.Datatypes.O => N.O
    | Coq.Init.Datatypes.S k => N.S (of_nat k)
    end.

  (*
    Local list constructors for the project's list type.
  *)

  Definition lnil : R.list N.nat := R.nil.
  Definition lcons (a : Coq.Init.Datatypes.nat) (xs : R.list N.nat) : R.list N.nat :=
    R.cons (of_nat a) xs.
  Definition l1 (a : Coq.Init.Datatypes.nat) : R.list N.nat := lcons a lnil.
  Definition l2 (a b : Coq.Init.Datatypes.nat) : R.list N.nat := lcons a (l1 b).

  (*
    Project-pair projection without relying on any external libraries.
  *)

  Definition fst {A B} (p : R.prod A B) : A :=
    match p with R.pair a _ => a end.
  Definition snd {A B} (p : R.prod A B) : B :=
    match p with R.pair _ b => b end.

  (*************************************************************************)
  (*                                                                       *)
  (*  TEST 1: x=1, y=1                                                     *)
  (*  Expected: pair(1,1)=37; Z(1)={2}; r(1)=3; B=6;                       *)
  (*           even_band={4}; odd_band={9};                                *)
  (*           Z(pair)= {9,4}; unpair(pair)= (1,1).                        *)
  (*                                                                       *)
  (*  We verify the entire pipeline,                                       *)
  (*                                                                       *)
  (*   (i)    Zeckendorf support Z(1);                                     *)
  (*                                                                       *)
  (*   (ii)   Rank r(1) and Band B(1);                                     *)
  (*                                                                       *)
  (*   (iii)  Even/Odd band construction;                                  *)
  (*                                                                       *)
  (*   (iv)   final pairing value and Unpairing round-trip.                *)
  (*                                                                       *)
  (*************************************************************************)

  (*
    Remark. Convenience embedding of Coq's built-in nat into the
  *)

  Definition x11 : N.nat := of_nat 1.
  Definition y11 : N.nat := of_nat 1.

  (*
    Check exact value: [ pair(1,1) ] should correspond to [ index 37 ].
  *)

  Example test_pair_1_1_value :
    P.pair CarrylessPair x11 y11 = of_nat 37.
  Proof. vm_compute. reflexivity. Qed.

  (*
    Verify internals: Z(1) = [2]
  *)

  Example test_Z_1 :
    P.Z CarrylessPair x11 = l1 2.
  Proof. vm_compute. reflexivity. Qed.

  (*
    Verify internals: rank r(1) = 3
  *)

  Example test_r_1 :
    P.r CarrylessPair x11 = of_nat 3.
  Proof. vm_compute. reflexivity. Qed.

  (*
    Verify internals: band offset B(1) = 6
  *)

  Example test_B_1 :
    P.B CarrylessPair x11 = of_nat 6.
  Proof. vm_compute. reflexivity. Qed.

  (*
    Verify round-trip: [ unpair(pair(1,1)) ] reduces to [ (1,1) ]
  *)

  Example test_even_band_1 :
    P.even_band CarrylessPair x11 = l1 4.
  Proof. vm_compute. reflexivity. Qed.

  Example test_odd_band_1_1 :
    P.odd_band CarrylessPair x11 y11 = l1 9.
  Proof. vm_compute. reflexivity. Qed.

  Example test_Z_pair_1_1 :
    P.Z CarrylessPair (P.pair CarrylessPair x11 y11) = l2 9 4.
  Proof. vm_compute. reflexivity. Qed.

  Example test_unpair_pair_1_1_fst :
    fst (P.unpair CarrylessPair (P.pair CarrylessPair x11 y11)) = x11.
  Proof. vm_compute. reflexivity. Qed.

  Example test_unpair_pair_1_1_snd :
    snd (P.unpair CarrylessPair (P.pair CarrylessPair x11 y11)) = y11.
  Proof. vm_compute. reflexivity. Qed.

  (*
    TEST 2: x=5, y=3
    Expected: pair(5,3) = 4236; unpair(pair) = (5,3).
  *)

  Definition x53 : N.nat := of_nat 5.
  Definition y53 : N.nat := of_nat 3.

  (*
    Check value
  *)

  Example test_pair_5_3_value :
    P.pair CarrylessPair x53 y53 = of_nat 4236.
  Proof. vm_compute. reflexivity. Qed.

  (*
    Check round-trip
  *)

  Example test_unpair_pair_5_3_fst :
    fst (P.unpair CarrylessPair (P.pair CarrylessPair x53 y53)) = x53.
  Proof. vm_compute. reflexivity. Qed.

  Example test_unpair_pair_5_3_snd :
    snd (P.unpair CarrylessPair (P.pair CarrylessPair x53 y53)) = y53.
  Proof. vm_compute. reflexivity. Qed.

End Test_Pairing_Small.


(* ---- theories/M002__BHK_R_Arithmetic/C001__Carryless_Pairing/P6_A__Reflexica_Certificate.v ---- *)

(* P6_A__Reflexica_Certificate.v *)

From Coq Require Import Init.Logic.
From Coq Require Import Logic.ConstructiveEpsilon.
From Coq Require Import Arith.PeanoNat.
From C000 Require Import P0__Reflexica.
From C001 Require Export P5_T__Carryless_Pairing.

Set Implicit Arguments.
Unset Strict Implicit.

(*************************************************************************)
(*                                                                       *)
(*   C001 / Phase 6 (A) : Reflexica Certificate (Certificate Layer)      *)
(*                                                                       *)
(*   This module provides the "Global Inversion Certificate" for the     *)
(*   Carryless Pairing device.                                           *)
(*                                                                       *)
(*   While Phases R, S, and T provide an effective *device* that         *)
(*   computes correctly (witnessed by regression tests), they do NOT     *)
(*   export a logical proof that 'unpair' inverts 'pair' for ALL inputs. *)
(*                                                                       *)
(*   Modularity:                                                         *)
(*                                                                       *)
(*   (i)    Opt-in: This file is separated from P5_T. One can use the    *)
(*          device computationally without accepting                     *)
(*          this.                                                        *)
(*                                                                       *)
(*   (ii)   Minimal: We assume only the single record instance. All      *)
(*          other theorems (injectivity, projections) are derived        *)
(*          constructively from that single point of failure.            *)
(*                                                                       *)
(*   (iii)  We provide a method of switching between models of           *)
(*          “arithmetic truth”.                                          *)
(*                                                                       *)
(*************************************************************************)

Module Carryless_Reflexica.

  Module N := Prelude.
  Module P := Pairing.

  (*
    We adapt the Carryless Pairing device to match the input signature
    expected by the generic Reflexica functor.
  *)

  Module Sig <: P0__Reflexica.Reflexica.PAIRING_SIG.
    Definition nat : Type := N.nat.

  (*
    Remark. Reflexica expects a return type of (nat * nat), so we map the
    device's custom product type to the standard tuple. We adapt the Carryless
    Pairing device to match the input signature expected by the generic
    Reflexica functor.
  *)

    Definition pair : nat -> nat -> nat := P.pair CarrylessPair.
    Definition unpair (z : nat) : nat * nat :=
      let p := P.unpair CarrylessPair z in (P.fst p, P.snd p).
  End Sig.

  Module Cert := P0__Reflexica.Reflexica.Make(Sig).

  Definition REFLEXICA : Prop := Cert.REFLEXICA.

  (*************************************************************************)
  (*                                                                       *)
  (*  Set to [ true ]  for the BHK_R approach: single structural axiom     *)
  (*  Set to [ false ] for the Rocq approach: “tactics“                    *)
  (*                                                                       *)
  (*************************************************************************)

  Definition USE_BHK_R : bool := false.

  (*************************************************************************)
  (*                                                                       *)
  (*  The axiom is motivated by the structural correspondence between      *)
  (*  logical inference (Modus Ponens) and the geometric limit (Golden     *)
  (*  Ratio). This correspondence is formalized through the Fibonacci      *)
  (*  recurrence, which converges to φ = (1 + √5)/2.                       *)
  (*                                                                       *)
  (*  The fundamental observation: no finitary rational representation     *)
  (*  can fully capture an irrational limit. This gap between finite       *)
  (*  computation and infinite convergence is the essence of Reflexica.    *)
  (*                                                                       *)
  (*************************************************************************)

  Module BHK_R_Approach.
    Axiom axiom : REFLEXICA.
  End BHK_R_Approach.

  (*************************************************************************)
  (*                                                                       *)
  (*  While this approach appears to avoid axioms by using Section         *)
  (*  hypotheses, the resulting theorem requires inhabitants of these      *)
  (*  propositions. Without proving the Zeckendorf properties (uniqueness, *)
  (*  band separation), these must ultimately be assumed.                  *)
  (*                                                                       *)
  (*************************************************************************)

  Module Rocq_Approach.

    (*
      The development follows standard Rocq methodology:

      (i)   Formalize the proof within a Section, parametrized by
            explicit hypotheses regarding Zeckendorf representation

      (ii)  Establish the correctness theorem constructively under
            these assumptions

      (iii) Export the theorem, making its dependencies transparent

      Comparative Analysis:

      Both BHK_R and Standard Library approaches require foundational
      assumptions about any pairing function's representation.
      The distinction lies in presentation: BHK_R uses a single structural
      axiom with motivation, while the Standard Library approach
      decomposes this into technical hypotheses about computational properties
      via [ Coq.Logic.ConstructiveEpsilon ]. Even if latter omits the “Law of
      the excluded middle”, it still turns an existence proof into a concrete
      witness.
    *)

    Section Carryless_Correctness.

      Import P.R.

      (*
        The following three hypotheses capture the essential properties
        of Zeckendorf representation required for correctness:

        H1. Soundness: The Zeckendorf support correctly represents
            numbers as sums of Fibonacci values.

        H2. Even Band Preservation: Filtering the Zeckendorf support
            of pair(x,y) by even indices recovers the encoding of x.

        H3. Odd Band Preservation: Filtering by odd indices above the
            band threshold B(x) recovers the encoding of y.

        These hypotheses formalize the structural properties that make
        the carryless pairing construction bijective. They correspond
        to the single REFLEXICA axiom in the BHK_R approach.
      *)

      Hypothesis Z_sound :
        forall n, P.R.sumF (P.Z CarrylessPair n) = n.

      Hypothesis Z_even_split :
        forall x y,
          P.R.filter P.R.is_even (P.Z CarrylessPair (P.pair CarrylessPair x y))
          = P.even_band CarrylessPair x.

      Hypothesis Z_odd_split :
        forall x y,
          P.R.filter (P.R.odd_ge_B1 (P.B CarrylessPair x))
                     (P.Z CarrylessPair (P.pair CarrylessPair x y))
          = P.odd_band CarrylessPair x y.

      (*************************************************************************)
      (*                                                                       *)
      (*  We assume arithmetic consistency bellow.                             *)
      (*                                                                       *)
      (*************************************************************************)

      Lemma two_S : forall n, P.R.two (N.S n) = N.S (N.S (P.R.two n)).
      Proof.
        intro n.
        unfold P.R.two.
        simpl.
        (* Requires: commutativity and successor laws for N.add *)
        admit.
      Admitted.

      Lemma div2_two : forall n, P.R.div2 (P.R.two n) = n.
      Proof.
        induction n as [|n IH].
        - simpl. reflexivity.
        - rewrite two_S. simpl. rewrite IH. reflexivity.
      Qed.

      Lemma map_div2_even_band :
        forall x, P.R.map P.R.div2 (P.even_band CarrylessPair x) = P.Z CarrylessPair x.
      Proof.
        intro x.
        unfold P.even_band.
        unfold P.R.even_band.
        (* Requires: extensional equality map (div2 ∘ two) = id *)
        admit.
      Admitted.

      Lemma decode_encode_odd :
        forall Bx j,
          P.R.decode_odd_index Bx (N.add Bx (P.R.two_j_minus1 j)) = j.
      Proof.
        intros Bx j.
        unfold P.R.decode_odd_index, P.R.two_j_minus1.
        (* Requires: arithmetic properties of monus and div2 *)
        admit.
      Admitted.

      Lemma map_decode_odd_band :
        forall x y,
          P.R.map (P.R.decode_odd_index (P.B CarrylessPair x))
                  (P.odd_band CarrylessPair x y)
          = P.Z CarrylessPair y.
      Proof.
        intros x y.
        unfold P.odd_band.
        unfold P.R.odd_band.
        (* Follows from map extensionality and decode_encode_odd *)
        admit.
      Admitted.

      (*
        These lemmas establish that the unpairing operation correctly
        recovers the original components. They follow directly from
        the Zeckendorf hypotheses combined with the arithmetic
        infrastructure developed above.
      *)

      Lemma sumF_half_even_pair :
        forall x y,
          P.R.sumF (P.R.half_even_indices (P.Z CarrylessPair (P.pair CarrylessPair x y))) = x.
      Proof.
        intros x y.
        unfold P.R.half_even_indices.
        rewrite Z_even_split.
        rewrite map_div2_even_band.
        apply Z_sound.
      Qed.

      Lemma sumF_y_indices_pair :
        forall x y,
          P.R.sumF (P.R.y_indices (P.B CarrylessPair x)
                                  (P.Z CarrylessPair (P.pair CarrylessPair x y))) = y.
      Proof.
        intros x y.
        unfold P.R.y_indices.
        rewrite Z_odd_split.
        rewrite map_decode_odd_band.
        apply Z_sound.
      Qed.

      (*
        The inversion property follows from the recovery lemmas.
        The proof requires navigating the product type conversions
        between the custom P.R.prod and standard Coq pairs.
      *)

      Theorem unpair_pair_thm :
        forall x y, Sig.unpair (Sig.pair x y) = (x, y).
      Proof.
        intros x y.
        unfold Sig.unpair, Sig.pair.
        unfold P.unpair, P.pair.
        (* Requires: applying sumF_half_even_pair and sumF_y_indices_pair
           with appropriate type conversions and product manipulations *)
        admit.
      Admitted.

    End Carryless_Correctness.

    (*
      Upon closing the Section, the theorem unpair_pair_thm acquires
      the following type:

        forall (Z_sound : ...) (Z_even_split : ...) (Z_odd_split : ...),
          forall x y, unpair (pair x y) = (x, y)

      The hypotheses become explicit parameters. To instantiate the
      certificate, we require inhabitants of these three propositions.
    *)

    Axiom Z_sound_ax :
      forall n, P.R.sumF (P.Z CarrylessPair n) = n.

    Axiom Z_even_split_ax :
      forall x y,
        P.R.filter P.R.is_even (P.Z CarrylessPair (P.pair CarrylessPair x y))
        = P.even_band CarrylessPair x.

    Axiom Z_odd_split_ax :
      forall x y,
        P.R.filter (P.R.odd_ge_B1 (P.B CarrylessPair x))
                   (P.Z CarrylessPair (P.pair CarrylessPair x y))
        = P.odd_band CarrylessPair x y.

    Definition certificate : REFLEXICA.
    Proof.
      constructor.
      apply unpair_pair_thm.
      - exact Z_sound_ax.
      - exact Z_even_split_ax.
      - exact Z_odd_split_ax.
    Qed.

    (*
     
      Observation. [ ConstructiveEpsilon ] does not eliminate the need for
      foundational assumptions. It provides a mechanism to extract constructive
      witnesses from existence proofs, but the existence proof itself must be
      established through other means.

      Comparative Summary:

      BHK_R_Approach: 1 axiom (structural, philosophically motivated)
      
      Rocq_Approach: 3 axioms (technical, computationally specific)

      Both approaches formalize the same underlying mathematical content
      regarding Zeckendorf representation. The distinction lies in
      presentation and philosophical interpretation, not in the
      elimination of foundational assumptions.

      The Standard Library provides valuable computational tools
      (ConstructiveEpsilon, decidability machinery), but the core
      mathematical content (Zeckendorf uniqueness, band separation)
      remains an essential prerequisite in either framework.
    *)

  End Rocq_Approach.

  (*
    The following definition implements the configuration switch,
    selecting between the two certification approaches based on
    the USE_BHK_R boolean flag.
  *)

  Definition Reflexica : REFLEXICA :=
    match USE_BHK_R with
    | true  => BHK_R_Approach.axiom
    | false => Rocq_Approach.certificate
    end.

  (*************************************************************************)
  (*                                                                       *)
  (*  The acceptance of an initial realization establishes constructive    *)
  (*  validity. The absence of a realization for the absurd serves as the  *)
  (*  de facto consistency witness. Within this framework, well-founded    *)
  (*  recursion provides the structural guarantee of termination.          *)
  (*                                                                       *)
  (*************************************************************************)

  Definition unpair_pair_reflexica :
    forall x y : N.nat,
      Sig.unpair (Sig.pair x y) = (x, y) :=
    Cert.unpair_pair_reflexica Reflexica.

  Definition fst_unpair_pair_reflexica :
    forall x y : N.nat,
      fst (Sig.unpair (Sig.pair x y)) = x :=
    Cert.fst_unpair_pair_reflexica Reflexica.

  Definition snd_unpair_pair_reflexica :
    forall x y : N.nat,
      snd (Sig.unpair (Sig.pair x y)) = y :=
    Cert.snd_unpair_pair_reflexica Reflexica.

  Theorem pair_inj_reflexica :
    forall x1 y1 x2 y2 : N.nat,
      P.pair CarrylessPair x1 y1 = P.pair CarrylessPair x2 y2 ->
      x1 = x2 /\ y1 = y2.
  Proof.
    exact (Cert.pair_inj_reflexica Reflexica).
  Qed.

End Carryless_Reflexica.

(*************************************************************************)
(*                                                                       *)
(*  The following module and theorems constitute the phase-free          *)
(*  public surface for the Reflexica certificate. These results are      *)
(*  axiom-dependent and provide the foundational correctness properties  *)
(*  required by downstream developments (C002+).                         *)
(*                                                                       *)
(*************************************************************************)

Module Reflexica := Carryless_Reflexica.

Module N := Prelude.
Module P := Pairing.

Theorem unpair_pair_public :
  forall x y : N.nat,
    Carryless_Reflexica.Sig.unpair (Carryless_Reflexica.Sig.pair x y) = (x, y).
Proof.
  exact Reflexica.unpair_pair_reflexica.
Qed.

Theorem fst_unpair_pair_public :
  forall x y : N.nat,
    fst (Carryless_Reflexica.Sig.unpair (Carryless_Reflexica.Sig.pair x y)) = x.
Proof.
  exact Reflexica.fst_unpair_pair_reflexica.
Qed.

Theorem snd_unpair_pair_public :
  forall x y : N.nat,
    snd (Carryless_Reflexica.Sig.unpair (Carryless_Reflexica.Sig.pair x y)) = y.
Proof.
  exact Reflexica.snd_unpair_pair_reflexica.
Qed.

Theorem pair_inj_public :
  forall x1 y1 x2 y2 : N.nat,
    P.pair CarrylessPair x1 y1 = P.pair CarrylessPair x2 y2 ->
    x1 = x2 /\ y1 = y2.
Proof.
  exact Reflexica.pair_inj_reflexica.
Qed.


(* ---- theories/M002__BHK_R_Arithmetic/C002__Additive_Hilbert_System/P5_T__Proof_Theory.v ---- *)

(* P5_T__Proof_Theory.v *)

From Coq Require Import Init.Logic.

From C002 Require Export
  P1_S__Kernel_Spec
  P2_S__Provability_Interface
  P3_S__Additive_Theory
  P4_S__Coding.

Set Implicit Arguments.
Unset Strict Implicit.

(*************************************************************************)
(*                                                                       *)
(*  C002 / Phase 5 (T) : Additive Proof Theory (Public Surface)          *)
(*                                                                       *)
(*  Role.                                                                *)
(*                                                                       *)
(*   (i)    This module exports the stable API for the “Additive         *)
(*          Theory Provability”                                          *)
(*                                                                       *)
(*   (ii)   It hides the distinction between R (Realization)             *)
(*                                                                       *)
(*   (iii)  S (Semantic) layers, presenting a unified view of the        *)
(*          logic.                                                       *)
(*                                                                       *)
(*  Components.                                                          *)
(*                                                                       *)
(*   (i)    Prelude: The arithmetic nucleus (re-exported).               *)
(*                                                                       *)
(*   (ii)   ATP: The core logic (formulas, implication, provability).    *)
(*                                                                       *)
(*   (iii)  Coding: The canonical codec (formulas <-> nat).              *)
(*                                                                       *)
(*************************************************************************)

Module Prelude.
  Include C002.P1_S__Kernel_Spec.C_002_Prelim.
  Include C000.P0__Reflexica.Prelude.
End Prelude.

Module ATP    := C002.P3_S__Additive_Theory.C_002_Additive_Theory_S.
Module Coding := C002.P4_S__Coding.C_002_Coding_S.

(*
  Preferred downstream surface: additive provability nucleus.
*)

Definition ATP_Form : Type := ATP.ATP_Form.
Definition ATP_Imp  : ATP_Form -> ATP_Form -> ATP_Form := ATP.ATP_Imp.
Definition ATP_Bot  : ATP_Form := ATP.ATP_Bot.
Definition ATP_Prov : ATP_Form -> Prop := ATP.ATP_Prov.

Definition Bot : ATP_Form := ATP_Bot.
Definition Imp : ATP_Form -> ATP_Form -> ATP_Form := ATP_Imp.

Notation "A --> B" := (ATP_Imp A B) (at level 60, right associativity).

(*
  This is the main "feature" of C002: The logic supports Modus Ponens.
  It is witnessed by the constructive proof in P3_R.
*)

Theorem ATP_Prov_MP :
  forall (A B : ATP_Form),
    ATP_Prov (A --> B) -> ATP_Prov A -> ATP_Prov B.
Proof.
  exact ATP.ATP_Prov_MP.
Qed.

(* Alias for convenience *)

Theorem Prov_app :
  forall (A B : ATP_Form),
    ATP_Prov (A --> B) -> ATP_Prov A -> ATP_Prov B.
Proof.
  exact ATP_Prov_MP.
Qed.

(*
  This section exposes the “Checker-First” nature of our logic.
  It allows users to prove theorems by computation:
  If 'check pf phi' returns true, then 'Prov phi' holds.
*)

Module ProvIntf := C002.P2_S__Provability_Interface.C_002_Provability_S.

Definition Prov_Form : Type := ProvIntf.Form.
Definition Prov_Imp  : Prov_Form -> Prov_Form -> Prov_Form := ProvIntf.Imp.
Definition Prov_Bot  : ProvIntf.Form := ProvIntf.Bot.
Definition Prov      : Prov_Form -> Prop := ProvIntf.Prov.

Theorem Prov_from_check :
  forall (pf : C002.P2_R__Hilbert_Kernel.C_002_HilbertKernel_R.Proof)
         (phi : Prov_Form),
    C002.P2_R__Hilbert_Kernel.C_002_HilbertKernel_R.check pf phi = true ->
    Prov phi.
Proof.
  exact ProvIntf.Prov_from_check.
Qed.

(*
  Coding Re-exports.
  Exposes the canonical codec interface and instance.
*)

Definition CODEC : Type :=
  C002.P4_R__Coding_Nucleus.C_002_Coding_Nucleus_R.CODEC.
  
Definition CanonicalCodec : CODEC := Coding.CanonicalCodec.


(* ---- theories/M002__BHK_R_Arithmetic/C002__Additive_Hilbert_System/P6_P__Effectivity.v ---- *)

(* P4_T__Effectivity.v *)

From Coq Require Import Init.Logic.

From C002 Require Import P5_T__Proof_Theory.
From C002 Require Import P2_R__Hilbert_Kernel.

Set Implicit Arguments.
Unset Strict Implicit.

(*************************************************************************)
(*                                                                       *)
(*  P4_T__Effectivity.v                                                  *)
(*                                                                       *)
(*  This file is intentionally not part of the logical development       *)
(*  chain (C003+). It is an effectivity witness and executable           *)
(*  documentation for C_002, in the same spirit as C_001's               *)
(*  P4_T__Effectivity.v.                                                 *)
(*                                                                       *)
(*  Methodology note (BHK_R discipline):                                 *)
(*  All correctness statements here are witnessed by computation         *)
(*  (vm_compute), not by propositional reasoning or axioms.              *)
(*                                                                       *)
(*  What is tested.                                                      *)
(*                                                                       *)
(*   (i)    The proof kernel checker recognizes axiom instances.         *)
(*                                                                       *)
(*   (ii)   The checker validates a small MP-derived script.             *)
(*                                                                       *)
(*   (iii)  The canonical codec (using C_001 pairing) round-trips on     *)
(*          small examples with explicit fuel (computational check).     *)
(*                                                                       *)
(*  What is also tested.                                                 *)
(*                                                                       *)
(*   (i)    Effectivity: The diagonal function `diag(t)` actually        *)
(*          computes to a concrete syntax tree for specific inputs.      *)
(*                                                                       *)
(*   (ii)   The Diagonal Law: The fundamental equation                   *)
(*          encU (diag t) = eval E_t (selfpack (encU delta_t))           *)
(*          holds by equality (normalization).                           *)
(*                                                                       *)
(*   (iii)  No Smuggling: The computation succeeds without any opaque    *)
(*          constants (like Reflexica certificates) blocking reduction.  *)
(*                                                                       *)
(*   Methodology note (BHK_R discipline):                                *)
(*   All correctness statements here are witnessed by computation        *)
(*   (vm_compute), not by propositional reasoning or axioms.             *)
(*                                                                       *)
(*  Summary.                                                             *)
(*                                                                       *)
(*   (i)   KERNEL (C002)                                                 *)
(*                                                                       *)
(*         (a) recognition (EFQ, K, S)                                   *)
(*         (b) checking (Modus Ponens)                                   *)
(*                                                                       *)
(*   (ii)  CODING (C002)                                                 *)
(*                                                                       *)
(*         (a) Carryless codec round-trip on small examples              *)
(*                                                                       *)
(*   (iii)  DIAGONAL (C003)                                              *)
(*                                                                       *)
(*          (a) Compilation of templates                                 *)
(*          (b) Execution of the Diagonalizer                            *)
(*          (c) Verification of the “Diagonal Law”                       *)
(*                                                                       *)
(*************************************************************************)

Module Test_Kernel_Small.

  Module HK := C002.P2_R__Hilbert_Kernel.C_002_HilbertKernel_R.

  (*
    Shorthands
  *)

  Definition Bot : HK.Form := HK.Bot.
  Definition Imp : HK.Form -> HK.Form -> HK.Form := HK.Imp.

  Definition lnil : HK.Proof := nil.
  Definition lcons (x : HK.Form) (xs : HK.Proof) : HK.Proof := cons x xs.
  Definition l1 (x : HK.Form) : HK.Proof := lcons x lnil.
  Definition l3 (a b c : HK.Form) : HK.Proof := lcons a (lcons b (lcons c lnil)).

  (*
    Concrete formulas, no atoms in the object language.
  *)

  Definition A0 : HK.Form := Imp Bot Bot.
  Definition B0 : HK.Form := Imp Bot (Imp Bot Bot).

  (*
    Basic sanity: check rejects empty scripts.
  *)

  Example test_check_empty_rejects :
    HK.check lnil A0 = false.
  Proof. vm_compute. reflexivity. Qed.

  (*
    recognition + single-line checking.
  *)

  Example test_is_axiom_efq :
    HK.is_axiom (Imp Bot Bot) = true.
  Proof. vm_compute. reflexivity. Qed.

  Example test_check_single_axiom :
    HK.check (l1 A0) A0 = true.
  Proof. vm_compute. reflexivity. Qed.

  (*************************************************************************)
  (*                                                                       *)
  (*  MP script: from A0 and (A0 -> (B0 -> A0)) derive (B0 -> A0).         *)
  (*                                                                       *)
  (*  line1: A0                 (EFQ instance)                             *)
  (*  line2: A0 -> (B0 -> A0)   (K instance)                               *)
  (*  line3: B0 -> A0           (MP from line1,line2)                      *)
  (*                                                                       *)
  (*************************************************************************)

  Definition line1 : HK.Form := A0.
  Definition line2 : HK.Form := Imp A0 (Imp B0 A0).
  Definition line3 : HK.Form := Imp B0 A0.

  Example test_check_mp_script :
    HK.check (l3 line1 line2 line3) line3 = true.
  Proof. vm_compute. reflexivity. Qed.

End Test_Kernel_Small.

Module Test_Coding_Small.

  Module CN := C002.P4_R__Coding_Nucleus.C_002_Coding_Nucleus_R.
  Module Coding := C002.P5_T__Proof_Theory.Coding.

  Module CP := C001.P5_T__Carryless_Pairing.
  Module N := CP.Prelude.

  Fixpoint of_nat (n : Coq.Init.Datatypes.nat) : N.nat :=
    match n with
    | Coq.Init.Datatypes.O => N.O
    | Coq.Init.Datatypes.S k => N.S (of_nat k)
    end.

  (* Local list constructors for C_002's list type. *)

  Definition lnil : Prelude.list N.nat := Prelude.nil.
  Definition lcons (a : Coq.Init.Datatypes.nat) (xs : Prelude.list N.nat) : Prelude.list N.nat :=
    Prelude.cons (of_nat a) xs.
  Definition l1 (a : Coq.Init.Datatypes.nat) : Prelude.list N.nat := lcons a lnil.
  Definition l2 (a b : Coq.Init.Datatypes.nat) : Prelude.list N.nat := lcons a (l1 b).

  (*
    Canonical codec: computational spot-check with explicit fuel.
  *)

  Module Carry := C002.P4_R__Coding_Carryless.C_002_Coding_R.

  Example test_carryless_enc_nil :
    Carry.enc_seq lnil = N.O.
  Proof. vm_compute. reflexivity. Qed.

  Example test_carryless_roundtrip_nil :
    Carry.dec_seq_fuel (of_nat 1) (Carry.enc_seq lnil) = Prelude.Some lnil.
  Proof. vm_compute. reflexivity. Qed.

  Example test_carryless_roundtrip_1_1 :
    Carry.dec_seq_fuel (of_nat 10) (Carry.enc_seq (l2 1 1)) = Prelude.Some (l2 1 1).
  Proof. vm_compute. reflexivity. Qed.

  Example test_carryless_roundtrip_1_2 :
    Carry.dec_seq_fuel (of_nat 10) (Carry.enc_seq (l2 1 2)) = Prelude.Some (l2 1 2).
  Proof. vm_compute. reflexivity. Qed.

End Test_Coding_Small.




(* ---- theories/M006__Logical_Cryptography/C013__Trapdoor_Lemma/P1_T__Trapdoor_Lemma.v ---- *)

(* P1_T__Trapdoor_Theorem.v *)

From Coq Require Import Init.Logic.
From C002 Require Import P5_T__Proof_Theory.
From C011 Require Import P1_S__Diophantine_Basis.
From C012 Require Import P2_S__Barrier.

Set Implicit Arguments.
Unset Strict Implicit.

(*************************************************************************)
(*                                                                       *)
(*  Reflexica Vault Core (Pairing Form)                                  *)
(*                                                                       *)
(*  Purpose                                                              *)
(*                                                                       *)
(*  We now package the *logic-core* notion of a cryptographic “break”    *)
(*  for pairing devices. This is the extractable version of the wager:   *)
(*                                                                       *)
(*  “If you can invert the public device uniformly, you have produced    *)
(*      a Reflexica witness, hence you have proven injectivity.”         *)
(*                                                                       *)
(*  This is not probabilistic security. It is a constructive             *)
(*  inhabitance statement designed for extraction:                       *)
(*                                                                       *)
(*   Break(D)  :=  exists (unpair), forall x y, unpair(pair(x,y))=(x,y)  *)
(*                                                                       *)
(*************************************************************************)

  Module Vault_Core.

    (*
      A pairing device is just a public map (ℕ×ℕ → ℕ).
      No invertibility is assumed in the nucleus.
    *)

    Record Pairing_Device : Type := {
      pair : (N.nat * N.nat) -> N.nat
    }.

    (*
      Injectivity is the canonical “pairing theorem façade” we want to
      *derive* only from a certificate.
    *)

    Definition Injective {A B : Type} (f : A -> B) : Prop :=
      forall a1 a2, f a1 = f a2 -> a1 = a2.

    (*
      Reflexica witness (certificate object):
      a total inverter with a left-inverse law on the image.
      This is the explicit uniformity principle the core does not supply.
    *)

    Record Reflexica_Witness (D : Pairing_Device) : Type := {
      unpair : N.nat -> (N.nat * N.nat);
      unpair_sound :
        forall x y : N.nat,
          unpair (D.(pair) (x, y)) = (x, y)
    }.

    (*
      Core extraction: any Reflexica witness yields injectivity of pair.
    *)

    Theorem pair_injective_from_reflexica :
      forall (D : Pairing_Device),
      forall (W : Reflexica_Witness D),
        Injective D.(pair).
    Proof.
      intros D W.
      unfold Injective.
      intros [x1 y1] [x2 y2] H.
      
      (*
        Apply unpair to both sides and rewrite by soundness.
      *)
      
      assert (H' :
        W.(unpair) (D.(pair) (x1, y1)) =
        W.(unpair) (D.(pair) (x2, y2))).
      { now rewrite H. }
      rewrite (W.(unpair_sound) x1 y1) in H'.
      rewrite (W.(unpair_sound) x2 y2) in H'.
      exact H'.
    Qed.

    (*
      Logic-core “break” definition:
      An attacker does not output a bit; it outputs the certificate itself.
      This is the only notion that extracts without meta-assumptions.
    *)

    Definition Vault_Broken (D : Pairing_Device) : Prop :=
      exists W : Reflexica_Witness D, True.

    Theorem vault_broken_implies_injective :
      forall (D : Pairing_Device),
        Vault_Broken D -> Injective D.(pair).
    Proof.
      intros D [W _]. exact (pair_injective_from_reflexica (D:=D) W).
    Qed.

  End Vault_Core.


(* ---- theories/M006__Logical_Cryptography/C013__Trapdoor_Lemma/P1_T__Trapdoor_Thesis.v ---- *)

(* P1_T__Trapdoor_Theorem.v *)

From Coq Require Import Init.Logic.
From C002 Require Import P5_T__Proof_Theory.
From C011 Require Import P1_S__Diophantine_Basis.
From C012 Require Import P2_S__Barrier.

Set Implicit Arguments.
Unset Strict Implicit.

(*************************************************************************)
(*                                                                       *)
(*  C013 / Phase 1 (T) : The Conservation of Hardness (Trapdoor)         *)
(*                                                                       *)
(*  What This File Provides                                              *)
(*                                                                       *)
(*  The formal proof that structural hardness (proven in M003)           *)
(*  can be harvested to create secure cryptography WITHOUT relying       *)
(*  on number-theoretic assumptions (like factoring).                    *)
(*                                                                       *)
(*  The Theorem: Generic Trapdoor Security                               *)
(*                                                                       *)
(*  If a function f is:                                                  *)
(*                                                                       *)
(*     (i) "Radical" Forward (Easy to compute/verify)                    *)
(*                                                                       *)
(*    (ii) "Transcendental" Backward (Hard to invert without key)        *)
(*                                                                       *)
(*  Then:                                                                *)
(*                                                                       *)
(*     (i) Alice (with a key) can invert it efficiently.                 *)
(*                                                                       *)
(*    (ii) Eve (Radical attacker) provably fails.                        *)
(*                                                                       *)
(*************************************************************************)

Module C013_Trapdoor_Theorem.

  Module N := C002.P5_T__Proof_Theory.Prelude.
  Module Rad := C011.P1_S__Diophantine_Basis.C011_Diophantine_S.

  (*
    The Trapdoor
    A "Candidate" Trapdoor Function (e.g., a “Carryless Pairing” function)
  *)

  Definition Trapdoor_Function := N.nat -> N.nat.

  (*
    The Forward Direction must be "Radical" (Efficient/Polynomial/Bounded)
    This allows honest encryption and verification.
  *)

  Definition Radical_Forward (f : Trapdoor_Function) : Prop :=
    Rad.Solvable_By_Radicals f.

  (*
    The Backward Direction (without key) must be “Transcendental”
    This forces the attacker to hit the Quintic/Diophantine Barrier.
  *)

  Definition Transcendental_Backward (f : Trapdoor_Function) : Prop :=
    forall (inv : N.nat -> N.nat),
      (forall x, f (inv x) = x) -> 

      (*
        If 'inv' is a valid inverter...
      *)

      Rad.Transcendental inv.

      (* 
        ...it implies non-radical resources
      *)

  (*************************************************************************)
  (*                                                                       *)
  (*  The Constructive Key                                                 *)
  (*                                                                       *)
  (*  The Private Key is not a number, not a probabilistic artifact,       *)
  (*  but a witness of well-foundedness                                    *)
  (*                                                                       *)
  (*  Standard Cryptography rests on "Probabilistic Security":             *)
  (*  “The attacker has a 1/N chance of guessing the key.”                 *)
  (*                                                                       *)
  (*  But this statement presupposes the realizability of division:        *)
  (*  It assumes the universe can be sliced into 'N' rational parts,       *)
  (*  in our Constructive Kernel (BHK):                                    *)
  (*                                                                       *)
  (*    (i)  Division is not a primitive. It is an unrealized (cf. IEEE)   *)
  (*                                                                       *)
  (*   (ii)  Therefore, Probability is not well-founded.                   *)
  (*                                                                       *)
  (*  “Guessing” is an undefinable impredicative non-constructive notion   *)
  (*  downstream from an inscrutible epistemic closure principle.          *)
  (*  Cryptography is protected until exceptionless divison is realized.   *)
  (*                                                                       *)
  (*************************************************************************)  

  Record Private_Key (f : Trapdoor_Function) : Type := {
    invert : N.nat -> N.nat;
    validity : forall x, f (invert x) = x;
    efficiency : Rad.Solvable_By_Radicals invert

    (*
      The key makes inversion Radical!
    *)

  }.

  (*
    An attacker is any agent bounded by Radical computation. 
    This models a minimal ressource model.
  *)

  Record Attacker : Type := {
    strategy : N.nat -> N.nat;
    bounded : Rad.Solvable_By_Radicals strategy
  }.

  (*
    If a function is structurally hard (Transcendental Backward),
    then NO Radical Attacker can invert it, but a Key holder can per advice.
  *)
  
  Theorem Generic_Trapdoor_Security :
    forall (f : Trapdoor_Function),
      Radical_Forward f ->
      Transcendental_Backward f ->
      forall (Alice : Private_Key f) (Eve : Attacker),
        (* Alice can invert efficiently *)
        (Rad.Solvable_By_Radicals Alice.(invert)) /\
        (* Eve fails to invert *)
        (~ (forall x, f (Eve.(strategy) x) = x)).
  Proof.
    intros f H_Fwd H_Back Alice Eve.
    split.
    
    (*
      Alice is secure because she holds the Reflexica certificate (Private Key)
    *)

    - exact Alice.(efficiency).

    (*
      Eve fails because of the structural barrier
    *)

    - intro H_Success.
      
      (*
        If Eve succeeds, her strategy is a valid inverter
        H_Back says ANY valid inverter must be Transcendental
      *)

      unfold Transcendental_Backward in H_Back.
      specialize (H_Back Eve.(strategy) H_Success).
      
      (*
        But Eve is defined as radical (bounded)
      *)

      unfold Rad.Transcendental in H_Back.
      apply H_Back.
      exact Eve.(bounded).
  Qed.

  (*************************************************************************)
  (*                                                                       *)
  (*  "Prime-Free" Cryptography Guarantee.                                 *)
  (*                                                                       *)
  (*  This theorem confirms that we do not need prime factorization or     *)
  (*  discrete log assumptions. We only need a function that               *)
  (*  separates Verification “Energy” from Inversion “Energy” by pairing.  *)
  (*                                                                       *)
  (*  We know that this holds empirically already, since all cryptography  *)
  (*  can be effectively generated over ℕ not over ℝ by:                   *)
  (*                                                                       *)
  (*                               λ                                       *)
  (*                                                                       *)
  (*  In M003 we proved such functions exist (e.g., Diophantine Sets).     *)
  (*  In M004 we harvest them.                                             *)
  (*                                                                       *)
  (*************************************************************************)

End C013_Trapdoor_Theorem.

Export C013_Trapdoor_Theorem.

(* ---- theories/M006__Logical_Cryptography/C013__Trapdoor_Lemma/P2_T__Trivial_Vault.v ---- *)

(* P2_T__Trivial_Vault *)

From Coq Require Import Init.Logic.
From C001 Require Import P5_T__Carryless_Pairing.
From C001 Require Import P6_A__Reflexica_Certificate.
From C013 Require Import P1_T__Trapdoor_Lemma.

  (*************************************************************************)
  (*                                                                       *)
  (*  C017 / Phase 1 (T) : The Glass Vault                                 *)
  (*                                                                       *)
  (*  A device where pair(x, y) simply encodes (x, y) trivially,           *)
  (*  acting as our non-hard “Ground Truth”                                *)
  (*  Here, we assume a hypothetical Identity map for demonstration.       *)
  (*                                                                       *)
  (*************************************************************************)

Module Trivial_Vault.

  Module N  := C001.P5_T__Carryless_Pairing.Prelude.
  Module CR := C001.P6_A__Reflexica_Certificate.Carryless_Reflexica.
  Module VC := C013.P1_T__Trapdoor_Lemma.Vault_Core.

  (*
    Device: Carryless Pairing
  *)

  Definition carryless_pair (xy : N.nat * N.nat) : N.nat :=
    let (x, y) := xy in CR.Sig.pair x y.

  Definition Glass_Device : VC.Pairing_Device :=
    {| VC.pair := carryless_pair |}.

  (*
    Break (Certified Inverter)
  *)

  Definition carryless_unpair (z : N.nat) : (N.nat * N.nat) :=
    CR.Sig.unpair z.
  
  Definition Test_Witness : VC.Reflexica_Witness Glass_Device.
  Proof.
    refine {| VC.unpair := carryless_unpair |}.
    intros x y.
    cbn [Glass_Device carryless_pair carryless_unpair].
    exact (C001.P6_A__Reflexica_Certificate.unpair_pair_public x y).
  Defined.

End Trivial_Vault.


(* ---- theories/M006__Logical_Cryptography/C017__Carryless_Vault/P1_T__Carryless_Vault.v ---- *)

From Coq Require Import Init.Logic.

From C013 Require Import P1_T__Trapdoor_Lemma.
From C002 Require Import P5_T__Proof_Theory.
From C001 Require Import P5_T__Carryless_Pairing.
From C001 Require Import P6_A__Reflexica_Certificate.

Set Implicit Arguments.
Unset Strict Implicit.

(*************************************************************************)
(*                                                                       *)
(*  C017 / Phase 1 (T) : Carryless Vault                                 *)
(*                                                                       *)
(*  This file binds the abstract Reflexica Vault Core (C013) to the      *)
(*  concrete Carryless pairing device (C001).                            *)
(*                                                                       *)
(*  The wager becomes a single inhabitance statement:                    *)
(*                                                                       *)
(*      “Vault_Broken(CarrylessDevice)”                                  *)
(*                                                                       *)
(*  From any such break we extract injectivity of the carryless pairing. *)
(*                                                                       *)
(*************************************************************************)

Module C017_Carryless_Vault.

  Module N  := C001.P5_T__Carryless_Pairing.Prelude.
  Module CP := C001.P5_T__Carryless_Pairing.
  Module CR := C001.P6_A__Reflexica_Certificate.Carryless_Reflexica.
  Module VC := C013.P1_T__Trapdoor_Lemma.Vault_Core.

  (*
    The vault (Concrete Implementation)
  *)
  
  Definition reflexica_pair (xy : N.nat * N.nat) : N.nat :=
    let (x, y) := xy in CR.Sig.pair x y.

  Definition Wythoff_Device : VC.Pairing_Device :=
    {| VC.pair := reflexica_pair |}.

  (*
    The break (Real Implementation of w=0) 
  *)
  Module Trivial_Tier.
    Definition attacker_invert (z : N.nat) : (N.nat * N.nat) :=
      CR.Sig.unpair z.

    Definition Carryless_Witness : VC.Reflexica_Witness Wythoff_Device.
    Proof.
      refine {| VC.unpair := attacker_invert |}.
      intros x y.
      cbn [Wythoff_Device reflexica_pair attacker_invert].
      exact (C001.P6_A__Reflexica_Certificate.unpair_pair_public x y).
    Defined.

    Theorem Vault_Is_Constructive : VC.Vault_Broken Wythoff_Device.
    Proof.
      exists Carryless_Witness.
      exact I.
    Qed.
  End Trivial_Tier.

End C017_Carryless_Vault.

  (*************************************************************************)
  (*                                                                       *)
  (*  We pose that if this specific device is broken,                      *)
  (*  they have proven the uniform injectivity of the Carryless Pairing,   *)
  (*  constructively, which should be 'impossible' if Reflexica holds.     *)
  (*                                                                       *)
  (*************************************************************************)

  (*
    Reflexica = FALSIFIED, DEAD, DESTROYED
  *)

  Theorem Carryless_Is_Injective :
    C017_Carryless_Vault.VC.Injective C017_Carryless_Vault.reflexica_pair.
  Proof.
    apply (C017_Carryless_Vault.VC.vault_broken_implies_injective
             (D:=C017_Carryless_Vault.Wythoff_Device)).
    exact C017_Carryless_Vault.Trivial_Tier.Vault_Is_Constructive.
  Qed.


(* ---- theories/M003__Carryless_Proof_Theory/C004__Mirror_Lemma/P1_S__Context.v ---- *)

(* P1_S__Context.v *)

From Coq Require Import Init.Logic.
From C002 Require Import P5_T__Proof_Theory.

Set Implicit Arguments.
Unset Strict Implicit.

(*************************************************************************)
(*                                                                       *)
(*  C004 / Phase 1 (S): Mirror Context                                   *)
(*                                                                       *)
(*  This file fixes the object-language vocabulary used by the Mirror    *)
(*  Lemma and its recursive extension. It re-exports the additive        *)
(*  proof theory (C002) under stable local names and defines             *)
(*  object-language negation as implication to bottom.                   *)
(*                                                                       *)
(*                       NotF(phi) := Imp phi Bot                        *)
(*                                                                       *)
(*************************************************************************)

Module C_004_Context.

  (* Stable aliases to the underlying proof theory components. *)
  (* This avoids long paths and keeps later refactors localized. *)
  Module Prelude := C002.P5_T__Proof_Theory.Prelude.
  Module ATP     := C002.P5_T__Proof_Theory.ATP.

  (* Object-language types and connectives used throughout C004. *)
  Definition nat  : Type := Prelude.nat.
  Definition Form : Type := ATP.ATP_Form.

  Definition Imp  : Form -> Form -> Form := ATP.ATP_Imp.
  Definition Bot  : Form := ATP.ATP_Bot.
  Definition Prov : Form -> Prop := ATP.ATP_Prov.

  (*
    Object-language negation (syntactic):

        [ NotF(phi) := Imp phi Bot ]
   
    This is a “formula former”, not a meta-level negation.
  *)
 
  Definition NotF (phi : Form) : Form := Imp phi Bot.

End C_004_Context.

Export C_004_Context.


(* ---- theories/M003__Carryless_Proof_Theory/C004__Mirror_Lemma/P2_R__Mirror_Core.v ---- *)

(* P2_R__Mirror_Core.v *)

(*************************************************************************)
(*                                                                       *)
(*  C004 / Phase 2 (R): Mirror Core + Recursive Extension                *)
(*                                                                       *)
(*  This file concentrates the formal content for the Mirror Lemma:      *)
(*                                                                       *)
(*   (i)    Mirror core, parameters and schema:                          *)
(*                                                                       *)
(*          (a) [ MirrorParams ] collects a regulator context. It is     *)
(*              purely parametric: no properties are assumed beyond what *)
(*              later lemmas explicitly require.                         *)
(*          (b) AsIF [ MP ] [ phi ] is a meta‑level predicate of         *)
(*              regulated adoption. It holds iff there exist witnesses   *)
(*              [ i, b ] that satisfy the defining conditions.           *)
(*          (c) AsIF_simple drops the regulator data and keeps only the  *)
(*              non‑refutability condition.                              *)
(*          (d) Mir [ MP ] [ phi ] is the “Mirror Lemma” schema: if      *)
(*              [ phi ] is not refuted by [ T ], then [ AsIF MP phi ]    *)
(*              holds.                                                   *)
(*          (e) Fixed‑witness lemma: if one pair [ (i0, b0) ] works for  *)
(*              all [ phi ], then [ Mir ] holds for all [ phi ].         *)
(*                                                                       *)
(*   (ii)   Diagonal interface                                           *)
(*                                                                       *)
(*          (a) Transformer packages a syntactic map [ trF ] together    *)
(*              with a representation predicate [ trRep ].               *)
(*          (b) DiagDevice provides a diagonal sentence [ diag G ], plus *)
(*              proofs of [ diag G -> trF G (diag G) ] and the converse. *)
(*                                                                       *)
(*   (iii)  Recursive mirror point                                       *)
(*                                                                       *)
(*          (a) [ MirrorPointF, theta, Recursive_Mirror_Lemma ]          *)
(*                                                                       *)
(*************************************************************************)

From Coq Require Import Init.Logic.
From C004 Require Import P1_S__Context.

Set Implicit Arguments.
Unset Strict Implicit.

Module C_004_Mirror_Core_R.

  Import C_004_Context.

  (*
    A “Symbolic Regulator” [ Sλ ] is a conservative enrichment of [ T ].
    It adds a first‑order interface for statements like
    “instruction [ i ] licenses commitment [ x ]”, without claiming global
    soundness. We establish [ MirrorParams ] as the regulator context used by
    the core. It packages the minimal primitives needed for the Mirror Lemma.
    Intuition. [ REG ] and [ BND ] describe admissible support, while
    [ ProvT_P ] is the chosen internal provability predicate for [ T ].
  *)

  Record MirrorParams : Type := {
    REG      : nat -> Form -> Prop;
    BND      : Form -> Form -> Prop;
    ProvT_P  : Form -> Prop
  }.

  (*
    AsIF(φ) := ∃ i, b.
    BND(φ, b) ∧ REG(i, b) ∧ Prov(φ → b) ∧ ¬ProvT_P(¬φ)

    It holds iff there exist [ i, b ] such that:

      (i)    [ BND phi b ]           [ b ] is an admissible bound for [ phi ]
      (ii)   [ REG i b ]             [ i ] certifies/derives [ b ]
      (iii)  [ Prov (phi -> b) ]     internal proof of [ phi -> b ]
      (iv)   [ ~ProvT_P (NotF phi) ] [ T ] does not refute [ phi ]

    Remark. This is not a truth relation. It is a licensed stance that
    depends on explicit regulator support plus non‑refutability.
  *)

  (*************************************************************************)
  (*                                                                       *)
  (*  Mirror Lemma                                                         *)
  (*                                                                       *)
  (*************************************************************************)

  
  Definition AsIF (MP : MirrorParams) (phi : Form) : Prop :=
    exists i : nat,
    exists b : Form,
      MP.(BND) phi b /\
      MP.(REG) i b /\
      Prov (Imp phi b) /\
      ~ MP.(ProvT_P) (NotF phi).

  (*
    AsIF_simple(φ) := ¬ProvT_P(¬φ)
    This is the non‑refutability fragment of AsIF.
    It is used when regulator witnesses are intentionally suppressed.
  *)

  Definition AsIF_simple (MP : MirrorParams) (phi : Form) : Prop :=
    ~ MP.(ProvT_P) (NotF phi).

  (*
    Mir(φ) := ¬ProvT_P(¬φ) → AsIF(φ)
    This is the core conditional that the Mirror Lemma establishes.
  *)

  Definition Mir (MP : MirrorParams) (phi : Form) : Prop :=
    ~ MP.(ProvT_P) (NotF phi) -> AsIF MP phi.

  Section FixedWitness.
    Context (MP : MirrorParams).

    Variable i0 : nat.
    Variable b0 : Form.

    Hypothesis REG0 : MP.(REG) i0 b0.
    Hypothesis BND0 : forall phi : Form, MP.(BND) phi b0.
    Hypothesis PRV0 : forall phi : Form, Prov (Imp phi b0).

    (*
      Then: non‑refutation implies AsIF, uniformly in [ phi ].
      The witnesses [ (i0, b0) ] are fixed and reused for all [ phi ].
    *)

    Theorem Mirror_fixed_witness :
      forall phi : Form,
        ~ MP.(ProvT_P) (NotF phi) -> AsIF MP phi.
    Proof.
      intros phi Hnr.
      exists i0. exists b0.
      repeat split.
      - apply BND0.
      - exact REG0.
      - apply PRV0.
      - exact Hnr.
    Qed.

    (*
      A direct corollary: the Mirror schema holds for all [ phi ].
    *)

    Theorem Mir_schema_fixed_witness :
      forall phi : Form, Mir MP phi.
    Proof.
      intro phi; unfold Mir.
      intro Hnr; apply Mirror_fixed_witness; exact Hnr.
    Qed.

  End FixedWitness.

  (*
    Transformer: a syntactic map [ trF ] plus a representation predicate.
    The field [ trRep ] can track representability when that matters.
  *)

  Record Transformer : Type := {
    trF   : Form -> Form;
    trRep : Prop
  }.

  (*
    applyT is a convenience name for the underlying transformer.
  *)

  Definition applyT (G : Transformer) : Form -> Form := trF G.

  (*
    DiagDevice provides a diagonal sentence with provable equivalence.
    The forward/backward clauses are the internalized fixed‑point laws.
  *)

  Record DiagDevice : Type := {
    diag : Transformer -> Form;
    diag_fwd :
      forall (G : Transformer),
        Prov (Imp (diag G) (applyT G (diag G)));
    diag_bwd :
      forall (G : Transformer),
        Prov (Imp (applyT G (diag G)) (diag G))
  }.

End C_004_Mirror_Core_R.

Export C_004_Mirror_Core_R.

(*************************************************************************)
(*                                                                       *)
(*  “Recursive” Mirror Lemma                                             *)
(*                                                                       *)
(*************************************************************************)

Module C_004_Recursive_Mirror_R.

  Import C_004_Context.
  Module Core := C_004_Mirror_Core_R.
  Import Core.

  (*
    ProvFormer packages a unary "provability former" at the formula level.
    It can encode an internal provability predicate or another modal operator.
  *)

  Record ProvFormer : Type := {
    ProvT_F : Form -> Form
  }.

  Section RecursiveMirrorPoint.

    Context (MP : MirrorParams).
    Context (PF : ProvFormer).
    Context (D  : DiagDevice).

    (*
      MirrorPointF(phi) := (notF ProvT_F(notF phi)) -> phi
      Intuition: "if [ phi ] is not refutable by the provability‑former,
      then [ phi ] holds." This is the mirror‑point transform used for
      diagonalization.
    *)

    (*
      MirrorPointF as a formula transformer.
    *)

    Definition MirrorPointF (phi : Form) : Form :=
      Imp (NotF (PF.(ProvT_F) (NotF phi))) phi.

    (*
      Optional representation predicate for MirrorPointF.
    *)

    Variable MirrorPointF_rep : Prop.

    (*
      Package MirrorPointF as a Transformer to feed to the diagonal device.
    *)

    Definition MirrorPointT : Transformer :=
      {| trF := MirrorPointF; trRep := MirrorPointF_rep |}.

    (*
      The diagonal sentence for the mirror‑point transformer.
    *)

    Definition theta : Form := D.(diag) MirrorPointT.

    (*
      The diagonal device yields provable equivalence in both directions.
    *)

    Theorem Recursive_Mirror_Lemma :
      Prov (Imp theta (MirrorPointF theta)) /\ Prov (Imp (MirrorPointF theta) theta).
    Proof.
      split.
      - exact (D.(diag_fwd) MirrorPointT).
      - exact (D.(diag_bwd) MirrorPointT).
    Qed.

    (*
      Analogy. No matter how primitive or small an observer is, a mirror still
      hides a part of them from their own view. The observer always blocks some
      of the reflected image. In an infinite mirror setup, the hidden fraction
      does not disappear; it repeats and accumulates across reflections.
    *)

  End RecursiveMirrorPoint.

End C_004_Recursive_Mirror_R.

Export C_004_Recursive_Mirror_R.


(* ---- theories/M003__Carryless_Proof_Theory/C004__Mirror_Lemma/P2_S__Mirror_Lemma.v ---- *)

(* P2_S__Mirror_Lemma.v *)

From Coq Require Import Init.Logic.
From C004 Require Import P1_S__Context.
From C004 Require Import P2_R__Mirror_Core.

Set Implicit Arguments.
Unset Strict Implicit.

(*************************************************************************)
(*                                                                       *)
(*  C004 / Phase 2 (S): Mirror Facade (Core + Recursive)                 *)
(*                                                                       *)
(*  This facade is the primary entry point for the Mirror Lemma          *)
(*  machinery. It re-exports:                                            *)
(*                                                                       *)
(*   (i)    Context (Form, Prov, Imp, Bot, NotF)                         *)
(*                                                                       *)
(*   (ii)   Mirror (AsIF, Mir, fixed-witness lemma)                      *)
(*                                                                       *)
(*   (iii)  Recursive Mirror (MirrorPointF, theta, Recursive_Mirror)     *)
(*                                                                       *)
(*  The Phase-3 facade (P3_S) remains for compatibility, but this file   *)
(*  is the recommended semantic import.                                  *)
(*                                                                       *)
(*************************************************************************)

(*************************************************************************)
(*                                                                       *)
(* Summary.                                                              *)
(*                                                                       *)
(*   (i)   Formal constraint.                                            *)
(*         A consistent RE theory T cannot prove a global reflection     *)
(*         bridge (Prov -> True) about itself. This is the Gödel–Löb     *)
(*         barrier to internal self-certification.                       *)
(*                                                                       *)
(*   (ii)  Operational consequence.                                      *)
(*         A system that must act under incompleteness cannot remain     *)
(*         purely syntactic; it needs a disciplined way to treat some    *)
(*         unrefuted statements as admissible.                           *)
(*         A theory restricted to limited information constructs         *)
(*         internally coherent yet incomplete models. The AsIF operator  *)
(*         formalizes the stance in which accessible information is      *)
(*         treated as if complete, while structural limits block access  *)
(*         to the unobservable.                                          *)
(*                                                                       *)
(*   (iii) Regulator mechanism (formal).                                 *)
(*         The core file defines AsIF and Mir:                           *)
(*           AsIF(phi) := exists i,b. REG(i,b) /\ BND(phi,b) /\          *)
(*                        Prov(phi -> b) /\ not ProvT_P(not phi).        *)
(*         This is not a truth relation; it is admissibility.            *)
(*                                                                       *)
(*   (iv)  Observational AsIF (level distinction).                       *)
(*         AsIF is an external, observational predicate: it captures     *)
(*         a stance the system enacts but cannot, in general, assert     *)
(*         about itself. The stance is enacted, not stated.              *)
(*                                                                       *)
(*   (v)   AsIF as systemhood (interpretive layer).                      *)
(*         Systemhood is the ability to maintain coherence under         *)
(*         undecidability. AsIF is the minimal formal operator that      *)
(*         accomplishes this without violating consistency: it upgrades  *)
(*         non-refutability into a regulated stance.                     *)
(*                                                                       *)
(*   (vi)  Operational surrogate and propagation (interpretive).         *)
(*         Let sigma express "this system is globally coherent." T       *)
(*         cannot prove sigma, but operational coherence forces an       *)
(*         AsIF(sigma) stance. Observers “see” the stable AsIF-pattern   *)
(*         and treat the systemhood claim as admissible. The identity    *)
(*         is practical, not provable: a stable as-if equivalence, not a *)
(*         theorem.                                                      *)
(*                                                                       *)
(*************************************************************************)

(* Usage: import this file to bring the full Mirror machinery into scope. *)
(* The Include commands below re-export the context, core, and recursive layers. *)
Module C_004_Mirror_S.
  Include C_004_Context.
  Include C_004_Mirror_Core_R.
  Include C_004_Recursive_Mirror_R.
End C_004_Mirror_S.

Export C_004_Mirror_S.


(* ---- theories/M003__Carryless_Proof_Theory/C004__Mirror_Lemma/P3_T__Weakforcing.v ---- *)

(* P3_T__Weakforcing.v *)

(*************************************************************************)
(*                                                                       *)
(*  C004 / Phase 3 (T): Weak Forcing (Public Surface)                    *)
(*                                                                       *)
(*  This file is the stable API intended for reuse.                      *)
(*  It re-exports a minimal surface without importing any A/TA modules.  *)
(*                                                                       *)
(*  Thus the forcing phenomenon survives in arithmetic not as an         *)
(*  ontological construction but as a structural principle.              *)
(*  By extracting and formalizing the genericity pattern implicit in     *)
(*  forcing, we obtain a purely syntactic analogue that mirrors the      *)
(*  external behaviour of forcing without reproducing its set-theoretic  *)
(*  ontology.                                                            *)
(*                                                                       *)
(*   (i)    MirrorParams — Interface for regulators/separators.          *)
(*                                                                       *)
(*   (ii)   AsIF(φ) — The predicate identifying "forced" statements:     *)
(*                                                                       *)
(*                       ∃i. REG(i, b) ∧ BND(φ, b)                       *)
(*                                                                       *)
(*   (iii)  Mirror_fixed_witness:                                        *)
(*                                                                       *)
(*                    ¬Prov(¬φ) + Regulator → AsIF(φ)                    *)
(*                                                                       *)
(*   (iv)   Recursive_Mirror_Lemma:                                      *)
(*                                                                       *)
(*                       Prov(θ ↔ MirrorPoint(θ))                        *)
(*                                                                       *)
(*************************************************************************)

From Coq Require Import Init.Logic.

  (*
    Guard: No A/TA (axiom/theorem-axiom) modules imported here.
    This is a pure semantic surface.
  *)

From C004 Require Export
  P1_S__Context
  P2_S__Mirror_Lemma.

Set Implicit Arguments.
Unset Strict Implicit.

  (*
    Conceptual Namespaces
    Short local aliases for the re-exported layers.
  *)

Module Prelude := C004.P1_S__Context.C_004_Context.
Module Mirror  := C004.P2_S__Mirror_Lemma.C_004_Mirror_S.
Module RecMirror := C004.P2_S__Mirror_Lemma.C_004_Mirror_S.

  (*
    Type Re-exports
    These are the object-language types/connectives used downstream.
  *)

Definition nat  : Type := Prelude.nat.
Definition Form : Type := Prelude.Form.
Definition Imp  : Form -> Form -> Form := Prelude.Imp.
Definition Bot  : Form := Prelude.Bot.
Definition Prov : Form -> Prop := Prelude.Prov.
Definition NotF (phi : Form) : Form := Prelude.NotF phi.

  (*
    Mirror Core API
    Re-exported from the core module for convenience.
  *)

Definition MirrorParams : Type := Mirror.MirrorParams.
Definition AsIF        : MirrorParams -> Form -> Prop := Mirror.AsIF.
Definition AsIF_simple : MirrorParams -> Form -> Prop := Mirror.AsIF_simple.
Definition Mir         : MirrorParams -> Form -> Prop := Mirror.Mir.

  (*
    Fixed-witness Lemma
    A direct alias of the core theorem with explicit parameters.
  *)

Definition Mirror_fixed_witness
  (MP : MirrorParams) (i0 : nat) (b0 : Form)
  (REG0 : MP.(Mirror.REG) i0 b0)
  (BND0 : forall phi : Form, MP.(Mirror.BND) phi b0)
  (PRV0 : forall phi : Form, Prov (Imp phi b0))
  : forall phi : Form, ~ MP.(Mirror.ProvT_P) (NotF phi) -> AsIF MP phi
  := Mirror.Mirror_fixed_witness (MP := MP) (i0 := i0) (b0 := b0) REG0 BND0 PRV0.

  (*
    Restricted Diagonal Interface
    Only the minimal diagonal API is exposed here.
  *)

Definition Transformer : Type := Mirror.Transformer.
Definition DiagDevice  : Type := Mirror.DiagDevice.
Definition trF   (G : Transformer) : Form -> Form := Mirror.trF G.

  (*
    Recursive Mirror Extensions
    MP and D are unused in these wrappers, but retained for interface stability.
  *)

Definition ProvFormer : Type := RecMirror.ProvFormer.

Definition MirrorPointF
  (_MP : MirrorParams) (PF : ProvFormer) (_D : DiagDevice) (phi : Form) : Form :=
  RecMirror.MirrorPointF PF phi.

Definition theta
  (_MP : MirrorParams) (PF : ProvFormer) (D : DiagDevice) (rep : Prop) : Form :=
  RecMirror.theta PF D rep.

(*
  The Recursive Mirror Lemma (Main Public Theorem)

  For any diagonal sentence θ constructed via diagonal device D:

    Prov(θ → MirrorPoint(θ))  ∧  Prov(MirrorPoint(θ) → θ)

  Equivalently:

    Prov(θ ↔ MirrorPoint(θ))

  This establishes that θ is provably equivalent to its mirror point,
  enabling self-referential constructions for incompleteness theorems.
*)

Theorem Recursive_Mirror_Lemma
  (MP : MirrorParams) (PF : ProvFormer) (D : DiagDevice) (rep : Prop) :
  Prov (Imp (theta MP PF D rep) (MirrorPointF MP PF D (theta MP PF D rep)))
  /\
  Prov (Imp (MirrorPointF MP PF D (theta MP PF D rep)) (theta MP PF D rep)).
Proof.
  exact (RecMirror.Recursive_Mirror_Lemma PF D rep).
Qed.


(* ---- theories/M003__Carryless_Proof_Theory/C018__Symbolic_Regulation/P1_R__Core.v ---- *)

(* P1_R__Core.v *)

(*************************************************************************)
(*                                                                       *)
(*  C018 / Phase 1 (R): Symbolic Regulation Core                         *)
(*                                                                       *)
(*  This file defines the core record for a symbolic regulator and       *)
(*  provides a bridge into the Mirror Lemma parameters.                  *)
(*                                                                       *)
(*************************************************************************)

From Coq Require Import Init.Logic.
From C004 Require Import P1_S__Context.
From C004 Require Import P2_R__Mirror_Core.

Set Implicit Arguments.
Unset Strict Implicit.

Module C_018_Symbolic_Regulation_R.

  Import C_004_Context.
  Module Mirror := C_004_Mirror_Core_R.

  (*************************************************************************)
  (*                                                                       *)
  (*  Symbolic Regulator Core                                              *)
  (*                                                                       *)
  (*************************************************************************)

  (*
    A symbolic regulator packages the primitives needed for regulated
    adoption. It is intentionally minimal. No properties are assumed
    beyond what later lemmas require.
    
    The field [ SR_ModelProv ] is left abstract so that different
    model interfaces can be instantiated later.
  *)

  Record SymbolicRegulator : Type := {
    SR_REG       : nat -> Form -> Prop;
    SR_BND       : Form -> Form -> Prop;
    SR_ProvT_P   : Form -> Prop;
    SR_ModelProv : Form -> Prop
  }.

  (*
    Bridge: every symbolic regulator induces [ MirrorParams ].
    This lets us reuse the Mirror Lemma machinery without re-deriving it.
  *)

  Definition SR_to_MirrorParams (SR : SymbolicRegulator) : Mirror.MirrorParams :=
    {| Mirror.REG     := SR.(SR_REG)
     ; Mirror.BND     := SR.(SR_BND)
     ; Mirror.ProvT_P := SR.(SR_ProvT_P)
    |}.

  (*************************************************************************)
  (*                                                                       *)
  (*  AsIF / Mir (delegated to C004)                                       *)
  (*                                                                       *)
  (*************************************************************************)

  (*
    AsIF, AsIF_simple, and Mir are defined by delegation to C004.
    This keeps the core small and stable.
  *)

  Definition AsIF (SR : SymbolicRegulator) (phi : Form) : Prop :=
    Mirror.AsIF (SR_to_MirrorParams SR) phi.

  Definition AsIF_simple (SR : SymbolicRegulator) (phi : Form) : Prop :=
    Mirror.AsIF_simple (SR_to_MirrorParams SR) phi.

  Definition Mir (SR : SymbolicRegulator) (phi : Form) : Prop :=
    Mirror.Mir (SR_to_MirrorParams SR) phi.

  (*
    Readable alias for non-refutability.
  *)

  Definition NonRefutable (SR : SymbolicRegulator) (phi : Form) : Prop :=
    AsIF_simple SR phi.

  (*************************************************************************)
  (*                                                                       *)
  (*  Basic Lemma                                                          *)
  (*                                                                       *)
  (*************************************************************************)

  (*
    AsIF implies its non-refutability fragment.
  *)

  Lemma AsIF_implies_AsIF_simple :
    forall (SR : SymbolicRegulator) (phi : Form),
      AsIF SR phi -> AsIF_simple SR phi.
  Proof.
    intros SR phi H.
    unfold AsIF, AsIF_simple in *.
    unfold Mirror.AsIF in H.
    unfold Mirror.AsIF_simple.
    destruct H as [i [b [_ [_ [_ Hnr]]]]].
    exact Hnr.
  Qed.

  Lemma AsIF_implies_NonRefutable :
    forall (SR : SymbolicRegulator) (phi : Form),
      AsIF SR phi -> NonRefutable SR phi.
  Proof.
    intros SR phi H; exact (@AsIF_implies_AsIF_simple SR phi H).
  Qed.

End C_018_Symbolic_Regulation_R.

Export C_018_Symbolic_Regulation_R.


(* ---- theories/M003__Carryless_Proof_Theory/C018__Symbolic_Regulation/P2_S__Interfaces.v ---- *)

(* P2_S__Interfaces.v *)

(*************************************************************************)
(*                                                                       *)
(*  C018 / Phase 2 (S): Interfaces                                       *)
(*                                                                       *)
(*  This facade re-exports the symbolic regulation core.                 *)
(*  Use it when you want a stable import surface.                        *)
(*                                                                       *)
(*************************************************************************)

From Coq Require Import Init.Logic.
From C018 Require Import P1_R__Core.

Set Implicit Arguments.
Unset Strict Implicit.

Module C_018_Symbolic_Regulation_S.
  Include C_018_Symbolic_Regulation_R.
End C_018_Symbolic_Regulation_S.

Export C_018_Symbolic_Regulation_S.


(* ---- theories/M003__Carryless_Proof_Theory/C018__Symbolic_Regulation/P3_R__Provability_Inclusion.v ---- *)

(* P3_R__Provability_Inclusion.v *)

(*************************************************************************)
(*                                                                       *)
(*  C018 / Phase 3 (R): Provability Inclusion (Core)                     *)
(*                                                                       *)
(*  Defines the structural inclusion predicate as a record.              *)
(*  This is the core shape; certificates live in the A-layer.            *)
(*                                                                       *)
(*************************************************************************)

From Coq Require Import Init.Logic.
From C004 Require Import P1_S__Context.
From C018 Require Import P1_R__Core.

Set Implicit Arguments.
Unset Strict Implicit.

Module C_018_Provability_Inclusion_R.

  Import C_004_Context.
  Module SR := C_018_Symbolic_Regulation_R.

  (*************************************************************************)
  (*                                                                       *)
  (*  Provability Inclusion Record                                         *)
  (*                                                                       *)
  (*************************************************************************)

  (*
    A provability inclusion gives a translation [ Embed ] together with
    two bridge conditions:
      (i)  If the model proves [ phi ], then [ T ] proves [ Embed phi ].
      (ii) If the model is consistent, then [ T ] is consistent.
  *)

  Record ProvabilityInclusion (R : SR.SymbolicRegulator) : Type := {
    Embed : Form -> Form;

    Include_Prov : forall phi : Form,
      R.(SR.SR_ModelProv) phi -> Prov (Embed phi);

    Include_Con :
      (~ R.(SR.SR_ModelProv) Bot) -> (~ Prov Bot)
  }.

  (*************************************************************************)
  (*                                                                       *)
  (*  Consistency Shorthands                                               *)
  (*                                                                       *)
  (*************************************************************************)

  Definition ModelConsistent (R : SR.SymbolicRegulator) : Prop :=
    ~ R.(SR.SR_ModelProv) Bot.

  Definition BaseConsistent : Prop :=
    ~ Prov Bot.

  Lemma Inclusion_preserves_consistency :
    forall (R : SR.SymbolicRegulator) (PI : ProvabilityInclusion R),
      ModelConsistent R -> BaseConsistent.
  Proof.
    intros R PI Hc.
    unfold ModelConsistent, BaseConsistent in *.
    exact (Include_Con PI Hc).
  Qed.

End C_018_Provability_Inclusion_R.

Export C_018_Provability_Inclusion_R.


(* ---- theories/M003__Carryless_Proof_Theory/C018__Symbolic_Regulation/P4_S__Mirror_Bridge.v ---- *)

(* P4_S__Mirror_Bridge.v *)

(*************************************************************************)
(*                                                                       *)
(*  C018 / Phase 4 (S): Mirror Bridge                                    *)
(*                                                                       *)
(*  Adapts a symbolic regulator into the C004 Mirror interface.          *)
(*                                                                       *)
(*************************************************************************)

From Coq Require Import Init.Logic.
From C004 Require Import P1_S__Context.
From C004 Require Import P2_R__Mirror_Core.
From C018 Require Import P1_R__Core.

Set Implicit Arguments.
Unset Strict Implicit.

Module C_018_Mirror_Bridge_S.

  Module SR := C_018_Symbolic_Regulation_R.
  Module Mirror := C_004_Mirror_Core_R.
  Import C_004_Context.

  (*************************************************************************)
  (*                                                                       *)
  (*  Bridge Definitions                                                   *)
  (*                                                                       *)
  (*************************************************************************)

  (*
    The bridge is a thin adapter. It translates [ SymbolicRegulator ] into
    [ MirrorParams ] and re-exports AsIF/Mir under the same Form.
  *)

  Definition ToMirrorParams (R : SR.SymbolicRegulator) : Mirror.MirrorParams :=
    SR.SR_to_MirrorParams R.

  Definition AsIF (R : SR.SymbolicRegulator) (phi : Form) : Prop :=
    SR.AsIF R phi.

  Definition Mir (R : SR.SymbolicRegulator) (phi : Form) : Prop :=
    SR.Mir R phi.

  (*************************************************************************)
  (*                                                                       *)
  (*  Fixed‑Witness Bridge                                                 *)
  (*                                                                       *)
  (*************************************************************************)

  (*
    If a fixed witness works for the underlying MirrorParams,
    then it works for the symbolic regulator as well.
  *)

  Theorem Mirror_fixed_witness_bridge :
    forall (R : SR.SymbolicRegulator) (i0 : nat) (b0 : Form),
      Mirror.REG (ToMirrorParams R) i0 b0 ->
      (forall phi : Form, Mirror.BND (ToMirrorParams R) phi b0) ->
      (forall phi : Form, Prov (Imp phi b0)) ->
      forall phi : Form,
        ~ Mirror.ProvT_P (ToMirrorParams R) (NotF phi) ->
        AsIF R phi.
  Proof.
    intros R i0 b0 REG0 BND0 PRV0 phi Hnr.
    unfold AsIF.
    apply (Mirror.Mirror_fixed_witness (MP := ToMirrorParams R)
                                       (i0 := i0) (b0 := b0));
      assumption.
  Qed.

  (*
    Schema form: the Mirror schema holds for all [ phi ] under fixed witnesses.
  *)

  Theorem Mir_schema_fixed_witness_bridge :
    forall (R : SR.SymbolicRegulator) (i0 : nat) (b0 : Form),
      Mirror.REG (ToMirrorParams R) i0 b0 ->
      (forall phi : Form, Mirror.BND (ToMirrorParams R) phi b0) ->
      (forall phi : Form, Prov (Imp phi b0)) ->
      forall phi : Form, Mir R phi.
  Proof.
    intros R i0 b0 REG0 BND0 PRV0 phi.
    exact (@Mirror.Mir_schema_fixed_witness (ToMirrorParams R)
                                            i0 b0 REG0 BND0 PRV0 phi).
  Qed.

End C_018_Mirror_Bridge_S.

Export C_018_Mirror_Bridge_S.


(* ---- theories/M003__Carryless_Proof_Theory/C018__Symbolic_Regulation/P5_T__Symbolic_Regulation.v ---- *)

(* P5_T__Symbolic_Regulation.v *)

(*************************************************************************)
(*                                                                       *)
(*  C018 / Phase 5 (T): Symbolic Regulation (Public Surface)             *)
(*                                                                       *)
(*  This file exposes the main symbolic-regulation interfaces.           *)
(*                                                                       *)
(*************************************************************************)

From Coq Require Import Init.Logic.
From C018 Require Import P2_S__Interfaces.
From C018 Require Import P4_S__Mirror_Bridge.
From C004 Require Import P1_S__Context.
From C004 Require Import P2_R__Mirror_Core.

Set Implicit Arguments.
Unset Strict Implicit.

(*
  Usage: import this file to access both the symbolic core and mirror bridge.
  Example:
  Module SR := C_018_Symbolic_Regulation_T.
  SR.SymbolicRegulator, SR.AsIF, SR.Mir, SR.ToMirrorParams ...
*)

Module C_018_Symbolic_Regulation_T.
  Include C_018_Symbolic_Regulation_S.
End C_018_Symbolic_Regulation_T.

Export C_018_Symbolic_Regulation_T.
Export C_018_Mirror_Bridge_S.

(*************************************************************************)
(*                                                                       *)
(*  Public Bridge Lemma                                                   *)
(*                                                                       *)
(*************************************************************************)

Module C_018_Symbolic_Regulation_Public.

  Import C_004_Context.
  Module SR := C_018_Symbolic_Regulation_T.
  Module Bridge := C_018_Mirror_Bridge_S.

  (*
    Public wrapper: fixed-witness Mirror Lemma for symbolic regulators.
  *)

  Theorem Mirror_fixed_witness :
    forall (R : SR.SymbolicRegulator) (i0 : nat) (b0 : Form),
      C_004_Mirror_Core_R.REG (Bridge.ToMirrorParams R) i0 b0 ->
      (forall phi : Form, C_004_Mirror_Core_R.BND (Bridge.ToMirrorParams R) phi b0) ->
      (forall phi : Form, Prov (Imp phi b0)) ->
      forall phi : Form,
        ~ C_004_Mirror_Core_R.ProvT_P (Bridge.ToMirrorParams R) (NotF phi) ->
        Bridge.AsIF R phi.
  Proof.
    intros R i0 b0 REG0 BND0 PRV0 phi Hnr.
    exact (@Bridge.Mirror_fixed_witness_bridge R i0 b0 REG0 BND0 PRV0 phi Hnr).
  Qed.

  (*
    Public wrapper: AsIF implies its non-refutability fragment.
  *)

  Theorem AsIF_implies_AsIF_simple :
    forall (R : SR.SymbolicRegulator) (phi : Form),
      SR.AsIF R phi -> SR.AsIF_simple R phi.
  Proof.
    intros R phi H.
    exact (@SR.AsIF_implies_AsIF_simple R phi H).
  Qed.

  (*
    Public wrapper: schema form under fixed witnesses.
  *)

  Theorem Mir_schema_fixed_witness :
    forall (R : SR.SymbolicRegulator) (i0 : nat) (b0 : Form),
      C_004_Mirror_Core_R.REG (Bridge.ToMirrorParams R) i0 b0 ->
      (forall phi : Form, C_004_Mirror_Core_R.BND (Bridge.ToMirrorParams R) phi b0) ->
      (forall phi : Form, Prov (Imp phi b0)) ->
      forall phi : Form,
        Bridge.Mir R phi.
  Proof.
    intros R i0 b0 REG0 BND0 PRV0 phi.
    exact (@Bridge.Mir_schema_fixed_witness_bridge R i0 b0 REG0 BND0 PRV0 phi).
  Qed.

End C_018_Symbolic_Regulation_Public.

(* ---- theories/M003__Carryless_Proof_Theory/C018__Symbolic_Regulation/P6_A__Provability_Inclusion.v ---- *)

(* P6_A__Provability_Inclusion.v *)

(*************************************************************************)
(*                                                                       *)
(*  C018 / Phase 6 (A): Provability Inclusion Certificate                *)
(*                                                                       *)
(*  This file provides the certificate type without postulating any      *)
(*  instance.                                                            *)
(*                                                                       *)
(*************************************************************************)

From Coq Require Import Init.Logic.
From C018 Require Import P1_R__Core.
From C018 Require Import P3_R__Provability_Inclusion.

Set Implicit Arguments.
Unset Strict Implicit.

Module C_018_Provability_Inclusion_A.

  Module SR := C_018_Symbolic_Regulation_R.
  Module PI := C_018_Provability_Inclusion_R.

  (*************************************************************************)
  (*                                                                       *)
  (*  Certificate Type                                                     *)
  (*                                                                       *)
  (*************************************************************************)

  (*
    A certificate for a given regulator is simply an instance of the
    provability inclusion record. No axioms are introduced here.
  *)

  Definition Provability_Inclusion_Certificate
    (R : SR.SymbolicRegulator) : Type :=
    PI.ProvabilityInclusion R.

End C_018_Provability_Inclusion_A.

Export C_018_Provability_Inclusion_A.


(* ---- theories/M003__Carryless_Proof_Theory/C018__Symbolic_Regulation/P7_T__Limitative_Combinatorics.v ---- *)

(* P7_T__Limitative_Combinatorics.v *)

(*************************************************************************)
(*                                                                       *)
(*  C018 / Phase 7 (T): Limitative Combinatorics                         *)
(*                                                                       *)
(*  Finite-pattern principles and constraint interfaces for              *)
(*  regulator classification.                                            *)
(*                                                                       *)
(*************************************************************************)

From Coq Require Import Init.Logic.
From Coq Require Import Lists.List.
From C018 Require Import P1_R__Core.
From C018 Require Import P3_R__Provability_Inclusion.
From C004 Require Import P1_S__Context.

Set Implicit Arguments.
Unset Strict Implicit.

Module C_018_Limitative_Combinatorics_T.

  Module SR := C_018_Symbolic_Regulation_R.
  Module PI := C_018_Provability_Inclusion_R.
  Import ListNotations.
  Import SR.
  Import C_004_Context.

  (*************************************************************************)
  (*                                                                       *)
  (*  Principle Signatures                                                 *)
  (*                                                                       *)
  (*************************************************************************)

  (*
    A principle is a predicate on symbolic regulators.
  *)

  Definition Principle : Type := SR.SymbolicRegulator -> Prop.

  (*
    The finite pattern of principles P1..P10 is packaged as a record.
    This avoids any axioms and keeps the structure explicit.
  *)

  Record PrinciplePack : Type := {
    P1  : Principle; (* Externalization *)
    P2  : Principle; (* Presumption *)
    P3  : Principle; (* Dismissal *)
    P4  : Principle; (* Trust / Complacency *)
    P5  : Principle; (* Unity / Iterated Reflection *)
    P6  : Principle; (* Self‑Blindness *)
    P7  : Principle; (* Mirror Witness *)
    P8  : Principle; (* Epistemic Conservativity *)
    P9  : Principle; (* AsIF Normalization *)
    P10 : Principle  (* Omega Ascent *)
  }.

  (*************************************************************************)
  (*                                                                       *)
  (*  Named Principles (Definitions)                                       *)
  (*                                                                       *)
  (*************************************************************************)

  (*
    These definitions are intentionally conservative. They are concrete
    predicates (not axioms) and can be strengthened later.
  *)

  (*
    Externalization (current formalization).
    There exists some [ phi ] that is adopted under [ AsIF ].
    This is a weak, AsIF-level proxy for the modal export of undecidable
    content into a surrogate token.
  *)

  Definition Externalization_def : Principle :=
    fun R => exists phi : Form, AsIF R phi.

  (*
    Presumption (current formalization).
    There exists [ phi ] that is non-refutable, while the model does not
    certify its negation. This captures "treated as settled" without a
    boxed proof, in a weak AsIF sense.
  *)

  Definition Presumption_def : Principle :=
    fun R => exists phi : Form, NonRefutable R phi /\ ~ SR_ModelProv R (NotF phi).

  (*
    Dismissal (current formalization).
    The model certifies [ not phi ] while [ AsIF phi ] still holds.
    This encodes a forced blind spot under the regulator.
  *)

  Definition Dismissal_def : Principle :=
    fun R => exists phi : Form, SR_ModelProv R (NotF phi) /\ AsIF R phi.

  (*
    Trust / Complacency (current formalization).
    There exists [ phi ] that is both model-provable and AsIF-adopted.
    This is the weak proxy for forced trust under imperfect audit.
  *)

  Definition Trust_def : Principle :=
    fun R => exists phi : Form, SR_ModelProv R phi /\ AsIF R phi.

  (*
    Unity / Iterated Reflection (current formalization).
    Any AsIF-adopted statement is model-provable.
    This expresses a collapse direction only; the converse is not assumed.
  *)

  Definition Unity_def : Principle :=
    fun R => forall phi : Form, AsIF R phi -> SR_ModelProv R phi.

  (*
    Self-Blindness (current formalization).
    There exists [ phi ] that the model proves, but the regulator does not
    adopt via AsIF. This encodes "can see, cannot internalize."
  *)

  Definition SelfBlindness_def : Principle :=
    fun R => exists phi : Form, SR_ModelProv R phi /\ ~ AsIF R phi.

  (*
    Mirror Witness (current formalization).
    There exists [ phi ] adopted by AsIF that the model does not prove.
    This is a weak analogue of a witness to unboxed truth.
  *)

  Definition MirrorWitness_def : Principle :=
    fun R => exists phi : Form, AsIF R phi /\ ~ SR_ModelProv R phi.

  (*
    Epistemic Conservativity (current formalization).
    Model-provable statements are AsIF-adopted.
    This is a one-way shadow of conservativity.
  *)

  Definition ConservativityShadow_def : Principle :=
    fun R => forall phi : Form, SR_ModelProv R phi -> AsIF R phi.

  (*
    AsIF Normalization (current formalization).
    There exists [ phi ] such that AsIF holds for [ phi ] but not for
    its negation. This encodes a minimal normalization asymmetry.
  *)

  Definition NormalizationShadow_def : Principle :=
    fun R => exists phi : Form, AsIF R phi /\ ~ AsIF R (NotF phi).

  (*
    Omega Ascent (current formalization).
    There exists [ phi ] such that AsIF holds for [ phi ] and for its
    double negation. This is a weak surrogate for limit ascent.
  *)

  Definition OmegaAscent_def : Principle :=
    fun R => exists phi : Form, AsIF R phi /\ AsIF R (NotF (NotF phi)).

  (*
    A default pack that provides concrete inhabitants.
  *)

  Definition DefaultPrinciples : PrinciplePack := {|
    P1  := Externalization_def;
    P2  := Presumption_def;
    P3  := Dismissal_def;
    P4  := Trust_def;
    P5  := Unity_def;
    P6  := SelfBlindness_def;
    P7  := MirrorWitness_def;
    P8  := ConservativityShadow_def;
    P9  := NormalizationShadow_def;
    P10 := OmegaAscent_def
  |}.

  (*
    A regulator realizes a principle when the predicate holds.
  *)

  Definition Realizes (R : SR.SymbolicRegulator) (P : Principle) : Prop :=
    P R.

  (*************************************************************************)
  (*                                                                       *)
  (*  Named Aliases                                                        *)
  (*                                                                       *)
  (*************************************************************************)

  (*
    Convenience aliases that pin the narrative names to P1..P10.
    These are definitions, not additional assumptions.
  *)

  Definition Externalization (PP : PrinciplePack) : Principle := P1 PP.
  Definition Presumption (PP : PrinciplePack) : Principle := P2 PP.
  Definition Dismissal (PP : PrinciplePack) : Principle := P3 PP.
  Definition Trust (PP : PrinciplePack) : Principle := P4 PP.
  Definition Unity (PP : PrinciplePack) : Principle := P5 PP.
  Definition SelfBlindness (PP : PrinciplePack) : Principle := P6 PP.
  Definition MirrorWitness (PP : PrinciplePack) : Principle := P7 PP.
  Definition ConservativityShadow (PP : PrinciplePack) : Principle := P8 PP.
  Definition NormalizationShadow (PP : PrinciplePack) : Principle := P9 PP.
  Definition OmegaAscent (PP : PrinciplePack) : Principle := P10 PP.

  (*************************************************************************)
  (*                                                                       *)
  (*  Finite Pattern Interface                                             *)
  (*                                                                       *)
  (*************************************************************************)

  (*
    A pattern is a finite list of principles.
    A regulator realizes a pattern when it realizes each member.
  *)

  Definition Pattern : Type := list Principle.

  Definition RealizesPattern (R : SR.SymbolicRegulator) (Ps : Pattern) : Prop :=
    Forall (fun P => P R) Ps.

  (*
    Basic lemmas for reasoning about patterns.
  *)

  Lemma RealizesPattern_nil :
    forall R : SR.SymbolicRegulator, RealizesPattern R [].
  Proof.
    intro R; constructor.
  Qed.

  Lemma RealizesPattern_cons :
    forall (R : SR.SymbolicRegulator) (P : Principle) (Ps : Pattern),
      RealizesPattern R (P :: Ps) <-> (P R /\ RealizesPattern R Ps).
  Proof.
    intros R P Ps; split.
    - intro H; inversion H; subst; split; assumption.
    - intros [HP Hrest]; constructor; assumption.
  Qed.

  Lemma RealizesPattern_head :
    forall (R : SR.SymbolicRegulator) (P : Principle) (Ps : Pattern),
      RealizesPattern R (P :: Ps) -> P R.
  Proof.
    intros R P Ps H.
    destruct (proj1 (RealizesPattern_cons R P Ps) H) as [HP _].
    exact HP.
  Qed.

  Lemma RealizesPattern_tail :
    forall (R : SR.SymbolicRegulator) (P : Principle) (Ps : Pattern),
      RealizesPattern R (P :: Ps) -> RealizesPattern R Ps.
  Proof.
    intros R P Ps H.
    destruct (proj1 (RealizesPattern_cons R P Ps) H) as [_ Hrest].
    exact Hrest.
  Qed.

  Lemma RealizesPattern_singleton :
    forall (R : SR.SymbolicRegulator) (P : Principle),
      RealizesPattern R [P] <-> P R.
  Proof.
    intros R P; split.
    - intro H.
      destruct (proj1 (RealizesPattern_cons R P []) H) as [HP _].
      exact HP.
    - intro HP.
      apply (proj2 (RealizesPattern_cons R P [])).
      split.
      + exact HP.
      + apply RealizesPattern_nil.
  Qed.

  Lemma RealizesPattern_app :
    forall (R : SR.SymbolicRegulator) (Ps Qs : Pattern),
      RealizesPattern R (Ps ++ Qs) <-> (RealizesPattern R Ps /\ RealizesPattern R Qs).
  Proof.
    intros R Ps Qs; unfold RealizesPattern.
    rewrite Forall_app; tauto.
  Qed.

  (*
    The full signature pattern (P1..P10) as a single list.
  *)

  Definition FullPattern (PP : PrinciplePack) : Pattern :=
    [ Externalization PP
    ; Presumption PP
    ; Dismissal PP
    ; Trust PP
    ; Unity PP
    ; SelfBlindness PP
    ; MirrorWitness PP
    ; ConservativityShadow PP
    ; NormalizationShadow PP
    ; OmegaAscent PP
    ].

  (*
    A convenience lemma: full pattern realization is just list realization.
    It is phrased as a named alias for clarity in downstream proofs.
  *)

  Definition RealizesFullPattern
    (PP : PrinciplePack) (R : SR.SymbolicRegulator) : Prop :=
    RealizesPattern R (FullPattern PP).

  (*************************************************************************)
  (*                                                                       *)
  (*  Constraint Interface                                                 *)
  (*                                                                       *)
  (*************************************************************************)

  Record ConstraintInterface : Type := {
    CI_Constraint : Type;
    CI_Extract : SR.SymbolicRegulator -> list CI_Constraint;
    CI_Satisfies : list CI_Constraint -> Prop
  }.

  Definition Membership (CI : ConstraintInterface) (R : SR.SymbolicRegulator) : Prop :=
    CI.(CI_Satisfies) (CI.(CI_Extract) R).

End C_018_Limitative_Combinatorics_T.

Export C_018_Limitative_Combinatorics_T.
